<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sanitizer Enna1's blog</title><link>https://enna1.github.io/tags/sanitizer/</link><description> Sanitizer Enna1's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 14 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://enna1.github.io/tags/sanitizer/index.xml" rel="self" type="application/rss+xml"/><item><title>Strict Aliasing, TBAA and TypeSanitizer</title><link>https://enna1.github.io/post/strict_aliasing-tbaa-and-type_sanitizer/</link><pubDate>Mon, 14 Nov 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/strict_aliasing-tbaa-and-type_sanitizer/</guid><description>&lt;p>本文首先介绍了 C++ 中的 strict aliasing rule，然后深入分析编译器是如何利用 strict aliasing rule 对程序进行分析优化的，之后介绍了检测 strict aliasing violation 的动态分析工具 TypeSanitizer，最后介绍如何在编程时避免写出 strict aliasing violation 的代码。&lt;/p>
&lt;h2 id="strict-aliasing-rule">Strict Aliasing Rule&lt;/h2>
&lt;p>首先，我们通过一个例子看下 strict aliasing rule 指的是什么？&lt;/p>
&lt;p>考虑如下代码 &lt;a href="https://godbolt.org/z/bjMMhjWaf">Compiler Explorer&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> &lt;span style="color:#a6e22e">i_am_clever&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>i, &lt;span style="color:#66d9ef">float&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isnan(&lt;span style="color:#f92672">*&lt;/span>f))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>i &lt;span style="color:#f92672">^=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f; &lt;span style="color:#75715e">// Do we need to load *f again here?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">=&lt;/span> i_am_clever((&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span>f, &lt;span style="color:#f92672">&amp;amp;&lt;/span>f);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%f&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, f);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述代码，不管是 GCC 还是 Clang 在 O3 优化等级下运行结果都是 5.000000，但是在 O0 的优化等级下运行结果就是 -5.000000。如果在 O3 优化等级下再加 &lt;code>-fno-strict-aliasing&lt;/code> 编译选项，此时运行结果就又变成了 -5.000000。&lt;/p>
&lt;p>为什么会出现上述现象？简单来说就是上述代码因违反了 strict aliasing rule 而导致代码中存在定义行为 (Undefined Behavior, UB)，而一旦程序中有了未定义行为，则什么事情都有可能发生了。&lt;/p>
&lt;p>有关 strict aliasing rule 在 &lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">C++ 17 标准&lt;/a>中 [basic.lval] 一节有如下描述：&lt;/p>
&lt;blockquote>
&lt;p>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:&lt;/p>
&lt;p>(8.1) — the dynamic type of the object,&lt;/p>
&lt;p>(8.2) — a cv-qualified version of the dynamic type of the object,&lt;/p>
&lt;p>(8.3) — a type similar (as defined in 7.5) to the dynamic type of the object,&lt;/p>
&lt;p>(8.4) — a type that is the signed or unsigned type corresponding to the dynamic type of the object,&lt;/p>
&lt;p>(8.5) — a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,&lt;/p>
&lt;p>(8.6) — an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),&lt;/p>
&lt;p>(8.7) — a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,&lt;/p>
&lt;p>(8.8) — a char, unsigned char, or std::byte type.&lt;/p>
&lt;p>The intent of this list is to specify those circumstances in which an object may or may not be aliased.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4849.pdf">C++ 20 标准&lt;/a>中 [basic.lval] 一节的描述则更为精简：&lt;/p>
&lt;blockquote>
&lt;p>If a program attempts to access (3.1) the stored value of an object through a glvalue whose type is not similar (7.3.5) to one of the following types the behavior is undefined:&lt;/p>
&lt;p>(11.1) — the dynamic type of the object,&lt;/p>
&lt;p>(11.2) — a type that is the signed or unsigned type corresponding to the dynamic type of the object, or&lt;/p>
&lt;p>(11.3) — a char, unsigned char, or std::byte type.&lt;/p>
&lt;p>The intent of this list is to specify those circumstances in which an object may or may not be aliased.&lt;/p>
&lt;/blockquote>
&lt;p>因为我不是 C++ language lawyer，所以也就不尝试一一解释上述标准中每一条描述的情况了，在 &lt;a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8#what-the-c17-draft-standard-say">What is Strict Aliasing and Why do we Care? · GitHub&lt;/a> 这篇文章中，作者对 C++ 17 标准中规定的每一种情况都列举了对应的示例代码来解释说明。&lt;/p>
&lt;p>由于上述 C++ 标准的存在，所以编译器认为：如果两个指针指向的对象&lt;strong>类型&lt;/strong>不同，那么这两个指针指向的就是不同的内存，或者说这两个指针没有别名关系，这就是 strict aliasing rule（char, unsigned char 和 std::byte 是例外，通过 char, unsigned char 或 std::byte 类型的指针能够合法访问任意其他类型的对象）。&lt;/p>
&lt;p>回到我们最开始的例子，函数 &lt;code>i_am_clever&lt;/code> 想实现的是：如果浮点数 float 不是 NaN (not-a-number)，那么就通过将其最高位取反（IEEE Floating Point 定义最高位是符号位），得到该浮点数的相反数。&lt;/p>
&lt;p>因为函数 &lt;code>i_am_clever&lt;/code> 的参数类型是 &lt;code>unsigned int *i, float *f&lt;/code> ，编译器认为指针 &lt;code>i&lt;/code> 和指针 &lt;code>f&lt;/code> 指向的不是同一内存，所以编译器认为 &lt;code>*i ^= 1 &amp;lt;&amp;lt; 31;&lt;/code> 这条语句不会修改 &lt;code>*f&lt;/code> 的值，而函数 &lt;code>i_am_clever&lt;/code> 的返回值是 &lt;code>*f&lt;/code>，所以编译器将函数 &lt;code>i_am_clever&lt;/code> 优化成类似如下代码的形式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> &lt;span style="color:#a6e22e">i_am_clever&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>i, &lt;span style="color:#66d9ef">float&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isnan(tmp))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>i &lt;span style="color:#f92672">^=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即在调用 &lt;code>isnan&lt;/code> 时，&lt;code>*f&lt;/code> 的值是多少，函数的返回值就是多少，这样就可以减少一次从内存中 load &lt;code>*f&lt;/code> 的操作。这样就能理解为什么不管是 GCC 还是 Clang 在 O3 优化等级下上述例子的运行结果都是 5.000000 了。&lt;/p>
&lt;p>那么问题来了，编译器是如何根据指针指向的对象类型来判断两个指针是否有别名关系的呢？答案是 Type Based Alias Analysis (TBAA)。下面 &amp;ldquo;Type Based Alias Analysis&amp;rdquo; 这一节将详细介绍 TBAA 的原理以及 LLVM 中的实现。&lt;/p>
&lt;p>注：clang 在 O0 以上优化等级时会开 TBAA，如果添加 &lt;code>-fno-strict-aliasing&lt;/code> 编译选项则不会开启 TBAA，&lt;a href="https://github.com/llvm/llvm-project/blob/llvmorg-15.0.0/clang/lib/CodeGen/CodeGenTBAA.cpp#L226">llvm-project/CodeGenTBAA.cpp&lt;/a>。&lt;/p>
&lt;h2 id="type-based-alias-analysis">Type Based Alias Analysis&lt;/h2>
&lt;p>所谓 Alias Analysis 即别名分析（又称 Pointer Analyis 即指针分析），是编译器程序分析中的一种技术，简单来说就是用于判断两个指针是否指向内存中的同一对象。&lt;/p>
&lt;p>别名分析有很多种算法，Type Based Alias Analysis (TBAA) 就是其中一种经典的算法。TBAA 算法由 Amer Diwan 等人在论文 &lt;a href="https://dl.acm.org/citation.cfm?id=277670">Type-Based Alias Analysis - PLDI'98&lt;/a> 中提出，是一种适用于 type-safe 编程语言的高效而精确的别名分析算法。&lt;/p>
&lt;p>在本节我们先学习下 TBAA 论文原文中的算法，然后再学习下 TBAA 在 LLVM 中的实现。&lt;/p>
&lt;h3 id="paper">Paper&lt;/h3>
&lt;p>&lt;a href="https://dl.acm.org/citation.cfm?id=277670">Type-Based Alias Analysis - PLDI'98&lt;/a> 这篇论文在介绍 TBAA 算法时是基于 Modula-3 这个编程语言来进行说明的，所以我们得先了解下 Modula-3 这个编程语言。&lt;/p>
&lt;p>Modula-3 是一门 staticlly typed, type-safe 的编程语言。在 Modula-3 中有三种 memory referneces：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Notation&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>p.f&lt;/code>&lt;/td>
&lt;td>Qualify&lt;/td>
&lt;td>Access field &lt;em>f&lt;/em> of object &lt;em>p&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>p^&lt;/code>&lt;/td>
&lt;td>Deference&lt;/td>
&lt;td>Deference pointer &lt;em>p&lt;/em>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>p[i]&lt;/code>&lt;/td>
&lt;td>Subscript&lt;/td>
&lt;td>Array &lt;em>p&lt;/em> with subscript &lt;em>i&lt;/em>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如上表所示，在 Modula-3 中 &lt;code>p.f&lt;/code> 表示访问对象 &lt;code>p&lt;/code> 的 &lt;code>f&lt;/code> 字段；&lt;code>p^&lt;/code> 表示对指针 &lt;code>p&lt;/code> 解引用；&lt;code>p[i]&lt;/code> 表示访问数组 &lt;code>p&lt;/code> 的第 &lt;code>i&lt;/code> 个元素。&lt;/p>
&lt;p>在该论文中还有一些符号定义：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将访问内存的表达式称为 &lt;em>access path&lt;/em> ($\mathcal{AP}$)，例如 &lt;code>a^.b[i].c&lt;/code> 就是一个 &lt;em>access path&lt;/em>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$Type(p)$ 表示 $\mathcal{AP}$ p 的 static type。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>$Subtypes(T)$ 表示由类型 T 和 T 的所有子类型所构成的集合。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>并且在 Modula-3 中，类型转换只允许在基类和它的子类之间进行，同时类型 T 的 memory references 能够访问类型 T 及子类的所有字段。&lt;/p>
&lt;p>论文中介绍了三种基于类型来做别名分析的算法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>TypeDecl&lt;/strong>：非常保守的分析，如果两个内存引用/指针具有&lt;strong>相同的类型&lt;/strong>，就认为它们可能互为别名，即可能指向同一内存对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>FieldTypeDecl&lt;/strong>：使用字段的类型声明和程序的其他高级信息（如某个字段、数组元素是否被执行过&lt;strong>取地址&lt;/strong>操作）来改进 TypeDecl，使得 FieldTypeDecl 的别名分析比 TypeDecl 更精确。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>SMTypeRefs&lt;/strong> (Selectively Merge Type References)：通过分析程序中的赋值语句 (assignments) 来更准确地实现别名分析。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="typedecl">TypeDecl&lt;/h4>
&lt;p>TypeDecl TBAA 的思想很简单，给定一个 $\mathcal{AP}$ p，TypeDecl 非常保守地认为 p 可能访问所有与 Type(p) 有相同类型或子类型的对象。&lt;/p>
&lt;p>更形式化一点的定义：给定两个 $\mathcal{AP}$s p 和 q，TypeDecl(p, q) 认为 p 和 q 互为别名当且仅当 $Subtypes(Type(p)) \cap Subtypes(Type(q)) \ne \emptyset$ 。&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;pre tabindex="0">&lt;code>TYPE
    T = OBJECT f, g: T; END;
    S1 = T OBJECT ... END;
    S2 = T OBJECT ... END;
    S3 = T OBJECT ... END;
VAR
    t: T;
    s: S1;
    u: S2;
&lt;/code>&lt;/pre>&lt;p>因为 S1 和 S2 都是 T 的子类，所以 TypeDecl 认为 t 和 s 可能互为别名，t 和 u 可能互为别名：$Subtypes(Type(t)) \cap Subtypes(Type(s)) = {T, S1, S2, S3} \cap {S1} = {S1} \ne \emptyset$，$Subtypes(Type(t)) \cap Subtypes(Type(u)) = {T, S1, S2, S3} \cap {S2} = {S2} \ne \emptyset$ 。&lt;/p>
&lt;p>但是 TypeDecl 认为 s 和 u 一定不会互为别名，因为 $Subtypes(Type(s)) \cap Subtypes(Type(u)) = {S1} \cap {S2} = \emptyset$ 。&lt;/p>
&lt;h4 id="fieldtypedecl">FieldTypeDecl&lt;/h4>
&lt;p>FieldTypeDecl TBAA 使用字段的类型声明和程序的其他高级信息（如某个字段、数组元素是否被执行过&lt;strong>取地址&lt;/strong>操作）来改进 TypeDecl，使得 FieldTypeDecl 的别名分析比 TypeDecl 更精确。&lt;/p>
&lt;p>和 TypeDecl 类似，给定两个 $\mathcal{AP}$s p 和 q，FieldTypeDecl(p, q) 返回 p 和 q 是否可能互为别名。FieldTypeDecl 的具体算法如下表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Case&lt;/th>
&lt;th>$\mathcal{AP}$ 1&lt;/th>
&lt;th>$\mathcal{AP}$ 2&lt;/th>
&lt;th>FieldTypeDecl($\mathcal{AP}$ 1, $\mathcal{AP}$ 2)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>&lt;code>p&lt;/code>&lt;/td>
&lt;td>&lt;code>p&lt;/code>&lt;/td>
&lt;td>$true$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>&lt;code>p.f&lt;/code>&lt;/td>
&lt;td>&lt;code>q.g&lt;/code>&lt;/td>
&lt;td>$(f = g) \land FieldTypeDecl(p, q)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;code>p.f&lt;/code>&lt;/td>
&lt;td>&lt;code>q^&lt;/code>&lt;/td>
&lt;td>$AddressTaken(p.f) \land TypeDecl(p.f, q\hat{})$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;code>p^&lt;/code>&lt;/td>
&lt;td>&lt;code>q[i]&lt;/code>&lt;/td>
&lt;td>$AddressTaken(q[i]) \land TypeDecl(p\hat{}, q[i])$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>&lt;code>p.f&lt;/code>&lt;/td>
&lt;td>&lt;code>q[i]&lt;/code>&lt;/td>
&lt;td>$false$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>&lt;code>p[i]&lt;/code>&lt;/td>
&lt;td>&lt;code>q[i]&lt;/code>&lt;/td>
&lt;td>$FieldTypeDecl(p, q)$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>&lt;code>p&lt;/code>&lt;/td>
&lt;td>&lt;code>q&lt;/code>&lt;/td>
&lt;td>$TypeDecl(p, q)$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>$AddressTaken(p) = true$ 表示程序中曾经对 p 有过取地址的操作。例如 $AddressTaken(p.f) = true$ 说明程序中曾经对 TypeDecl(p) 类型的对象的 f 字段有过取地址操作；$AddressTaken(q[i]) = true$ 说明程序中曾经对数组 q 的某些元素有过取地址操作。&lt;/p>
&lt;p>FieldTypeDecl 的别名分析比 TypeDecl 更精确，比如对于同一对象的不同字段 &lt;code>t.f&lt;/code> 和 &lt;code>t.g&lt;/code>，即使它们有着相同的类型，但是因为它们访问的是不同的字段，所以 FieldTypeDecl 会认为它们没有别名关系。&lt;/p>
&lt;p>这里需要额外解释一下 case 5，在 Modula-3 编程语言中取数组下标的表达式一定不会和访问对象某个字段的表达书互为别名。&lt;/p>
&lt;h4 id="smtyperefs">SMTypeRefs&lt;/h4>
&lt;p>SMTypeRefs 即 Selectively Merge Type References，通过分析程序中的赋值语句 (assignments) 来更准确地实现别名分析。&lt;/p>
&lt;p>给定一个 $\mathcal{AP}$ p，TypeDecl 非常保守地认为 p 可能访问所有与 Type(p) 有相同类型或子类型的对象。但是这样就有一个问题，考虑如下的代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>TYPE
    T = OBJECT f, g: T; END;
    S1 = T OBJECT ... END;
    S2 = T OBJECT ... END;
    S3 = T OBJECT ... END;
VAR
    t: T := NEW (T);
    s: S1 := NEW (S1);
&lt;/code>&lt;/pre>&lt;p>对于上述代码，TypeDecl 认为 t 和 s 可能互为别名，但是显然 t 和 s 之间没有任何直接或间接的赋值语句使他们指向同一个内存对象，所以他们一定不会互为别名。SMTypeRefs 就是在 TypeDecl 的基础上通过分析程序中的赋值语句来提高别名分析的精确度。&lt;/p>
&lt;p>SMTypeRefs 的算法伪代码如下图所示：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/strict_aliasing-tbaa-and-type_sanitizer/2022-11-14-09-30-04-image.png" alt="">&lt;/p>
&lt;p>给定两个 $\mathcal{AP}$s p 和 q，SMTypeRefs(p, q) 认为 p 和 q 互为别名当且仅当 $TypeRefsTable(Type(p)) \cap TypeRefsTable(Type(q)) \ne \emptyset$ 。&lt;/p>
&lt;p>举个例子来解释 SMTypeRefs TBAA 算法：&lt;/p>
&lt;pre tabindex="0">&lt;code>TYPE
    T = OBJECT f, g: T; END;
    S1 = T OBJECT ... END;
    S2 = T OBJECT ... END;
    S3 = T OBJECT ... END;
VAR
    s1: S1 := NEW (S1);
    s2: S2 := NEW (S2);
    s3: S3 := NEW (S3);
    t: T
BEGIN
    t := s1; (* Statement 1*)
    t := s2; (* Statement 2*)
END
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>Step 1：初始化 Group 集合：{ {T}, {S1}, {S2}, {S3} }&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Step 2：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>根据 &lt;code>t := s1; (* Statement 1*)&lt;/code> 更新 Group：Type(t) = T, Type(s1) = S1, Ga = {T}, Gb = {S1}, Group = { {T}, {S1}, {S2}, {S3} } - {T} - {S1} + {T, S1} = { {T, S1}, {S2}, {S3} }&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据 &lt;code>t := s2; (* Statement 2*)&lt;/code> 再更新 Group：Type(t) = T, Type(s2) = S2, Ga = {T, S1}, Gb = {S2}, Group = { {T, S1}, {S2}, {S3} } - {T, S1} - {S2} + {T, S1, S2} = { {T, S1, S2}, {S3} }&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Step 3：根据 Group 集合得到 TypeRefsTable 如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Type&lt;/th>
&lt;th>TypeRefsTable(Type)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>T&lt;/td>
&lt;td>T, S1, S2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S1&lt;/td>
&lt;td>S1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S2&lt;/td>
&lt;td>S2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>S3&lt;/td>
&lt;td>S3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;p>所以根据 TypeRefsTable，可以得到：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>t 和 s1 可能互为别名，因为 $SMTypeRefs(t, s1) = TypeRefsTable(Type(t)) \cap TypeRefsTable(Type(s1)) = {T, S1, S2} \cap {S1} = {S1} \ne \emptyset$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>t 和 s2 可能互为别名，因为 $SMTypeRefs(t, s2) = TypeRefsTable(Type(t)) \cap TypeRefsTable(Type(s2)) = {T, S1, S2} \cap {S2} = {S2} \ne \emptyset$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>s1 和 s2 不可能互为别名，因为 $SMTypeRefs(s1, s2) = TypeRefsTable(Type(s1)) \cap TypeRefsTable(Type(s2)) = {S1} \cap {S2} = \emptyset$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="implementation-in-llvm">Implementation in LLVM&lt;/h3>
&lt;p>TBAA 在 LLVM 中是以一种称为 metadata-based TBAA 的方式实现的。因为在 LLVM IR 上，内存是没有类型的，所以直接基于 LLVM 的类型系统做 TBAA 不太合适。Metadata-based TBAA 指的是：基于 LLVM 的编译器（如 clang）在前端生成 LLVM IR 时会在指令上 attach 一些 metadata，这些 metadata 描述了高级语言的类型系统信息，LLVM 就是基于这些 metadata 来做 TBAA 分析的。&lt;/p>
&lt;p>本节我们以如下代码为例说明 LLVM 中 TBAA 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S1&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> i; &lt;span style="color:#66d9ef">long&lt;/span> l; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S2&lt;/span> { &lt;span style="color:#66d9ef">float&lt;/span> f; &lt;span style="color:#66d9ef">double&lt;/span> d; S1 s; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(S1 &lt;span style="color:#f92672">*&lt;/span>p1, S2 &lt;span style="color:#f92672">*&lt;/span>p2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>s.i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> p1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>clang++ -O3 -S -emit-llvm struct-tbaa.cpp&lt;/code> 生成的 LLVM IR 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>%struct.S1 = type { i32, i64 }
%struct.S2 = type { float, double, %struct.S1 }
define i32 @_Z3fooP2S1P2S2(ptr %p1, ptr %p2) {
entry:
store i32 1, ptr %p1, align 8, !tbaa !5
%s = getelementptr inbounds %struct.S2, ptr %p2, i64 0, i32 2
store i32 2, ptr %s, align 8, !tbaa !11
%0 = load i32, ptr %p1, align 8, !tbaa !5
ret i32 %0
}
!5 = !{!6, !7, i64 0}
!6 = !{!&amp;#34;_ZTS2S1&amp;#34;, !7, i64 0, !10, i64 8}
!7 = !{!&amp;#34;int&amp;#34;, !8, i64 0}
!8 = !{!&amp;#34;omnipotent char&amp;#34;, !9, i64 0}
!9 = !{!&amp;#34;Simple C++ TBAA&amp;#34;}
!10 = !{!&amp;#34;long&amp;#34;, !8, i64 0}
!11 = !{!12, !7, i64 16}
!12 = !{!&amp;#34;_ZTS2S2&amp;#34;, !13, i64 0, !14, i64 8, !6, i64 16}
!13 = !{!&amp;#34;float&amp;#34;, !8, i64 0}
!14 = !{!&amp;#34;double&amp;#34;, !8, i64 0}
&lt;/code>&lt;/pre>&lt;h4 id="tbaa-medata">TBAA medata&lt;/h4>
&lt;p>首先学习下 TBAA metadata 是什么。在函数 &lt;code>foo&lt;/code> 对应的 LLVM IR 中 load/store 指令之后都有形如 !tbaa !5 的内容，这就是 TBAA metadata。&lt;/p>
&lt;p>TBAA metadata node 一共有三种：scalar type node, struct type node 和 path tag node。TBAA type node 之间会形成 DAG。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>scalar type node&lt;/p>
&lt;p>下述 metadata node 都是 scalar type node。&lt;/p>
&lt;pre tabindex="0">&lt;code>!7 = !{!&amp;#34;int&amp;#34;, !8, i64 0}
!8 = !{!&amp;#34;omnipotent char&amp;#34;, !9, i64 0}
!9 = !{!&amp;#34;Simple C++ TBAA&amp;#34;}
!10 = !{!&amp;#34;long&amp;#34;, !8, i64 0}
!13 = !{!&amp;#34;float&amp;#34;, !8, i64 0}
!14 = !{!&amp;#34;double&amp;#34;, !8, i64 0}
&lt;/code>&lt;/pre>&lt;p>scalar type node 最多由三个字段组成：第一个字段通常是字符串，作为该 scalar type 的标识符；第二个字段表示该节点的父节点；第三个字段是一个常数，如果为 1 表示 &lt;a href="https://llvm.org/doxygen/classllvm_1_1AAResults.html#a2017d417fc2e73c8bcc5acb6a0688016">pointsToConstantMemory&lt;/a> 返回 true。&lt;/p>
&lt;p>例如 &lt;code>!13 = !{!&amp;quot;float&amp;quot;, !8, i64 0}&lt;/code> 该节点表示的类型是 float 类型，父节点是 &lt;code>!8 = !{!&amp;quot;omnipotent char&amp;quot;, !9, i64 0}&lt;/code>。&lt;/p>
&lt;p>&lt;code>!8 = !{!&amp;quot;omnipotent char&amp;quot;, !9, i64 0}&lt;/code> 表示的则是 char 类型，父节点是 &lt;code>!9 = !{!&amp;quot;Simple C++ TBAA&amp;quot;}&lt;/code>。这里为什么要在 char 之前加个 omnipotent（万能的） ？还记得我们在 Strict Aliasing Rule 一章中提到的 C++ 标准么，标准中规定 char, unsigned char 或 std::byte 类型的指针能够合法访问任意其他类型的对象，所以这里用 &amp;ldquo;omnipotent char&amp;rdquo; 表示 char 类型可能与任意其他类型之间存在别名关系。（注：C++ 标准中说的是 char, unsigned char 并没有包括 signed char，C 标准则是 char, signed char 和 unsigned char 都包含了，这里 clang 在处理 C++ 时“不太标准”，&lt;a href="https://github.com/llvm/llvm-project/blob/llvmorg-15.0.0/clang/lib/CodeGen/CodeGenTBAA.cpp#L121">为 signed char 也生成了 “omnipotent char” TBAA metadata node&lt;/a>）&lt;/p>
&lt;p>&lt;code>!9 = !{!&amp;quot;Simple C++ TBAA&amp;quot;}&lt;/code> 就是根节点了，所以只有一个标识符字段。这里 &amp;ldquo;Simple C++ TBAA&amp;rdquo; 的作用主要是说明这部分 LLVM IR 是 C++ 代码生成的。不同的编译器前端比如 clang, rustc 在生成 TBAA metadata 时生成的根结点是不同的，LLVM 优化时会保守地认为两个根节点不同的 type node 存在别名关系。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>struct type node&lt;/p>
&lt;p>struct type node 由标识符和多个 pair 组成，struct 有多少个成员变量就有多少个 pair。pair 的第一个元素表示成员变量的类型，指向其他的 TBAA type node，pair 的第二个字段表示成员变量的偏移。&lt;/p>
&lt;p>例如 struct S1 有 2 个成员变量，所以 &lt;code>!6 = !{!&amp;quot;_ZTS2S1&amp;quot;, !7, i64 0, !10, i64 8}&lt;/code> 由标识符和 2 个 pair 组成。&lt;code>!7&lt;/code> 表示 struct S1 的第一个成员变量类型是 int，&lt;code>i64 0&lt;/code> 表示 struct S1 的第一个成员变量的偏移是 0，&lt;code>!10&lt;/code> 表示 struct S1 的第二个成员变量类型是 long，&lt;code>i64 8&lt;/code> 表示 struct B 的第二个成员变量的偏移是 8。&lt;/p>
&lt;p>struct S2 有 3 个成员变量，所以 &lt;code>!12 = !{!&amp;quot;_ZTS2S2&amp;quot;, !13, i64 0, !14, i64 8, !6, i64 16}&lt;/code> 由标识符和 3 个 pair 组成。&lt;code>!13&lt;/code> 表示 struct S2 的第一个成员变量类型是 float，&lt;code>i64 0&lt;/code> 表示 struct S2 的第一个成员变量的偏移是 0，&lt;code>!14&lt;/code> 表示 struct S2 的第二个成员变量类型是 double，&lt;code>i64 8&lt;/code> 表示 struct B 的第二个成员变量的偏移是 8，&lt;code>!16&lt;/code> 表示 struct S2 的第三个成员变量类型是 struct S1，&lt;code>i64 16&lt;/code> 表示 struct B 的第三个成员变量的偏移是 16。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>path tag node&lt;/p>
&lt;p>path tag node 用于标识一次 load/store，attach 到 的 load/store 指令后的 &lt;code>!tbaa&lt;/code> 就是 TBAA path tag node。path tag node 由四个字段组成：第一个字段是 base type node，可以是 scalar type node 或 struct type node；第二个字段是 access type node，一定是 scalar type node；第三个字段是偏移；第四个字段是可选字段，与 scalar type node 的最后一个字段有着同样的意义，如果为 1 表示本次访问的是 &lt;a href="https://llvm.org/doxygen/classllvm_1_1AAResults.html#a2017d417fc2e73c8bcc5acb6a0688016">pointsToConstantMemory&lt;/a>。&lt;/p>
&lt;pre tabindex="0">&lt;code>p2-&amp;gt;s.i = 2
&lt;/code>&lt;/pre>&lt;p>对应的 LLVM IR 就是：&lt;/p>
&lt;pre tabindex="0">&lt;code> %s = getelementptr inbounds %struct.S2, ptr %p2, i64 0, i32 2
store i32 2, ptr %s, align 8, !tbaa !11
&lt;/code>&lt;/pre>&lt;p>&lt;code>!11 = !{!12, !7, i64 16}&lt;/code> path tag node 表示的就是对 &lt;code>S2.s.i&lt;/code> 的访问：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>!12&lt;/code> 表示 &lt;code>S2.s.i&lt;/code> 访问的 base type 是 _ZTS2S2 即 struct S2&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>!7&lt;/code> 表示 &lt;code>S2.s.i&lt;/code> 访问的 access type 是 int&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>i64 16&lt;/code> 表示 &lt;code>S2.s.i&lt;/code> 访问的 i 相对 S2 的偏移是 16&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="type-dag">Type DAG&lt;/h4>
&lt;p>TBAA type node 之间构成了一个 type DAG。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于 scalar type node，DAG 中会有一条以该节点为起点，以其父节点为终点的边。例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>!7 = !{!&amp;#34;int&amp;#34;, !8, i64 0}
!8 = !{!&amp;#34;omnipotent char&amp;#34;, !9, i64 0}
&lt;/code>&lt;/pre>&lt;p>在 DAG 中就存在一条由 int 节点指向 omnipotent char 节点的边。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 struct type node，DAG 中会有以该节点为起点，以其成员变量类型节点为终点的边。例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>!6 = !{!&amp;#34;_ZTS2S1&amp;#34;, !7, i64 0, !10, i64 8}
!7 = !{!&amp;#34;int&amp;#34;, !8, i64 0}
!10 = !{!&amp;#34;long&amp;#34;, !8, i64 0}
&lt;/code>&lt;/pre>&lt;p>在 DAG 中有两条以 struct S1 为起点的边，终点分别为节点 int 和节点 long。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>回到本节最开始我们给出的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S1&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> i; &lt;span style="color:#66d9ef">long&lt;/span> l; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">S2&lt;/span> { &lt;span style="color:#66d9ef">float&lt;/span> f; &lt;span style="color:#66d9ef">double&lt;/span> d; S1 s; };
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的 type DAG 如下图所示：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/strict_aliasing-tbaa-and-type_sanitizer/2022-11-21-10-43-30-image.png" alt="">&lt;/p>
&lt;h4 id="check-alias">Check Alias&lt;/h4>
&lt;p>现在我们已经知道了 LLVM IR 上的 TBAA metadata 保存了哪些信息，下面我们看下 LLVM 是如何根据这些 TBAA metadata 信息判断两个内存访问之间是否存在别名关系的。&lt;/p>
&lt;p>LLVM &lt;a href="https://github.com/llvm/llvm-project/blob/llvmorg-15.0.0/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp#L91">TBAA 源码&lt;/a>中的注释其实将怎样判断两次内存访问是否存在别名关系说明非常清楚了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// To check if two tags (tagX and tagY) can alias, we start from the base type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// of tagX, follow the edge with the correct offset in the type DAG and adjust
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// the offset until we reach the base type of tagY or until we reach the Root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// node.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If we reach the base type of tagY, compare the adjusted offset with
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// offset of tagY, return Alias if the offsets are the same, return NoAlias
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// otherwise.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If we reach the Root node, perform the above starting from base type of tagY
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// to see if we reach base type of tagX.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If they have different roots, they&amp;#39;re part of different potentially
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// unrelated type systems, so we return Alias to be conservative.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// If neither node is an ancestor of the other and they have the same root,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// then we say NoAlias.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">TypeBasedAliasAnalysis&lt;/span>(PathTagNodeX, PathTagNodeY){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (PathTagNodeX &lt;span style="color:#f92672">==&lt;/span> PathTagNodeY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Accesses with no TBAA information may alias with any other accesses.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>PathTagNodeX &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>PathTagNodeY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonType &lt;span style="color:#f92672">=&lt;/span> getLeastCommonType(PathTagNodeX.getAccessType(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PathTagNodeY.getAccessType());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If the access types have different roots, they&amp;#39;re part of different
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// potentially unrelated type systems, so we must be conservative.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>CommonType)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If one of the accessed objects may be a subobject of the other,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// then such accesses may alias.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> MayAlias;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mayBeAccessToSubobjectOf(&lt;span style="color:#75715e">/* BaseTag= */&lt;/span> PathTagNodeX,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* SubobjectTag= */&lt;/span> PathTagNodeY,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonType, MayAlias) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mayBeAccessToSubobjectOf(&lt;span style="color:#75715e">/* BaseTag= */&lt;/span> PathTagNodeY,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* SubobjectTag= */&lt;/span> PathTagNodeX,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonType, MayAlias))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> MayAlias;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Return true if for two given accesses, one of the accessed objects may be
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// a subobject of the other. The \p BaseTag and \p SubobjectTag parameters
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// describe the accesses to the base object and the subobject respectively.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// \p CommonType must be the metadata node describing the common type of the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// accessed objects. On return, \p MayAlias is set to true iff these accesses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// may alias.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">mayBeAccessToSubobjectOf&lt;/span>(TBAAStructTagNode BaseTag,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TBAAStructTagNode SubobjectTag,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> MDNode &lt;span style="color:#f92672">*&lt;/span>CommonType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>MayAlias) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If the base object is of the least common type, then this may be an access
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// to its subobject.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (BaseTag.getAccessType() &lt;span style="color:#f92672">==&lt;/span> BaseTag.getBaseType() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BaseTag.getAccessType() &lt;span style="color:#f92672">==&lt;/span> CommonType) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MayAlias &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If the access to the base object is through a field of the subobject&amp;#39;s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// type, then this may be an access to that field. To check for that we start
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// from the base type, follow the edge with the correct offset in the type DAG
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// and adjust the offset until we reach the field type or until we reach the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// access type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> TBAAStructTypeNode BaseType(BaseTag.getBaseType());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> OffsetInBase &lt;span style="color:#f92672">=&lt;/span> BaseTag.getOffset();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In the old format there is no distinction between fields and parent
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// types, so in this case we consider all nodes up to the root.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>BaseType.getNode()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(&lt;span style="color:#f92672">!&lt;/span>NewFormat &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Did not see access type in access path!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (BaseType.getNode() &lt;span style="color:#f92672">==&lt;/span> SubobjectTag.getBaseType()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> SameMemberAccess &lt;span style="color:#f92672">=&lt;/span> OffsetInBase &lt;span style="color:#f92672">==&lt;/span> SubobjectTag.getOffset();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MayAlias &lt;span style="color:#f92672">=&lt;/span> SameMemberAccess;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Follow the edge with the correct offset. Offset will be adjusted to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// be relative to the field type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> BaseType &lt;span style="color:#f92672">=&lt;/span> BaseType.getField(OffsetInBase);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们还是通过例子来学习：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(S1 &lt;span style="color:#f92672">*&lt;/span>p1, S2 &lt;span style="color:#f92672">*&lt;/span>p2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>s.i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> p1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>define i32 @_Z3fooP2S1P2S2(ptr %p1, ptr %p2) {
entry:
store i32 1, ptr %p1, align 8, !tbaa !5
%s = getelementptr inbounds %struct.S2, ptr %p2, i64 0, i32 2
store i32 2, ptr %s, align 8, !tbaa !11
%0 = load i32, ptr %p1, align 8, !tbaa !5
ret i32 %0
}
&lt;/code>&lt;/pre>&lt;p>编译器之所以没有将 foo 函数的返回值直接优化为 &lt;code>return 1&lt;/code> 是因为编译器发现 &lt;code>p2-&amp;gt;s.i&lt;/code> 和 &lt;code>p1-&amp;gt;i&lt;/code> 访问的可能是内存中的同一对象，即存在别名关系。也就是说 &lt;code>p2-&amp;gt;s.i = 2&lt;/code> 这一赋值语句可能会修改 &lt;code>p1-&amp;gt;i&lt;/code> 的值，所以不能将 foo 函数的返回值直接优化为 1，而是需要重新从内存中读取 &lt;code>p1-&amp;gt;i&lt;/code> 的值作为返回值。&lt;/p>
&lt;p>判断 &lt;code>p2-&amp;gt;s.i&lt;/code> 和 &lt;code>p1-&amp;gt;i&lt;/code> 之间是否有别名关系：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>p2-&amp;gt;s.i = 2&lt;/code> 对应的 LLVM IR 指令是 &lt;code>store i32 2, ptr %s, align 8, !tbaa !11&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>p1-&amp;gt;i = 1&lt;/code> 对应的 LLVM IR 指令是 &lt;code>store i32 1, ptr %p1, align 8, !tbaa !5&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>详细的 TBAA 算法流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>两个输入 PathTagNode 分别是 &lt;code>!11 = !{!12, !7, i64 16}&lt;/code> 和 &lt;code>!5 = !{!6, !7, i64 0}&lt;/code>。&lt;code>!11&lt;/code> 的 BaseType 是 &lt;code>!12&lt;/code> 即 struct S2，AccessType 是 &lt;code>!7&lt;/code> 即 int，Offset 是 16；&lt;code>!5&lt;/code> 的 BaseType 是 &lt;code>!6&lt;/code> 即 struct S1，AccessType 是 &lt;code>!7&lt;/code> 即 int，Offset 是 0。显然 &lt;code>!11&lt;/code> 和 &lt;code>!5&lt;/code> 都不为空，并且是不同的 PathTagNode，所以继续执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为 &lt;code>!11&lt;/code> 的 AccessType 就是 &lt;code>!7&lt;/code> 即 int 类型，&lt;code>!5&lt;/code> 的 AccessType 也是 &lt;code>!7&lt;/code>即 int 类型，所以 LeastCommonType 就是 int 类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>!11&lt;/code> 的 BaseType 是 &lt;code>!12&lt;/code> 即 struct S2，AccessType 是 &lt;code>!7&lt;/code> 即 int，Offset 是 16。根据 &lt;code>!12 = !{!&amp;quot;_ZTS2S2&amp;quot;, !13, i64 0, !14, i64 8, !6, i64 16}&lt;/code> 可知 struct S2 第三个成员变量的类型是 struct S1 且偏移就是 16。所以 PathTagNode &lt;code>!11&lt;/code> 可以转换为新的 PathTagNode：BaseType 变为 struct S1，AccessType 不变还是 int，Offset 变为 &lt;code>16 - 16 = 0&lt;/code>，即 &lt;code>!11 = !{!12, !7, i64 16} = !{!6, !7, i64 0}&lt;/code>。此时发现 &lt;code>!11&lt;/code> 和 &lt;code>!5&lt;/code> 实际上访问的是同一 BaseType(&lt;code>!6&lt;/code> 即 struct S1) 的同一 Offset 0，所以就认为 &lt;code>!11&lt;/code> 和 &lt;code>!5&lt;/code> 可能存在别名关系，即 &lt;code>p2-&amp;gt;s.i&lt;/code> 和 &lt;code>p1-&amp;gt;i&lt;/code> 访问的可能是内存中的同一对象！&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="typesanitizer">TypeSanitizer&lt;/h2>
&lt;p>TypeSanitizer(AKA TySan) 最早由 Hal Finkel 在 2017 年提出 &lt;a href="https://lists.llvm.org/pipermail/llvm-dev/2017-April/112189.html">RFC&lt;/a>，并且在 2017 LLVM Developers’ Meeting 做了&lt;a href="https://www.youtube.com/watch?v=vAXJeN7k32Y">分享&lt;/a>。但是截止本文撰写时，TypeSanitizer 的实现还没有被合入社区。最近 Florian Hahn 在 discourse 上发帖希望能 &lt;a href="https://discourse.llvm.org/t/reviving-typesanitizer-a-sanitizer-to-catch-type-based-aliasing-violations/66092">Reviving TypeSanitizer&lt;/a>，我也做了一点微小的工作，解决了 TypeSanitizer 在 Linux 下的编译和测试问题，希望后面也能帮忙推进 TypeSanitizer 的发展。&lt;/p>
&lt;p>TypeSanitizer 和其他 Sanitizer 如 AddressSanitizer, ThreadSanitizer 一样都是动态分析，TypeSanitizer 用于检测程序中的 type-based aliasing violations。通常 Sanitizer 由三部分组成：shadow mapping, compile-time instrumentation 和 runtime library。所以下面我们从这三个方面展开来介绍 TypeSanitizer 的原理。&lt;/p>
&lt;p>在本节，我们使用如下代码为例说明 TypeSanitizer 的原理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang++ -O3 -S -emit-llvm int-long.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>x, &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[[clang::optnone]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> main(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> l;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, foo((&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>l&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>l));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>foo&lt;/code> 函数对应的 LLVM IR 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>define i64 @_Z3fooPiPl(ptr %x, ptr %y) {
entry:
store i64 1, ptr %y, align 8, !tbaa !5
store i32 0, ptr %x, align 4, !tbaa !9
ret i64 0
}
!5 = !{!6, !6, i64 0}
!6 = !{!&amp;#34;long&amp;#34;, !7, i64 0}
!7 = !{!&amp;#34;omnipotent char&amp;#34;, !8, i64 0}
!8 = !{!&amp;#34;Simple C++ TBAA&amp;#34;}
!9 = !{!10, !10, i64 0}
!10 = !{!&amp;#34;int&amp;#34;, !7, i64 0}
&lt;/code>&lt;/pre>&lt;h3 id="shadow-mapping">Shadow Mapping&lt;/h3>
&lt;p>Sanitizer 广泛使用了 shadow memory 技术，通过使用额外的内存来记录常规内存的状态。&lt;/p>
&lt;p>例如 ASan 对于每 8-bytes 的 application memory 都使用 1-byte shadow memory 来标识对这 8-bytes application memory 的访问是否合法。&lt;/p>
&lt;p>TySan 的 shadow mapping 与 ASan 有所不同，TySan 对于每 1-byte 的 application memory 都使用 &lt;code>sizeof(void*)&lt;/code> bytes 的 shadow memory 来记录这 1-byte 的类型信息。TySan 的 shadow mapping 计算公式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>MemToShadow(addr) = (addr &amp;amp; SHADOW_MASK) * sizeof(void*) + SHADOW_OFFSET
&lt;/code>&lt;/pre>&lt;p>&lt;code>sizeof (void*)&lt;/code> 就是计算指针的大小，在 64 位环境下就是 64 bit，即 8-bytes。那么 TySan 的 shadow mapping 为什么设计成这样呢？这是因为 TySan 的 shadow memory 中存储的是指针，所以每 1-byte application memory 都要对应指针大小的 shadow memory。&lt;/p>
&lt;p>64 位环境下 4-bytes application memory 对应的 32-bytes shadow memory 的布局如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>+-----------------+-----------------+-----------------+-----------------+
|Access Descriptor| -1 | -2 | -3 |
+-----------------+-----------------+-----------------+-----------------+
&lt;/code>&lt;/pre>&lt;p>前 8-bytes 存储的是指向 Access Descriptor 的指针，后面 8-bytes 的内容依次是 -1, -2, -3 &amp;hellip;&lt;/p>
&lt;h3 id="instrumentation">Instrumentation&lt;/h3>
&lt;p>在编译时启用 TypeSanitizer 后，不管程序的优化等级是多少、不管是否添加了 &lt;code>-fno-strict-aliasing&lt;/code> 编译选项，clang 都会在生成的 LLVM IR 上添加 TBAA metadata。&lt;/p>
&lt;p>TypeSanitizer 编译时插桩主要做两个事情：generateTypeDescriptor 和 instrumentMemoryAccess。&lt;/p>
&lt;h4 id="generatetypedescriptor">generateTypeDescriptor&lt;/h4>
&lt;p>generateTypeDescriptor 就是将 TBAA metadata 转变为程序中的全局变量，TypeSanitizer 将这样的全局变量称作 TypeDescriptor。这样在程序运行时就可以根据这些 TBAA metadata/TypeDescriptor 判断内存访问时是否发生了 type-based aliasing violations。&lt;/p>
&lt;p>TypeDescriptor 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> { TYSAN_MEMBER_TD &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, TYSAN_STRUCT_TD &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_type_descriptor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr Tag; &lt;span style="color:#75715e">// 1 for member_type_descriptor, 2 for struct_type_descriptor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">union&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tysan_member_type_descriptor Member;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tysan_struct_type_descriptor Struct;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_member_type_descriptor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_type_descriptor&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Base;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_type_descriptor&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Access;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_struct_type_descriptor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr MemberCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">tysan_type_descriptor&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } Members[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">// Tail allocated.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// char Name[]; // Tail allocated.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>TBAA metadata 中的 path tag node 使用 tysan_member_type_descriptor 来表示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>TBAA metadata 中的 scalar type node 和 struct type node 使用 tysan_struct_type_descriptor 来表示&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>回到本节我们使用的例子，例子中的 TBAA metadata 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>define i64 @_Z3fooPiPl(ptr %x, ptr %y) {
entry:
store i64 1, ptr %y, align 8, !tbaa !5
store i32 0, ptr %x, align 4, !tbaa !9
ret i64 0
}
!5 = !{!6, !6, i64 0}
!6 = !{!&amp;#34;long&amp;#34;, !7, i64 0}
!7 = !{!&amp;#34;omnipotent char&amp;#34;, !8, i64 0}
!8 = !{!&amp;#34;Simple C++ TBAA&amp;#34;}
!9 = !{!10, !10, i64 0}
!10 = !{!&amp;#34;int&amp;#34;, !7, i64 0}
&lt;/code>&lt;/pre>&lt;p>对应的生成的 TypeDescriptor 如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>; !5 = !{!6, !6, i64 0} 对应 @__tysan_v1_long_o_0
@__tysan_v1_long_o_0 = linkonce_odr constant
{ i64, ptr, ptr, i64 }
{ i64 1, ptr @__tysan_v1_long, ptr @__tysan_v1_long, i64 0 }, comdat
; !6 = !{!&amp;#34;long&amp;#34;, !7, i64 0} 对应 @__tysan_v1_long
@__tysan_v1_long = linkonce_odr constant
{ i64, i64, ptr, i64, [5 x i8] }
{ i64 2, i64 1, ptr @__tysan_v1_omnipotent_20char, i64 0, [5 x i8] c&amp;#34;long\00&amp;#34; }, comdat
; !7 = !{!&amp;#34;omnipotent char&amp;#34;, !8, i64 0} 对应 @__tysan_v1_omnipotent_20char
@__tysan_v1_omnipotent_20char = linkonce_odr constant
{ i64, i64, ptr, i64, [16 x i8] }
{ i64 2, i64 1, ptr @__tysan_v1_Simple_20C_2b_2b_20TBAA, i64 0, [16 x i8] c&amp;#34;omnipotent char\00&amp;#34; }, comdat
; !8 = !{!&amp;#34;Simple C++ TBAA&amp;#34;} 对应 @__tysan_v1_Simple_20C_2b_2b_20TBAA
@__tysan_v1_Simple_20C_2b_2b_20TBAA = linkonce_odr constant
{ i64, i64, [16 x i8] }
{ i64 2, i64 0, [16 x i8] c&amp;#34;Simple C++ TBAA\00&amp;#34; }, comdat
; !9 = !{!10, !10, i64 0} 对应 @__tysan_v1_int_o_0
@__tysan_v1_int_o_0 = linkonce_odr constant
{ i64, ptr, ptr, i64 }
{ i64 1, ptr @__tysan_v1_int, ptr @__tysan_v1_int, i64 0 }, comdat
; !10 = !{!&amp;#34;int&amp;#34;, !7, i64 0} 对应 @__tysan_v1_int
@__tysan_v1_int = linkonce_odr constant
{ i64, i64, ptr, i64, [4 x i8] }
{ i64 2, i64 1, ptr @__tysan_v1_omnipotent_20char, i64 0, [4 x i8] c&amp;#34;int\00&amp;#34; }, comdat
&lt;/code>&lt;/pre>&lt;p>注意到，因为 TypeDescriptor 是根据 TBAA metadata 生成的，所以实际上这些 TypeDescriptor 是常量，在编译时确定，并且在运行中不会修改。&lt;/p>
&lt;h4 id="instrumentmemoryaccess">instrumentMemoryAccess&lt;/h4>
&lt;p>开启 TypeSanitizer 后， LLVM IR 的 load/store 指令会被添加 TBAA metadata。TypeSanitizer 会对这些 load/store 指令插桩代码，在运行时检测是否存在 type-based aliasing violations。插桩的代码就是函数 &lt;code>__tysan_access_callback&lt;/code> 中的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">instrumentMemoryAccess&lt;/span>(Instruction &lt;span style="color:#f92672">*&lt;/span>I) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemoryLocation ML &lt;span style="color:#f92672">=&lt;/span> MemoryLocation&lt;span style="color:#f92672">::&lt;/span>get(I);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr &lt;span style="color:#f92672">=&lt;/span> ML.Ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> AccessSize &lt;span style="color:#f92672">=&lt;/span> ML.Size.getValue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromMetadata &lt;span style="color:#f92672">=&lt;/span> TypeDescriptor(MLoc.AATags.TBAA);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// __tysan_access_callback is inserted by compiler instrumentation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __tysan_access_callback(Ptr, AccessSize, TypeDescriptorFromMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__tysan_access_callback&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> AccessSize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromMetadata) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ShadowData &lt;span style="color:#f92672">=&lt;/span> MemToShadow(Ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tysan_type_descriptor &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">=&lt;/span> ShadowData[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">!=&lt;/span> TypeDescriptorFromMetadata) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">/* unknown */&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> NotAllUnknownTypeDescriptor &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint64_t&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> AccessSize; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NotAllUnkTD &lt;span style="color:#f92672">|=&lt;/span> (ShadowData[i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e">/* unknown */&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (NotAllUnknownTypeDescriptor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tysan_check(Ptr, AccessSize, TypeDescriptorFromMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tysan_set(Ptr, AccessSize, TypeDescriptorFromMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tysan_check(Ptr, AccessSize, TypeDescriptorFromMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> NotAllBadTypeDescriptor &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint64_t&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> AccessSize; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NotAllBadTypeDescriptor &lt;span style="color:#f92672">|=&lt;/span> (ShadowData[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (NotAllBadTypeDescriptor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tysan_check(Ptr, AccessSize, TypeDescriptorFromMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="runtime-library">Runtime Library&lt;/h3>
&lt;p>&lt;code>__tysan_access_callback&lt;/code> 中调用的 &lt;code>__tysan_check&lt;/code> 函数是在 runtime library 中实现的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__tysan_check&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> AccessSize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromMetadata) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">**&lt;/span>ShadowData &lt;span style="color:#f92672">=&lt;/span> MemToShadow(Ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">=&lt;/span> ShadowData[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((sptr)TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sptr Offset &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>((sptr)TypeDescriptorFromShadowMemory);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShadowData &lt;span style="color:#f92672">-=&lt;/span> Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ShadowData;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isAliasingLegal(TypeDescriptorFromMetadata,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDescriptorFromShadowMemory))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isAliasingLegal(TypeDescriptorFromMetadata,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDescriptorFromShadowMemory)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint64_t&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> AccessSize; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDescriptorFromShadowMemory &lt;span style="color:#f92672">=&lt;/span> ShadowData[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (((sptr)TypeDescriptorFromShadowMemory) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">!&lt;/span>isAliasingLegal(TypeDescriptorFromMetadata,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeDescriptorFromShadowMemory))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reportError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__tysan_set&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Ptr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> AccessSize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>TypeDescriptorFromMetadata) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">**&lt;/span>ShadowData &lt;span style="color:#f92672">=&lt;/span> MemToShadow(Ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShadowData[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> TypeDescriptorFromMetadata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">uint64_t&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> AccessSize; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ShadowData[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>__tysan_check&lt;/code> 中判断是否存在 type-based aliasing violations 的核心是函数 &lt;code>isAliasingLegal&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isAliasingLegal&lt;/span>(tysan_type_descriptor &lt;span style="color:#f92672">*&lt;/span>TDA,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tysan_type_descriptor &lt;span style="color:#f92672">*&lt;/span>TDB) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDA &lt;span style="color:#f92672">==&lt;/span> TDB &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>TDB &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>TDA)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Aliasing is legal is the two types have different root nodes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (getRootTD(TDA) &lt;span style="color:#f92672">!=&lt;/span> getRootTD(TDB))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> isAliasingLegalUp(TDA, TDB) &lt;span style="color:#f92672">||&lt;/span> isAliasingLegalUp(TDB, TDA);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">isAliasingLegalUp&lt;/span>(tysan_type_descriptor &lt;span style="color:#f92672">*&lt;/span>TDA,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tysan_type_descriptor &lt;span style="color:#f92672">*&lt;/span>TDB) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Walk up the tree starting with TDA to see if we reach TDB.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> uptr OffsetA &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, OffsetB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDB&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Tag &lt;span style="color:#f92672">==&lt;/span> TYSAN_MEMBER_TD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OffsetB &lt;span style="color:#f92672">=&lt;/span> TDB&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Member.Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TDB &lt;span style="color:#f92672">=&lt;/span> TDB&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Member.Base;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Tag &lt;span style="color:#f92672">==&lt;/span> TYSAN_MEMBER_TD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OffsetA &lt;span style="color:#f92672">=&lt;/span> TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Member.Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TDA &lt;span style="color:#f92672">=&lt;/span> TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Member.Base;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDA &lt;span style="color:#f92672">==&lt;/span> TDB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> OffsetA &lt;span style="color:#f92672">==&lt;/span> OffsetB;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Tag &lt;span style="color:#f92672">==&lt;/span> TYSAN_STRUCT_TD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Struct.MemberCount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr Idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; Idx &lt;span style="color:#f92672">&amp;lt;&lt;/span> TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Struct.MemberCount &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>Idx) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Struct.Members[Idx].Offset &lt;span style="color:#f92672">&amp;gt;=&lt;/span> OffsetA)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OffsetA &lt;span style="color:#f92672">-=&lt;/span> TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Struct.Members[Idx].Offset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TDA &lt;span style="color:#f92672">=&lt;/span> TDA&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Struct.Members[Idx].Type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (TDA);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你对照 LLVM TBAA 中 &lt;code>TypeBasedAliasAnalysis()&lt;/code> 函数的实现和 TypeSanitizer 这里 &lt;code>isAliasingLegal&lt;/code> 你会发现算法几乎是一模一样的！不得不说，TypeSanitizer 算法设计的很精妙！&lt;/p>
&lt;h3 id="case-study">Case Study&lt;/h3>
&lt;p>最后，我们通过本节最开始的例子，说明 TypeSanitizer 是如何检测出 type-based aliasing violations 的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang++ -O3 -S -emit-llvm int-long.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>x, &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// !5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// !9
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[[clang::optnone]]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> main(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> l;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%ld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, foo((&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">&amp;amp;&lt;/span>l&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>l));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !5 = !{!6, !6, i64 0}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !6 = !{!&amp;#34;long&amp;#34;, !7, i64 0}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !7 = !{!&amp;#34;omnipotent char&amp;#34;, !8, i64 0}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !8 = !{!&amp;#34;Simple C++ TBAA&amp;#34;}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !9 = !{!10, !10, i64 0}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// !10 = !{!&amp;#34;int&amp;#34;, !7, i64 0}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们的环境下 int 是 4-bytes，long 是 8-bytes，所以变量 &lt;code>l&lt;/code> 对应 64-bytes shadow memory。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>初始时，变量 &lt;code>l&lt;/code> 所在 8-bytes 对应 64-bytes shadow memory 的内容都是 0 即 unknown。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 &lt;code>*y = 1&lt;/code>时首先判断 &lt;code>y&lt;/code> 的 TypeDescriptorFromShadowMemory 的值，因为变量 &lt;code>l&lt;/code> 所在 8-bytes 对应 64-bytes shadow memory 的内容都是 unknown，所以调用函数 &lt;code>__tysan_set()&lt;/code> 进行设置，根据 &lt;code>*y = 1&lt;/code> 将变量 &lt;code>l&lt;/code> 所在 8-bytes 对应 64-bytes shadow memory 设置为如下内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>+---------------------+----+----+----+----+----+----+----+
| __tysan_v1_long_o_0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 |
+---------------------+----+----+----+----+----+----+----+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>执行 &lt;code>*x = 0&lt;/code>时，发现 &lt;code>x&lt;/code> 的 TypeDescriptorFromShadowMemory 值为 -4，TypeDescriptorFromMetadata 为 __tysan_v1_int_o_0。显然 TypeDescriptorFromShadowMemory 不等于 TypeDescriptorFromMetadata，所以调用 &lt;code>__tysan_check()&lt;/code> 函数检查是否存在 type-based aliasing violations。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>因为 TypeDescriptorFromShadowMemory 为 -4 表示的是偏移，更新 TypeDescriptorFromShadowMemory 指向 __tysan_v1_long_o_0。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此时检查是否存在 type-based aliasing violations 就是检查 &lt;code>!isAliasingLegal(__tysan_v1_int_o_0, __tysan_v1_long_o_0)&lt;/code> 的返回值。显然 __tysan_v1_int_o_0 和 __tysan_v1_long_o_0 不是 legal aliasing，即 &lt;code>!isAliasingLegal(__tysan_v1_int_o_0, __tysan_v1_long_o_0)&lt;/code> 返回值为 true。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后调用 &lt;code>reportError()&lt;/code> 函数报错，报错信息如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>ERROR: TypeSanitizer: type-aliasing-violation on address 0x7ffcb0e822b4 (pc 0x55b4e6cf04d6 bp 0x7ffcb0e82260 sp 0x7ffcb0e81a18 tid 2615428)
WRITE of size 4 at 0x7ffcb0e822b4 with type int accesses part of an existing object of type long that starts at offset -4
#0 0x55b4e6cf04d5 in foo(int*, long*) (a.out+0x334d5)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="ps">P.S.&lt;/h2>
&lt;p>本文的最后，简单说下如何在编程时避免写出 strict aliasing violation 的代码。&lt;/p>
&lt;p>最常见的违反 strict aliasing rule 的写法就是 type punning：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> &lt;span style="color:#a6e22e">u1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">int64_t&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> d ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u1 u ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u.d &lt;span style="color:#f92672">=&lt;/span> d ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf( &lt;span style="color:#e6db74">&amp;#34;%&amp;#34;&lt;/span> PRId64 &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, u.n ) ; &lt;span style="color:#75715e">// UB in C++, n is not the active member
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 C++ 中实现 type punning 的标准写法应该是 &lt;code>memcpy&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>( &lt;span style="color:#66d9ef">double&lt;/span> d )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">int64_t&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>memcpy(&lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>d, &lt;span style="color:#66d9ef">sizeof&lt;/span> d); &lt;span style="color:#75715e">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> printf( &lt;span style="color:#e6db74">&amp;#34;%&amp;#34;&lt;/span> PRId64 &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, n ) ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述两种实现编译生成的汇编代码是完全一样的，memcpy 并不会有额外的开销：&lt;a href="https://godbolt.org/z/xTKjxTejc">Compiler Explorer&lt;/a>！&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8">What is the Strict Aliasing Rule and Why do we care? - Shafik Yaghmour&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://lists.llvm.org/pipermail/llvm-dev/2017-April/112189.html">[RFC] Design of a TBAA sanitizer - llvm-dev at lists.llvm.org&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=vAXJeN7k32Y">The Type Sanitizer: Free Yourself from -fno-strict-aliasing - 2017 LLVM Developers&amp;rsquo; Meeting&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://discourse.llvm.org/t/reviving-typesanitizer-a-sanitizer-to-catch-type-based-aliasing-violations/66092">Reviving TypeSanitizer - a sanitizer to catch type-based aliasing violations - Sanitizers - LLVM Discussion Forums&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Dissecting ThreadSanitizer Algorithm</title><link>https://enna1.github.io/post/dissecting-thread-sanitizer/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/dissecting-thread-sanitizer/</guid><description>&lt;p>本文深入剖析 ThreadSanitizer(V2) 检测 Data Race 背后的算法原理。&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>ThreadSanitizer(AKA TSan) 是一个集成在 GCC 和 Clang 中的动态分析工具，能够检测 C++ 代码中大多数的数据竞争 (data race) 。它由编译时插桩和运行时库两部分组成，通过编译和链接时添加参数 &lt;code>-fsanitize=thread&lt;/code>，就可以在运行时检测 data race 。&lt;/p>
&lt;h2 id="data-race">Data Race&lt;/h2>
&lt;p>TSan 是检测 data race 的动态分析工具。我们先看下 data race 指的是什么？&lt;/p>
&lt;p>&lt;strong>Data Race&lt;/strong>：两个线程 &lt;strong>concurrently&lt;/strong> 访问了&lt;strong>同一个内存位置 (memory location)&lt;/strong>，并且两个线程的访存操作中&lt;strong>至少一个是写操作&lt;/strong>。&lt;/p>
&lt;p>注：关于 race condition 和 data race 的区别，见 &lt;a href="https://blog.regehr.org/archives/490">Race Condition vs. Data Race – Embedded in Academia&lt;/a>&lt;/p>
&lt;p>例如下述代码：两个线程并发地修改整型全局变量 Global 存在 data race。两个线程执行结束后，全局变量 Global 的值可能是 1 也可能是 2。如果是在读写 STL 容器时存在 data race，则可能导致更严重的后果，比如内存破坏、程序崩溃。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> Global;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Thread1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Global &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Thread2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Global &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据 data race 的定义，判断代码中是否存在 data race 需要考虑 3 个条件：&lt;/p>
&lt;ol>
&lt;li>两个线程访问的是否为&lt;strong>同一个 memory location&lt;/strong>&lt;/li>
&lt;li>两个线程的访存操作中&lt;strong>至少有一个是写操作&lt;/strong>&lt;/li>
&lt;li>两个线程的访存操作是否 &lt;strong>concurrent&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>其中前两个条件很容易判断，所以检测 data race 的要解决的关键问题就是怎么判断两个访存操作是否 &lt;strong>concurrent&lt;/strong> &lt;strong>！&lt;/strong>&lt;/p>
&lt;h2 id="happen-before--concurrent">Happen-Before &amp;amp; Concurrent&lt;/h2>
&lt;p>在介绍如何判断两次访问操作是否是 concurrent 之前，我们需要先引入 happen-before 的定义。&lt;/p>
&lt;p>Happen-before 的定义最开始是在 &lt;a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system&lt;/a> 中给出的，描述的是分布式系统中事件之间的一种偏序关系。&lt;/p>
&lt;p>一个分布式系统是由一系列 processes 组成的，每个 process 又由一系列事件组成， 不同的 process 之间是通过收发消息进行通信的。&lt;/p>
&lt;p>&lt;em>&lt;strong>Happen-before&lt;/strong>&lt;/em> 关系（记作 $\rightarrow$）的定义：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果事件 $a$ 和事件 $b$ 是在同一个 process 中的事件，并且 $a$ 早于 $b$ 发生，那么 $a \rightarrow b$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果事件 $a$ 和事件 $b$ 是不同 process 中的事件，且 $b$ 是 $a$ 发送的消息的接收者，那么 $a \rightarrow b$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>&lt;strong>Happen-before&lt;/strong>&lt;/em> 关系是一种严格&lt;strong>偏序&lt;/strong>关系 (strict partial order)，即满足 transitive, irreflexive and antisymmetric&lt;/p>
&lt;ol>
&lt;li>Transitive。对于任意事件 $a,b ,c$，如果 $a \rightarrow b$ 且 $b \rightarrow c$，那么有 $a \rightarrow c$&lt;/li>
&lt;li>Irreflexive。对于任意事件 $a$，都有 $a \nrightarrow a$&lt;/li>
&lt;li>Antisymmetric。对于任意事件 $a,b$，如果 $a \rightarrow b$，那么有 $b \nrightarrow a$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>下面通过一个例子对 happen-before 进行说明：&lt;/p>
&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-09-43-40-image.png" title="" alt="" width="450">
&lt;p>上图是对一个分布式系统的某一次 trace：&lt;/p>
&lt;ul>
&lt;li>3 条垂直线分别表示 3 个 process: $P, Q, R$&lt;/li>
&lt;li>垂直线上的点表示事件，在同一条垂直线上纵坐标小的事件发生的时间早于纵坐标大的事件发生的时间。例如事件 $p_1$ 早于事件 $p_2$ 发生&lt;/li>
&lt;li>连接 process 之间的线表示 process 之间通过收发消息进行通信，$p_1 \rightarrow q_2$ 表示 process $P$ 于事件 $p_1$ 向 process $Q$ 发送消息， 这个消息被 process $Q$ 于事件 $q_2$ 接收到&lt;/li>
&lt;/ul>
&lt;p>那么对于上图分布式系统 trace：&lt;/p>
&lt;ul>
&lt;li>根据 &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> 的定义能得出：$p_1 \rightarrow r_4$，这是因为 $p_1 \rightarrow q_2$, $q_2 \rightarrow q_4$, $q_4 \rightarrow r_3$, $r_3 \rightarrow r_4$，所以 $p_1 \rightarrow r_4$。即事件 $p1$ 一定是先于事件 $r4$ 发生，不管上述分布式系统事件运行多少次&lt;/li>
&lt;li>尽管根据本次 trace 看来在时间上事件 $q_3$ 是早于事件 $p_3$ 发生的，但是 $q_3 \nrightarrow p_3$ 且 $p_3 \nrightarrow q_3$，即事件 $q_3$ 和事件 $p_3$ 之间是没有 happen-before 关系的。所以不能保证每一次运行，事件 $q_3$ 都是早于事件 $p_3$ 发生的，也有可能在某一次 trace 中事件 $p_3$ 是早于事件 $q_3$ 发生的&lt;/li>
&lt;/ul>
&lt;p>理解了 happen-before 的定义后，我们给出 &lt;strong>concurrent&lt;/strong> 的定义：如果 $a \nrightarrow b$ 且 $b \nrightarrow a$，那么称 $a$ 和 $b$ 是 &lt;strong>concurrent&lt;/strong> 的。&lt;/p>
&lt;p>这样我们就能够将判断两次访存操作之间是否 concurrent 转化为了判断两次访存操作之间是否存在 happen-before 关系。&lt;/p>
&lt;p>那么如何判断两次访存操作之间是否存在 happen-before 关系呢？答案是 Vector Clock。在介绍 Vector Clock 之前，我们需要先了解下 Lamport Logical Clock。&lt;/p>
&lt;h2 id="lamport-logical-clock">Lamport Logical Clock&lt;/h2>
&lt;p>Lamport logical clock 算法是由 Leslie Lamport 在 &lt;a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system&lt;/a> 中提出的一种简单的逻辑时钟算法，用于描述分布式计算机系统中事件的偏序关系。&lt;/p>
&lt;p>算法如下：&lt;/p>
&lt;ol>
&lt;li>每个 Process $P_i$ 都持有一个逻辑时钟 $Clock_i$，process $P_i$ 在每次本地事件发生之前，都将 $Clock_i$ 自增 1&lt;/li>
&lt;li>Process $P_i$ 向其他 Process 发送消息时，先执行步骤 1，然后将 $Clock_i$ 的值包含在消息中一并发送出去&lt;/li>
&lt;li>Process $P_j$ 接收到 Process $P_i$ 发送来的消息时，获取消息中携带的 $Clock_i$ 的值，与自身的 $Clock_j$ 取最大值，然后在认为收到消息之前将 $Clock_j$ 自增 1&lt;/li>
&lt;/ol>
&lt;p>根据 lamport logical clock 算法流程和 happen-before 定义易得：对于任意两个事件，如果事件 $a$ &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> 事件 $b$，那么 $Clock(a) &amp;lt; Clock(b)$。&lt;/p>
&lt;p>下面通过例子来说明 lamport logical clock 算法流程：&lt;/p>
&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-09-51-37-image.png" title="" alt="" width="250">
&lt;ul>
&lt;li>初始时，Process $P$ 和 Process $Q$ 的逻辑时钟的值都为 0&lt;/li>
&lt;li>Process $P$ 发生本地事件 $p_1$，逻辑时钟 $Clock_p$ 的值由 0 更新为 1。Process $Q$ 发生本地事件 $q_1$，逻辑时钟 $Clock_q$ 的值由 0 更新为 1&lt;/li>
&lt;li>Process $P$ 于事件 $p_2$ 向 Process $Q$ 发送消息，先自增逻辑时钟 $Clock_p$ 的值，由 1 更新为 2。然后将此时 $Clock_p$ 的值（即 2）包含在消息中一并发送出去&lt;/li>
&lt;li>Process $Q$ 接收到 Process $P$ 发送来的消息，获取消息中携带的逻辑时钟的值（即 2），首先将逻辑时钟 $Clock_q$ 的值更新为消息中携带的逻辑时钟的值与此时自身逻辑时钟 $Clock_q$ 的值的最大值（即 $Clock_q$ 更新为 2 和 2 的最大值，还是 2），然后再将 $Clock_q$ 自增 1（即 $Clock_q$ 的值由 2 更新为 3 ）&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>但是 lamport logical clock 是存在局限性的：&lt;/p>
&lt;ul>
&lt;li>只能保证：如果 $a \rightarrow b$，那么 $Clock(a) &amp;lt; Clock(b)$&lt;/li>
&lt;li>但是 $Clock(a) &amp;lt; Clock(b)$ 不意味着 $a \rightarrow b$，即我们不能基于 $Clock(a) &amp;lt; Clock(b)$ 来判定事件 $a$ &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> 事件 $b$&lt;/li>
&lt;/ul>
&lt;p>例如 $Clock_p(p1)= 1 &amp;lt; 2 = Clock_q(q2) $，但是实际上 $p_1$ &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> $p_2$ 是不成立！也就是说，事件 $p_1$ 和事件 $p_2$ 之间谁都可能早于另外一个事件发生。&lt;/p>
&lt;p>我们前面将 data race 检测问题转化为了判断两次访存操作之间是否存在 happen-before 关系的问题。但是由于 lamport logical lock 的局限性，我们不能直接将 lamport logic clock 应用于 data race 的检测。&lt;/p>
&lt;h2 id="vector-clock">Vector Clock&lt;/h2>
&lt;p>Colin Fidge 和 Friedemann Mattern 提出的 vector clock 解决了 lamport logic clock 的上述局限性&lt;/p>
&lt;p>vector clock 算法如下：&lt;/p>
&lt;ul>
&lt;li>每一个 process $P_i$ 都对应一个 vector clock $VC_i$，$VC_i$ 是由 n 个元素组成的向量，n 是分布式系统中 process 的数量。每个 process $P_i$ 的 $VC_i$ 都被初始化为 0&lt;/li>
&lt;li>每当 process $P_i$ 发生本地事件之前，更新 vector clock：$VC_i[i] = VC_i[i] + 1$&lt;/li>
&lt;li>Process $P_i$ 向其他 Process 发送消息时，先更新 vector clock：$VC_i[i] = VC_i[i] + 1$，然后将 $VC_i$ 的值包含在消息中&lt;/li>
&lt;li>process $P_j$ 接收由 process $P_i$ 发送来的 message，更新 vector clock：$VC_j[j] = VC_j[j] + 1,
VC_j[k] = max(VC_j[k], VC_i[k])\ \textup{for all process}\ k$&lt;/li>
&lt;/ul>
&lt;p>下面还是通过一个例子来说明 vector clock 的算法流程：&lt;/p>
&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-10-23-24-image.png" title="" alt="" width="450">
&lt;ul>
&lt;li>
&lt;p>初始时 $VC_1 = VC_2 = VC_3= [0,0,0]$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Process $P$ 发生内部事件 $p_1$，更新 vector clock：$VC_1 = [0+1,0,0]=[1,0,0]$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Process $Q$ 发生内部事件$p_2$，更新 vector clock：$VC_2 = [0,0+1,0] = [0,1,0]$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Process $R$ 发生内部事件 $p_3$，更新 vector clock：$VC_3 = [0,0,0+1]=[0,0,1]$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>process $Q$ 于事件 $q_2$ 接收由 process $P$ 于事件 $p_2$ 发送的消息，更新 vector clock：&lt;/p>
&lt;ul>
&lt;li>$VC_1[1] = 1 + 1 = 2, VC_1 = [2, 0, 0]$&lt;/li>
&lt;li>$VC_2[2] = 1 + 1 = 2, VC_2 = [0,2,0]$&lt;/li>
&lt;li>$VC_2 = max(VC_1, VC_2) = [max(2,0), max(0,2), max(0,0)]=[2,2,0]$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Vector clock 解决了 lamport logical clock 的局限性，满足如下性质：&lt;/p>
&lt;ul>
&lt;li>如果事件 $a$ &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> 事件 $b$，那么 $VC(a) &amp;lt; VC(b)$&lt;/li>
&lt;li>如果 $VC(a) &amp;lt; VC(b)$，那么事件 $a$ &lt;em>&lt;strong>happen-before&lt;/strong>&lt;/em> 事件 $b$&lt;/li>
&lt;/ul>
&lt;p>即 $p_a \rightarrow q_b \quad \textup{iff} \quad VC_p(a) &amp;lt; VC_q(b)$&lt;/p>
&lt;p>Vector clock 上的偏序关系如下：&lt;/p>
&lt;ul>
&lt;li>$VC_p = VC_q \quad \textup{iff} \enspace \forall k, \enspace VC_p[k] = VC_q[k]$&lt;/li>
&lt;li>$VC_p \neq VC_q \quad \textup{iff} \enspace \exist k, \enspace VC_p[k] \neq VC_q[k]$&lt;/li>
&lt;li>$VC_p \leq VC_q \quad \textup{iff} \enspace \forall k, \enspace VC_p[k] \leq VC_q[k]$&lt;/li>
&lt;li>$VC_p &amp;lt; VC_q \quad \textup{iff} \enspace (VC_p \le VC_q \enspace \textup{and} \enspace VC_p \neq VC_q)$&lt;/li>
&lt;/ul>
&lt;p>根据 $p_a \rightarrow q_b \quad \textup{iff} \quad VC_p(a) &amp;lt; VC_q(b)$ 这个性质，我们就能使用 vector clock 来判断两次访存操作之间是否存在 happen-before 关系，即能够基于 vector clock 算法来检测多线程程序中的 data race。&lt;/p>
&lt;h2 id="data-race-detection">Data Race Detection&lt;/h2>
&lt;p>我们前面在介绍 lamport logic clock 和 vector clock 时都是以分布式系统中的事件之间序关系为背景进行介绍的。&lt;/p>
&lt;p>实际上多线程程序也可以看作是一个分布式系统。我们对上述 vector clock 算法稍加修改，就可以应用于检测多线程程序中的 data race：&lt;/p>
&lt;ul>
&lt;li>符号定义：
&lt;ul>
&lt;li>$\mathbb{VC_1} \sqsubseteq \mathbb{VC_2}\quad\textbf{iff}\quad\forall t.\ \mathbb{VC_1}(t) \leq \mathbb{VC_2}(t)$&lt;/li>
&lt;li>$\mathbb{VC_1} \sqcup \mathbb{VC_2} \quad=\quad \lambda t.\ max(\mathbb{VC_1}(t), \mathbb{VC_2}(t))$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个线程 $t$ 都对应一个 vector clock $\mathbb{VC}_t$，初始值为 0。对于任意一个线程 $u$，$\mathbb{VC}_t(u)$ 记录的其实是与线程 $t$ 的当前操作满足 happen-before 关系的线程 $u$ 的上一次操作的 clock。如果把线程 $u$ 的上一次操作记为 $O_u$，把线程 $t$ 的当前操作记为 $O_t$，那么有 $O_u\ \text{happen-before}\ O_t$&lt;/li>
&lt;li>每一个锁 $m$ 都对应一个 vector clock $\mathbb{L}_m$&lt;/li>
&lt;li>每一个变量 $x$都对应两个 vector clock: $\mathbb{W}_x$ 和 $\mathbb{R}_x$。对于任意一个线程 $t$，$\mathbb{W}_x[t]$ 和 $\mathbb{R}_x[t]$ 记录了线程 $t$ 对变量 $x$ 的最后一次读/写的 clock
&lt;ul>
&lt;li>线程 $t$ 对变量 $x$ 的读时，会将 $\mathbb{R}_x[t]$ 的值更新为 $\mathbb{VC}_t[t]$ 的值&lt;/li>
&lt;li>程序 $t$ 对变量 $x$ 的写时，会将 $\mathbb{W}_x[t]$ 的值更新为 $\mathbb{VC}_t[t]$ 的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>程序中执行同步和线程操作时，算法会更新相应的 vector clock：
&lt;ul>
&lt;li>$rel(t, m)$。线程 $u$ 释放了锁 $m$，先将 $\mathbb{L}_m$ 的值更新为 $\mathbb{VC}_u$ 的值，再将 $\mathbb{VC}_u[u]++$&lt;/li>
&lt;li>$acq(t, m)$。线程 $t$ 获取了锁 $m$，将 $\mathbb{VC}_t$ 的值更新为 $\mathbb{VC}_t \sqcup \mathbb{L}_m$ 的值&lt;/li>
&lt;li>$fork(t, u)$。先将 $\mathbb{VC}_u$ 的值更新为 $\mathbb{VC}_u \sqcup \mathbb{VC}_t$，再将 $\mathbb{VC}_t[t]++$&lt;/li>
&lt;li>$join(t, u)$。先将 $\mathbb{VC}_t$ 的值更新为 $\mathbb{VC}_t\sqcup \mathbb{VC}_u$，再将 $\mathbb{VC}_u[u]++$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>判断是否存在 data race：
&lt;ul>
&lt;li>假设当前线程 $u$ 读变量 $x$，如果满足 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$，那么当前线程 $u$ 对变量 $x$ 的读与之前其他线程对变量 $x$ 的写不存在 data race&lt;/li>
&lt;li>假设当前线程 $u$ 写变量 $x$，如果 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 且 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 那么当前线程 $u$ 对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读不存在 data race&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>下面还是通过一个例子来说明如何应用 vector clock 检测多线程程序中的 data race：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>考虑多线程程序中有两个线程 A 和 B，有一个锁 $m$ ，还有一个变量 $x$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线程 $A$ 对应的 vector clock 记作 $\mathbb{VC}_A$，线程 $B$ 对应的 vector clock 记作 $\mathbb{VC}_B$，锁 $m$ 对应的 vector clock 记作 $\mathbb{L}_m$，变量 $x$ 对应的写/读 vector clock 记作 $\mathbb{W}_x$ 和 $\mathbb{R}_x$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设多线程程序某一个时刻的运行状态如下图所示：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-32-22-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此时线程 $A$ 执行语句 &lt;code>x = 0&lt;/code> 写变量 $x$，我们需要检查当前线程对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 和 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。&lt;/p>
&lt;p>显然 $[3, 0] \sqsubseteq [4,1]$ 和 $[0, 1] \sqsubseteq [4,1]$ 都满足，即本次线程 $A$ 执行语句 &lt;code>x = 0&lt;/code> 写变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间不存在 data race&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-34-10-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因为线程 $A$ 执行语句 &lt;code>x = 0&lt;/code> 写了变量 $x$，我们要更新 $\mathbb{W}_x$ 的值，将 $\mathbb{W}_x[A]$ 的值更新为 $\mathbb{VC}_A[A]$ 的值：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-34-59-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序继续执行，此时线程 $A$ 执行语句 &lt;code>rel(m)&lt;/code> 释放锁 $m$，先将 $\mathbb{L}_m$ 的值更新为 $\mathbb{VC}_A$ 的值，再将 $\mathbb{VC}_A[A]++$&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-40-30-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序继续执行，此时线程 $B$ 执行语句 &lt;code>acq(m)&lt;/code> 申请锁 $m$，将 $\mathbb{VC}_B$ 的值更新为 $\mathbb{VC}_B \sqcup \mathbb{L}_m$ 的值&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-41-22-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线程 $B$ 执行语句 &lt;code>x = 1&lt;/code> 写变量 $x$ ，我们需要检查当前线程对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 和 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。&lt;/p>
&lt;p>显然 $[4, 0] \sqsubseteq [4,8]$ 和 $[0, 1] \sqsubseteq [4,8]$ 都满足，即本次线程 $B$ 执行语句 &lt;code>x = 1&lt;/code> 写变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间不存在 data race。&lt;/p>
&lt;p>因为线程 $B$ 执行语句 &lt;code>x = 1&lt;/code> 写变量 $x$，我们要更新 $\mathbb{W}_x$ 的值，将 $\mathbb{W}_x[B]$ 的值更新为 $\mathbb{VC}_B[B]$ 的值：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-43-57-image.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线程 $A$ 执行语句 &lt;code>y = x&lt;/code> 读变量 $x$，我们需要检查当前线程对变量 $x$ 的读与之前其他线程对变量 $x$ 的写之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。&lt;/p>
&lt;p>显然 $[4, 8] \sqsubseteq [5,1]$ &lt;strong>不满足&lt;/strong>，即本次线程 $B$ 执行语句 &lt;code>x = 1&lt;/code> 写变量 $x$ 与之前其他线程对变量 $x$ 的读之间&lt;strong>存在 data race&lt;/strong>。&lt;/p>
&lt;p>即我们检测到线程 $A$ 执行语句 &lt;code>y = x&lt;/code> 读变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间&lt;strong>存在 data race&lt;/strong>。更具体地说是线程 $A$ 执行语句 &lt;code>y = x&lt;/code> 读变量 $x$ 与之前线程 $B$ 执行语句 &lt;code>x = 1&lt;/code> 读变量 $x$ 存在 data race。&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-11-45-55-image.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="threadsanitizer-internals">ThreadSanitizer Internals&lt;/h2>
&lt;p>ThreadSanitizer 检测 data race 的思想其实就是基于 vector clock 算法的，只不过在实现时做了一些取舍。比如对于每一个变量 $x$，ThreadSanitizer 不会记录所有线程最近一次对变量 $x$ 的读写，ThreadSanitizer 只会记录最近 4 次对变量 $x$ 的读写。&lt;/p>
&lt;p>ThreadSanitizer 由编译时插桩和运行时库两部分组成。&lt;/p>
&lt;ul>
&lt;li>编译时插桩：对于每一次 memory access (load, store)，都会在此次 acccess 之前插入一个函数调用 (&lt;code>__tsan_read&lt;/code>, &lt;code>__tsan_write&lt;/code>)，该函数调用是在运行时库中实现的。&lt;/li>
&lt;li>运行时库：在 &lt;code>__tsan_read&lt;/code>, &lt;code>__tsan_write&lt;/code> 中实现 data race 检测的核心逻辑，判断本次访问是否存在 data race。劫持了很多函数实现如 libc 和 pthread，在申请锁、释放锁，fork/join 线程时更新 vector clock 。&lt;/li>
&lt;/ul>
&lt;p>例如，本文最开始提到的全局变量数据竞争的代码片段使用 ThreadSanitizer 插桩后的代码变为如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> global;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Thread1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_func_entry(__builtin_return_address(&lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_write4(&lt;span style="color:#f92672">&amp;amp;&lt;/span>global);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> global &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_func_exit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Thread2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_func_entry(__builtin_return_address(&lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_write4(&lt;span style="color:#f92672">&amp;amp;&lt;/span>global);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> global &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __tsan_func_exit();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意到：在 &lt;code>global = 1&lt;/code> 和 &lt;code>global = 2&lt;/code> 之前都插入了对 &lt;code>__tsan_write4&lt;/code> 的函数调用。&lt;/p>
&lt;hr>
&lt;p>启用 ThreadSanitizer 后，在程序运行过程中，每一个线程都会保存一个 vector clock，每 8-bytes 的应用程序内存都对应有 4 个 8-bytes 的 shadow word。每个 shadow word 都用于记录一次访问操作，记录 TID（线程 id）、Epoch（访存操作发生时线程 TID 此时的 local time）、Pos:Size（标识本次访存访问的是当前 8-bytes 的哪几个 bytes）、IsWrite（标识本次访存操作是读还是写）。&lt;/p>
&lt;p>每次读写变量 $x$ 时，由于程序被 ThreadSanitizer 插桩，所以在执行读写操作之前，都会调用函数 &lt;code>__tsan_read&lt;/code> 或 &lt;code>__tsan_write&lt;/code>，在&lt;code>__tsan_read&lt;/code> 和 &lt;code>__tsan_write&lt;/code>的函数实现中，首先找到变量 $x$ 所在的 8-bytes 内存区域。然后找到这 8-bytes 内存所对应的 4 个 shadow word，检查当前这一次对变量 $x$ 的读写与shadow word 中记录的最近 4 次读写是否存在 data race。最后更新 shadow word 的内容，记录本次对变量 $x$ 的读写，保证 shadow word 记录的是最近 4 次对变量 $x$ 的读写。&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/dissecting-thread-sanitizer/2022-10-20-12-04-08-image.png" alt="">&lt;/p>
&lt;p>完整的 ThreadSanitizer 算法的伪代码如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">HandleMemoryAccess&lt;/span>(thread_state, tid, pc, addr, size, is_write, is_atomic):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shadow_mem &lt;span style="color:#f92672">=&lt;/span> MemToShadow(addr) &lt;span style="color:#75715e"># the type of shadow_mem is uint64_t*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IncrementThreadClock(tid)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LogEvent(tid, pc)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_shadow_word &lt;span style="color:#f92672">=&lt;/span> ShadowWord(tid, CurrentClock(tid), addr, size, is_write, is_atomic)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stored &lt;span style="color:#f92672">=&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> raced &lt;span style="color:#f92672">=&lt;/span> UpdateOneShadowState(thread_state, shadow_mem, i, new_shadow_word, stored)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> raced:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> stored:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Evict a random Shadow Word&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shadow_mem[Random(&lt;span style="color:#ae81ff">4&lt;/span>)] &lt;span style="color:#f92672">=&lt;/span> store_word &lt;span style="color:#75715e"># Atomic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">UpdateOneShadowState&lt;/span>(shadow_mem, idx, new_shadow_word, stored):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> old_shadow_word &lt;span style="color:#f92672">=&lt;/span> shadow_mem[idx] &lt;span style="color:#75715e"># Atomic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># The old state is empty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> old_shadow_word &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> stored:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StoreIfNotYetStored(shadow_mem[idx], store_word)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stored &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Is the memory access equal to the previous?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> AccessedSameRegion(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> SameThreads(old_shadow_word, new_shadow_word): &lt;span style="color:#75715e"># same thread&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> IsRWWeakerOrEqual(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StoreIfNotYetStored(shadow_mem[idx], store_word)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stored &lt;span style="color:#f92672">=&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> HappensBefore(old_shadow_word, thread_state):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> IsBothReadsOrAtomic(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># race!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReportRace(old_shadow_word, new_shadow_word)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Do the memory access intersect?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> AccessedIntersectingRegions(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> SameThreads(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> IsBothReadsOrAtomic(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> HappensBefore(old_shadow_word, thread_state):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># race!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReportRace(old_shadow_word, new_shadow_word)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># The accesses do not intersect, do nothing&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">StoreIfNotYetStored&lt;/span>(shadow_mem, store_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>shadow_mem &lt;span style="color:#f92672">=&lt;/span> store_word &lt;span style="color:#75715e"># Atomic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> store_word &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">IsRWWeakerOrEqual&lt;/span>(old_shadow_word, new_shadow_word):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (old_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_atomic &lt;span style="color:#f92672">&amp;gt;&lt;/span> new_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_atomic) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (old_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_atomic &lt;span style="color:#f92672">==&lt;/span> new_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_atomic &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">!&lt;/span>old_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_write &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">!&lt;/span>new_shadow_word&lt;span style="color:#f92672">.&lt;/span>is_write)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">HappensBefore&lt;/span>(old_shadow_word, thread_state):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> thread_state&lt;span style="color:#f92672">.&lt;/span>vector_clock&lt;span style="color:#f92672">.&lt;/span>get(old_shadow_word&lt;span style="color:#f92672">.&lt;/span>tid) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> old_shadow_word&lt;span style="color:#f92672">.&lt;/span>epoch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system.Communications of the ACM,21(7), pp.558-565.&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://users.soe.ucsc.edu/~cormac/papers/pldi09.pdf">Cormac Flanagan and Stephen N. Freund. 2009. FastTrack: efficient and precise dynamic race detection. (PLDI &amp;lsquo;09)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gcc.gnu.org/wiki/cauldron2012?action=AttachFile&amp;amp;do=get&amp;amp;target=kcc.pdf">Finding races and memory errors with GCC instrumentation. (GNU Tools Cauldron 2012)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developers.google.com/google-test-automation-conference/2013/presentations-day2#Day2Presentation6">AddressSanitizer, ThreadSanitizer and MemorySanitizer &amp;ndash; Dynamic Testing Tools for C++. (Google Test Automation Conference)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lamport_timestamp">https://en.wikipedia.org/wiki/Lamport_timestamp&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Vector_clock">https://en.wikipedia.org/wiki/Vector_clock&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>How Sanitizer Get Stack Trace</title><link>https://enna1.github.io/post/how-sanitizer-get-stacktrace/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/how-sanitizer-get-stacktrace/</guid><description>&lt;p>本文以 ASan 为例分析 sanitizer runtime 是如何获取和保存 stack trace 的。&lt;/p>
&lt;p>Sanitizer 非常好用的一个原因就是报告的内容非常详细。例如 ASan 检测到一个 heap-use-after-free 类型的 bug，在报告中不仅会给出执行哪行代码时触发了 heap-use-after-free，还会给出这块堆内存是在哪里被申请的，又是在哪里被释放的。&lt;/p>
&lt;p>例如下面这个 heap-use-after-free 的例子：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&amp;ldquo;READ of size 4 at 0x603e0001fc64 thread T0&amp;rdquo; 给出的是触发 heap-use-after-free 的 stack trace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;ldquo;freed by thread T0 here:&amp;rdquo; 给出的是堆内存被释放时的 stack trace&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;ldquo;previously allocated by thread T0 here:&amp;rdquo; 给出的是堆内存被申请时的 stack trace&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang -O0 -g -fsanitize=address test.cpp &amp;amp;&amp;amp; ./a.out
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> [] array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> array[argc]; &lt;span style="color:#75715e">// BOOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>=================================================================
==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64 at pc 0x417f6a bp 0x7fff626b3250 sp 0x7fff626b3248
READ of size 4 at 0x603e0001fc64 thread T0
#0 0x417f69 in main test.cpp:5
#1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)
#2 0x417e54 (a.out+0x417e54)
0x603e0001fc64 is located 4 bytes inside of 400-byte region [0x603e0001fc60,0x603e0001fdf0)
freed by thread T0 here:
#0 0x40d4d2 in operator delete[](void*) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:61
#1 0x417f2e in main test.cpp:4
previously allocated by thread T0 here:
#0 0x40d312 in operator new[](unsigned long) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:46
#1 0x417f1e in main test.cpp:3
Shadow bytes around the buggy address:
0x1c07c0003f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=&amp;gt;0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd
0x1c07c0003f90: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x1c07c0003fa0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x1c07c0003fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa
0x1c07c0003fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable: 00
Partially addressable: 01 02 03 04 05 06 07
Heap left redzone: fa
Heap righ redzone: fb
Freed Heap region: fd
Stack left redzone: f1
Stack mid redzone: f2
Stack right redzone: f3
Stack partial redzone: f4
Stack after return: f5
Stack use after scope: f8
Global redzone: f9
Global init order: f6
Poisoned by user: f7
ASan internal: fe
==6254== ABORTING
&lt;/code>&lt;/pre>&lt;p>本文以 ASan 为例分析 sanitizer runtime 是如何获取 stack trace 的。&lt;/p>
&lt;h2 id="stack-unwinding">Stack unwinding&lt;/h2>
&lt;p>在分析 sanitizer runtime 关于 stack trace 的具体实现之前，我们先来学习下 stack unwinding。&lt;/p>
&lt;p>关于 stack unwinding，maskray 这篇文章 &lt;a href="https://maskray.me/blog/2020-11-08-stack-unwinding">Stack unwinding | MaskRay&lt;/a> 写的非常好。本节的内容都是从 maskray 这篇文章习来的。&lt;/p>
&lt;p>Stack unwinding 主要用于获取 stack trace 或 实现 C++ exception。&lt;/p>
&lt;p>Stack unwinding 可以分为两类：&lt;/p>
&lt;ul>
&lt;li>synchronous: 由程序自身触发的，只发生在函数调用处（在 function body 内，不会出现在 prologue/epilogue 处)。&lt;/li>
&lt;li>asynchronous: 由 garbage collector, signal 或外部程序触发，这类 stack unwinding 可以发生在函数 prologue/epilogue 处。&lt;/li>
&lt;/ul>
&lt;p>Sanitizer 的 stack unwinding 就是 synchronous stack unwinding，由 sanitizer runtime 自身触发。例如 sanitizer runtime 在 malloc/free 时会通过 stack unwinding 获取 stack trace。&lt;/p>
&lt;p>因此本文中我们只讨论 synchronous stack unwinding（而且我也不了解 asynchronous stack unwinding，以后有时间可以学习下）。&lt;/p>
&lt;h3 id="frame-pointer">Frame pointer&lt;/h3>
&lt;p>最朴素的 stack unwinding 就是基于 frame (base) pointer [%rbp] 来实现的。如果编译时添加了选项 &lt;code>-fno-omit-frame-pointer&lt;/code>，那么在函数 prologue/epilogue 处会有如下指令：&lt;/p>
&lt;pre tabindex="0">&lt;code>pushq %rbp
movq %rsp, %rbp
...
popq %rbp
ret
&lt;/code>&lt;/pre>&lt;p>函数 prologue 处 &lt;code>pushq %rbp&lt;/code> 将 caller 的 frame pointer 值压栈，&lt;code>movq %rsp, %rbp&lt;/code> 将寄存器 %rbp 的值更新为保存 caller frame pointer 的栈地址。这样，一旦我们获取了当前函数的 frame pointer 的值，将其解引用后就可以得到 caller 的 frame pointer 的值，不停地解引用就能获取到所有栈帧的 frame pointer。&lt;/p>
&lt;p>我们可以将 stack frame 抽象为如下结构体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">stack_frame&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack_frame&lt;span style="color:#f92672">*&lt;/span> nextFrame;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> returnAddress;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以如下汇编代码为例进行说明：在 x86_64 下，caller 会在执行 call 指令时会将当前函数的下一条指令地址压栈，然后跳转到 callee 的入口处继续执行，接着在 callee 的第一条指令就是 &lt;code>pushq %rbp&lt;/code> 将寄存器 %rbp 的值压栈。这两条指令合作将 struct stack_frame 的内容填充好。&lt;/p>
&lt;pre tabindex="0">&lt;code>main: # @main
pushq %rbp
movq %rsp, %rbp
subq $16, %rsp
movl $0, -4(%rbp)
movl $2, %edi
callq foo(int) # Pushes address of next instruction onto stack,
                      # populating &amp;#39;returnAddress&amp;#39; member of &amp;#39;stack_frame&amp;#39;.
# Then jumps to &amp;#39;callee&amp;#39; address(i.e. function foo).
addl $1, %eax
addq $16, %rsp
popq %rbp
retq
foo: # @foo(int)
pushq %rbp # Push rbp (stack_frame ptr) onto stack (populates &amp;#39;nextFrame&amp;#39; member)
movq %rsp, %rbp # Update rbp to point to new stack_frame
subq $16, %rsp. # Reserve an additional 16 bytes of stack-space
movl %edi, -4(%rbp)
movl -4(%rbp), %edi
callq bar(int)
addl $2, %eax
addq $16, %rsp. # Restore rsp
popq %rbp # Pop rbp from stack
retq # Pop return address from top of stack and jump to it
&lt;/code>&lt;/pre>&lt;p>因此我们可以通过 &lt;code>_builtin_frame_address(0)&lt;/code> 得到当前函数的 frame pointer 值，解引用 frame pointer 即可得到 nextFrame 和 returnAddress，不断重复，这样我们就能获取到 stack trace 了。&lt;/p>
&lt;p>一个简单的 unwinding 代码示例实现 test_unwind.cpp 如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>stdio.h&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span> __attribute__((noinline)) &lt;span style="color:#66d9ef">void&lt;/span> fast_unwind() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>frame &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)__builtin_frame_address(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;frame pointer is: %p&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">7&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pc &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)frame[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pc is: %p&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, pc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>new_frame &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)(&lt;span style="color:#f92672">*&lt;/span>frame);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>new_frame &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>frame) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">11&lt;/span> frame &lt;span style="color:#f92672">=&lt;/span> new_frame;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">13&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">14&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">15&lt;/span> &lt;span style="color:#a6e22e">__attribute__&lt;/span>((noinline)) &lt;span style="color:#66d9ef">int&lt;/span> bar(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">17&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">19&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">20&lt;/span> fast_unwind();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> bar(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> bar(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">22&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">23&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#a6e22e">__attribute__&lt;/span>((noinline)) &lt;span style="color:#66d9ef">int&lt;/span> foo(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> bar(n)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">26&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">27&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">28&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> foo(&lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">30&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>$ clang++ test_unwind.cpp -g -no-pie -fno-omit-frame-pointer &amp;amp;&amp;amp; ./a.out
frame pointer is: 0x7ffcbde94c10
pc is: 0x4011ec
frame pointer is: 0x7ffcbde94c30
pc is: 0x401233
frame pointer is: 0x7ffcbde94c50
pc is: 0x401259
$ llvm-symbolizer -iCfe a.out 0x4011ec 0x401233 0x401259
bar(int)
test-stack-trace/test_unwind.cpp:21:14
foo(int)
test-stack-trace/test_unwind.cpp:25:16
main
test-stack-trace/test_unwind.cpp:29:16
&lt;/code>&lt;/pre>&lt;p>但是这种基于 frame pointer 实现 stack unwinding 的方式有很大的局限性：编译器默认只有在 O0 优化等级下会添加 &lt;code>-fno-omit-frame-pointer&lt;/code> 编译选项，并且预留一个寄存器用于存储 frame pointer 与不预留一个寄存器存储 frame pointer 相比会有额外的性能开销。&lt;/p>
&lt;h3 id="dwarf-call-frame-information">DWARF Call Frame Information&lt;/h3>
&lt;p>另一种 stack unwinding 的实现方式就是基于 DWARF Call Frame Information 来实现的，由 compiler/assembler/linker/libunwind 提供相应支持。&lt;/p>
&lt;p>我们还是以例子进行说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat test.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__attribute__((noinline)) &lt;span style="color:#66d9ef">int&lt;/span> bar(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">bar&lt;/span>(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> bar(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__attribute__((noinline)) &lt;span style="color:#66d9ef">int&lt;/span> foo(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">bar&lt;/span>(n)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> foo(&lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成 test_unwind.s
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> clang&lt;span style="color:#f92672">++&lt;/span> &lt;span style="color:#f92672">-&lt;/span>O1 test.cpp &lt;span style="color:#f92672">-&lt;/span>S
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以在 test.s 中看到 .cfi_def_cfa_offset, .cfi_offset 这样的 &lt;a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">CFI directives&lt;/a>，assembler/linker 会根据这些 CFI directives 生成 .eh_frame section，最终用于 stack unwinding。&lt;/p>
&lt;p>例如在汇编文件 test.s 中函数 bar 对应的汇编代码中有如下内容：&lt;/p>
&lt;pre tabindex="0">&lt;code>_Z3bari: # @_Z3bari
.cfi_startproc
# %bb.0: # %entry
pushq %rbp
.cfi_def_cfa_offset 16
pushq %rbx
.cfi_def_cfa_offset 24
pushq %rax
.cfi_def_cfa_offset 32
.cfi_offset %rbx, -24
.cfi_offset %rbp, -16
testl %edi, %edi
jle .LBB0_1
&lt;/code>&lt;/pre>&lt;p>我们手动将 &lt;code>.cfi_offset %rbp, -16&lt;/code> 修改为 &lt;code>.cfi_offset %rbp, -24&lt;/code>，然后将 test.s 编译为可执行文件，并用 gdb 调试看下会有什么影响：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ clang test.s
$ gdb ./a.out
(gdb) b bar
(gdb) r
(gdb) ni
(gdb) ni
(gdb) ni
(gdb) disassemble
Dump of assembler code for function _Z3bari:
0x0000000000401110 &amp;lt;+0&amp;gt;: push %rbp
0x0000000000401111 &amp;lt;+1&amp;gt;: push %rbx
0x0000000000401112 &amp;lt;+2&amp;gt;: push %rax
=&amp;gt; 0x0000000000401113 &amp;lt;+3&amp;gt;: test %edi,%edi
(gdb) i r rbx rbp
rbx 0x0 0
rbp 0x401170 0x401170 &amp;lt;__libc_csu_init&amp;gt;
(gdb) bt
#0 0x0000000000401110 in bar(int) ()
#1 0x0000000000401156 in foo(int) ()
#2 0x000000000040116b in main ()
(gdb) f 1
#1 0x0000000000401156 in foo(int) ()
(gdb) i r rbx rbp
rbx 0x0 0
rbp 0x0 0x0
&lt;/code>&lt;/pre>&lt;p>我们让程序停在 bar 函数中 &lt;code>test %edi,%edi&lt;/code> 处，然后运行程序。可以看到在断点处 rbp 的值是 0x401170，rbx 的值是 0，跳转至 frame 1 后，再次看 rbp 的值，此时变为了 0。然而应当跳转至 frame 1 处和 rbp 的值也应该是 0x401170，变成 0 是因为我们将汇编文件 test.s 中 &lt;code>.cfi_offset %rbp, -16&lt;/code> 修改为了 &lt;code>.cfi_offset %rbp, -24&lt;/code>。而 cfi_offset -24 处存储的是 %rbx 的值，%rbx 的值是 0，所以 gdb 将 frame 1 的 %rbp 的值恢复为了 0。&lt;/p>
&lt;p>这样我们通过这样一个简单的例子管中窥豹了解了基于 DWARF Call Frame Information 的 stack unwinding。&lt;/p>
&lt;h2 id="sanitizer-stack-trace">Sanitizer stack trace&lt;/h2>
&lt;p>Sanitizer runtime 在 stack unwinding 时，有两种策略：fast unwind 和 slow unwind，sanitizer runtime 优先使用 fast unwind。&lt;/p>
&lt;p>在 sanitizer runtime 中有很多地方都需要收集 stack trace，例如在 malloc/free 被调用时收集 stack trace。在 ASan runtime library 中 intercptor malloc/free 函数实现中就通过宏 &lt;code>GET_STACK_TRACE_MALLOC&lt;/code> 和 &lt;code>GET_STACK_TRACE_FREE&lt;/code> 来获取 stack trace 保存至 BufferedStackTrace 类型的变量 stack 中，然后将 stack 作为参数传给函数 &lt;code>asan_malloc&lt;/code>, &lt;code>asan_free&lt;/code> 保存起来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// compiler-rt/lib/asan/asan_malloc_linux.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INTERCEPTOR(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>, malloc, uptr size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (DlsymAlloc&lt;span style="color:#f92672">::&lt;/span>Use())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> DlsymAlloc&lt;span style="color:#f92672">::&lt;/span>Allocate(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ENSURE_ASAN_INITED();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET_STACK_TRACE_MALLOC;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">asan_malloc&lt;/span>(size, &lt;span style="color:#f92672">&amp;amp;&lt;/span>stack);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INTERCEPTOR(&lt;span style="color:#66d9ef">void&lt;/span>, free, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (DlsymAlloc&lt;span style="color:#f92672">::&lt;/span>PointerIsMine(ptr))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> DlsymAlloc&lt;span style="color:#f92672">::&lt;/span>Free(ptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET_STACK_TRACE_FREE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> asan_free(ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>stack, FROM_MALLOC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>GET_STACK_TRACE_MALLOC&lt;/code> 和 &lt;code>GET_STACK_TRACE_FREE&lt;/code> 宏展开后经过一系列的调用，最终执行的是 &lt;code>BufferedStackTrace::Unwind()&lt;/code>：&lt;/p>
&lt;p>&lt;code>BufferedStackTrace::Unwind()&lt;/code> 函数的各个参数含义如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>max_depth：设置 unwind 最大回溯的深度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pc: the pc will be in the position 0 of the resulting stack trace. 即 unwind 起始处的 pc，是通过 &lt;code>__builtin_return_address(0)&lt;/code> 得到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bp: the bp may refer to the current frame or to the caller&amp;rsquo;s frame. 即 unwind 起始处的 frame address，是通过 &lt;code>__builtin_frame_address(0)&lt;/code> 得到的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>context: 通常为 nullptr。在 Android lollipop 版本之前，从 signal handler 中 unwind 要基于 libcorkscrew.so，需要用到 signal handler 提供的 context 参数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>stack_top, stack_bottom: unwind 起始处所在线程的线程栈底和线程栈顶，主要用于判断采取 fast unwind 时 unwind 过程何时终止。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>request_fast_unwind: 表示是使用 fast unwind 还是 slow unwind。在环境变量 ASAN_OPTIONS 中可以设置运行时参数 fast_unwind_on_check, fast_unwind_on_fatal, fast_unwind_on_malloc，sanitizer 会根据这些参数的设置以及运行环境是否支持选择使用 fast unwind 还是 slow unwind。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>fast_unwind_on_check: If available, use the fast frame-pointer-based unwinder on internal CHECK failures. Defaults to false.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>fast_unwind_on_fatal: If available, use the fast frame-pointer-based unwinder on fatal errors. Defaults to false.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>fast_unwind_on_malloc: If available, use the fast frame-pointer-based unwinder on malloc/free. Defaults to true.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_libcdep.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> BufferedStackTrace&lt;span style="color:#f92672">::&lt;/span>Unwind(u32 max_depth, uptr pc, uptr bp, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>context,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr stack_top, uptr stack_bottom,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> request_fast_unwind) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Ensures all call sites get what they requested.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHECK_EQ(request_fast_unwind, WillUseFastUnwind(request_fast_unwind));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> top_frame_bp &lt;span style="color:#f92672">=&lt;/span> (max_depth &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> bp : &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Avoid doing any work for small max_depth.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (max_depth &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (max_depth &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace_buffer[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> pc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>WillUseFastUnwind(request_fast_unwind)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if SANITIZER_CAN_SLOW_UNWIND
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnwindSlow(pc, context, max_depth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UnwindSlow&lt;/span>(pc, max_depth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If there are too few frames, the program may be built with
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// -fno-asynchronous-unwind-tables. Fall back to fast unwinder below.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">||&lt;/span> size &lt;span style="color:#f92672">&amp;gt;=&lt;/span> max_depth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> UNREACHABLE(&lt;span style="color:#e6db74">&amp;#34;slow unwind requested but not available&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnwindFast(pc, bp, stack_top, stack_bottom, max_depth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unwindfast">UnwindFast&lt;/h3>
&lt;p>UnwindFast 其实就是基于 frame pointer 的 unwind，具体实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_stacktrace.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> BufferedStackTrace&lt;span style="color:#f92672">::&lt;/span>UnwindFast(uptr pc, uptr bp, uptr stack_top,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr stack_bottom, u32 max_depth) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO(yln): add arg sanity check for stack_top/stack_bottom
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHECK_GE(max_depth, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> uptr kPageSize &lt;span style="color:#f92672">=&lt;/span> GetPageSizeCached();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace_buffer[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> pc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (stack_top &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4096&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>; &lt;span style="color:#75715e">// Sanity check for stack top.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> uhwptr &lt;span style="color:#f92672">*&lt;/span>frame &lt;span style="color:#f92672">=&lt;/span> GetCanonicFrame(bp, stack_top, stack_bottom);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lowest possible address that makes sense as the next frame pointer.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Goes up as we walk the stack.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> uptr bottom &lt;span style="color:#f92672">=&lt;/span> stack_bottom;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Avoid infinite loop when frame == frame[0] by using frame &amp;gt; prev_frame.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (IsValidFrame((uptr)frame, stack_top, bottom) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IsAligned((uptr)frame, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>frame)) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#f92672">&amp;lt;&lt;/span> max_depth) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uhwptr pc1 &lt;span style="color:#f92672">=&lt;/span> frame[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Let&amp;#39;s assume that any pointer in the 0th page (i.e. &amp;lt;0x1000 on i386 and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// x86_64) is invalid and stop unwinding here. If we&amp;#39;re adding support for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// a platform where this isn&amp;#39;t true, we need to reconsider this check.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pc1 &lt;span style="color:#f92672">&amp;lt;&lt;/span> kPageSize)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pc1 &lt;span style="color:#f92672">!=&lt;/span> pc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace_buffer[size&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (uptr) pc1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bottom &lt;span style="color:#f92672">=&lt;/span> (uptr)frame;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frame &lt;span style="color:#f92672">=&lt;/span> GetCanonicFrame((uptr)frame[&lt;span style="color:#ae81ff">0&lt;/span>], stack_top, bottom);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> uhwptr &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetCanonicFrame&lt;/span>(uptr bp,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr stack_top,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr stack_bottom) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHECK_GT(stack_top, stack_bottom);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (uhwptr&lt;span style="color:#f92672">*&lt;/span>)bp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Check if given pointer points into allocated stack area.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">IsValidFrame&lt;/span>(uptr frame, uptr stack_top, uptr stack_bottom) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> frame &lt;span style="color:#f92672">&amp;gt;&lt;/span> stack_bottom &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> frame &lt;span style="color:#f92672">&amp;lt;&lt;/span> stack_top &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span> (uhwptr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unwindslow">UnwindSlow&lt;/h3>
&lt;p>UnwindSlow 就是基于 libunwind 提供的接口 &lt;code>_Unwind_Backtrace&lt;/code> 来实现的 unwind：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_unwind_linux_libcdep.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> BufferedStackTrace&lt;span style="color:#f92672">::&lt;/span>UnwindSlow(uptr pc, u32 max_depth) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHECK_GE(max_depth, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnwindTraceArg arg &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#66d9ef">this&lt;/span>, Min(max_depth &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, kStackTraceMax)};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _Unwind_Backtrace(Unwind_Trace, &lt;span style="color:#f92672">&amp;amp;&lt;/span>arg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// We need to pop a few frames so that pc is on top.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> uptr to_pop &lt;span style="color:#f92672">=&lt;/span> LocatePcInTrace(pc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// trace_buffer[0] belongs to the current function so we always pop it,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// unless there is only 1 frame in the stack trace (1 frame is always better
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// than 0!).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1-frame stacks don&amp;#39;t normally happen, but this depends on the actual
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// unwinder implementation (libgcc, libunwind, etc) which is outside of our
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// control.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (to_pop &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> size &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> to_pop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PopStackFrames(to_pop);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trace_buffer[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> pc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">UnwindTraceArg&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BufferedStackTrace &lt;span style="color:#f92672">*&lt;/span>stack;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u32 max_depth;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>_Unwind_Reason_Code &lt;span style="color:#a6e22e">Unwind_Trace&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_Unwind_Context&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ctx, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>param) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnwindTraceArg &lt;span style="color:#f92672">*&lt;/span>arg &lt;span style="color:#f92672">=&lt;/span> (UnwindTraceArg&lt;span style="color:#f92672">*&lt;/span>)param;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHECK_LT(arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>size, arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_depth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr pc &lt;span style="color:#f92672">=&lt;/span> Unwind_GetIP(ctx);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> uptr kPageSize &lt;span style="color:#f92672">=&lt;/span> GetPageSizeCached();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Let&amp;#39;s assume that any pointer in the 0th page (i.e. &amp;lt;0x1000 on i386 and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// x86_64) is invalid and stop unwinding here. If we&amp;#39;re adding support for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// a platform where this isn&amp;#39;t true, we need to reconsider this check.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (pc &lt;span style="color:#f92672">&amp;lt;&lt;/span> kPageSize) &lt;span style="color:#66d9ef">return&lt;/span> UNWIND_STOP;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>trace_buffer[arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>size&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> pc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stack&lt;span style="color:#f92672">-&amp;gt;&lt;/span>size &lt;span style="color:#f92672">==&lt;/span> arg&lt;span style="color:#f92672">-&amp;gt;&lt;/span>max_depth) &lt;span style="color:#66d9ef">return&lt;/span> UNWIND_STOP;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> UNWIND_CONTINUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>_Unwind_Backtrace&lt;/code> 的函数原型如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// _Unwind_Backtrace() is a gcc extension that walks the stack and calls the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// _Unwind_Trace_Fn once per frame until it reaches the bottom of the stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// or the _Unwind_Trace_Fn function returns something other than _URC_NO_REASON.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">_Unwind_Reason_Code&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>_Unwind_Trace_Fn)(&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_Unwind_Context&lt;/span> &lt;span style="color:#f92672">*&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> _Unwind_Reason_Code &lt;span style="color:#a6e22e">_Unwind_Backtrace&lt;/span>(_Unwind_Trace_Fn, &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>_Unwind_Backtrace&lt;/code> 在 stack unwinding 时，对于每一个 frame 都会调用回调函数 &lt;code>Unwind_Trace&lt;/code> 将此 frame 的 PC/IP 指令地址保存至 BufferedStackTrace 的成员变量 trace_buffer 中。&lt;/p>
&lt;h2 id="stackdepot">StackDepot&lt;/h2>
&lt;p>本节我们来看下 sanitizer runtime 是如何保存 stack trace 的。&lt;/p>
&lt;p>我们在本文前面提到 intercetpr malloc 调用 &lt;code>asan_malloc&lt;/code> 来进行内存分配，而 &lt;code>asan_malloc&lt;/code> 就是对 &lt;code>__asan::Allocator::Allocate&lt;/code> 函数的一层包装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// compiler-rt/lib/asan/asan_allocator.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">asan_malloc&lt;/span>(uptr size, BufferedStackTrace &lt;span style="color:#f92672">*&lt;/span>stack) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> SetErrnoOnNull(instance.Allocate(size, &lt;span style="color:#ae81ff">8&lt;/span>, stack, FROM_MALLOC, true));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Allocate&lt;/span>(uptr size, uptr alignment, BufferedStackTrace &lt;span style="color:#f92672">*&lt;/span>stack,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AllocType alloc_type, &lt;span style="color:#66d9ef">bool&lt;/span> can_fill) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m&lt;span style="color:#f92672">-&amp;gt;&lt;/span>alloc_context_id &lt;span style="color:#f92672">=&lt;/span> StackDepotPut(&lt;span style="color:#f92672">*&lt;/span>stack);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意到 &lt;code>__asan::Allocator::Allocate&lt;/code> 函数是通过调用函数 &lt;code>StackDepotPut&lt;/code> 将 stack unwinding 获取的 stack trace 保存起来。&lt;code>StackDepotPut&lt;/code> 会返回一个 context_id，维护 context_id 与 stack trace 的映射关系，后续可以通过 context_id 找到对应的 stack trace。&lt;/p>
&lt;p>存储 stack trace 的核心数据结构就是 StackDepot，代码位于：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepotbase.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.cpp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// FIXME(dvyukov): this single reserved bit is used in TSan.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> StackDepotBase&lt;span style="color:#f92672">&amp;lt;&lt;/span>StackDepotNode, &lt;span style="color:#ae81ff">1&lt;/span>, StackDepotNode&lt;span style="color:#f92672">::&lt;/span>kTabSizeLog&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StackDepot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> StackDepot theDepot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>u32 &lt;span style="color:#a6e22e">StackDepotPut&lt;/span>(StackTrace stack) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StackDepotHandle h &lt;span style="color:#f92672">=&lt;/span> theDepot.Put(stack);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> h.valid() &lt;span style="color:#f92672">?&lt;/span> h.id() &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StackTrace &lt;span style="color:#a6e22e">StackDepotGet&lt;/span>(u32 id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> theDepot.Get(id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>StackDepotPut&lt;/code> 函数，参数类型是 StackTrace（BufferedStackTrace 是 StackTrace 的子类），返回值类型是 u32。存储 stack trace，返回一个 id，id 与 stack trace 是一一对应关系。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>StackDepotGet&lt;/code> 函数，参数类型是 u32，返回值类型是 StackTrace。根据 id 返回对应的 stack trace。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>StackDepotNode 和 StackDepotBase/StackDepot 的成员变量如下所示。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>StackDepotNode。成员变量 StackDepotNode *link; 存储指向下一个 StackDepotNode 的指针，即多个 StackDepotNode 组成一个链表。成员变量 id 用于标识该 StackDepotNode/StackTrace。成员变量 tag 的可能取值是 TAG_UNKNOWN(0), TAG_ALLOC(1), TAG_DEALLOC(2), TAG_CUSTOM(100) 表示 stack trace 的来源。成员变量 size 就是用于表示 stack trace 的深度，成员变量 stack 是个数组，数组每个元素用于存储 stack trace 每一帧的 pc。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>StackDepot/StackDepotBase。StackDepot 通过 hash table 来存储 StackDepotNode，hash table 维护了 1&amp;laquo;20 个 tab，每 1&amp;laquo;12 个 tab 又组成了一个 part。每个 tab 存储的是指向 StackDepotNode 链表第一个元素的指针。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">StackDepotNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StackDepotNode &lt;span style="color:#f92672">*&lt;/span>link;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u32 id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atomic_uint32_t hash_and_use_count; &lt;span style="color:#75715e">// hash_bits : 12; use_count : 20;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> u32 size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u32 tag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr stack[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">// [size]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> kReservedBits, &lt;span style="color:#66d9ef">int&lt;/span> kTabSizeLog&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StackDepotBase&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atomic_uintptr_t tab[kTabSize]; &lt;span style="color:#75715e">// Hash table of Node&amp;#39;s.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> atomic_uint32_t seq[kPartCount]; &lt;span style="color:#75715e">// Unique id generators.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>StackDepot hash table 示意图如下：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/sanitizer-stacktrace/2022-10-17-22-44-38-image.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于一个给定的 stack trace，首先计算出该 stack trace 的 hash 值记作 h，然后计算 &lt;code>h % kTabSize&lt;/code> 找到存储该 stack trace 的 tab。判断当前给定的 stack trace 是否已经在 &lt;code>tab[h % kTabSize]&lt;/code> 对应的链表中。如果不在，就申请一块内存，在这块内存上根据给定的 stack trace 构造 StackDepotNode，然后将该 StackDepotNode 插入到 &lt;code>tab[h % kTabSize]&lt;/code> 对应的链表开头。
那么 StackDepotNode 的 id 是怎么计算的呢？每 1&amp;laquo;12 个 tab 组成了一个 part，数组 &lt;code>seq[kPartCount]&lt;/code> 存储的是每个 part 中当前已经存储了多少个 StackDepotNode。通过计算 &lt;code>h % kTabSize / kPartSize&lt;/code> 找到存储该 stack trace 的 tab 所在的 part。对于一个新的 StackDepotNode 对应的 id 就是 &lt;code>(seq[part] + 1) | (part &amp;lt;&amp;lt; kPartShift)&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于一个给定的 id，首先通过 &lt;code>uptr part = id &amp;gt;&amp;gt; kPartShift;&lt;/code> 找到该 id 对应的 StackDepotNode 位于哪个 part。遍历该 part 中的 1 &amp;laquo;12 个 tab，在每个 tab 链表中寻找是否存在与给定 id 相等的 StackDepotNode。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>关于 sanitizer runtime 是如何保存 stack trace 的，可以仔细阅读下 StackDepot 的代码实现，这部分代码非常值得学习，这里就不一一贴代码了。&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://maskray.me/blog/2020-11-08-stack-unwinding">Stack unwinding | MaskRay&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://developers.facebook.com/blog/post/2021/09/23/async-stack-traces-folly-synchronous-asynchronous-stack-traces/">https://developers.facebook.com/blog/post/2021/09/23/async-stack-traces-folly-synchronous-asynchronous-stack-traces/&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>How Sanitizer Interceptor Works</title><link>https://enna1.github.io/post/how-sanitizer-interceptor-works/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/how-sanitizer-interceptor-works/</guid><description>&lt;p>本文分析了 sanitizer 是如何做到替换 malloc, free, memcpy 这些库函数的实现的。即 sanitizer 中的 interceptor 机制。&lt;/p>
&lt;p>我们在前面的文章中提到，所有的 Sanitizer 都由编译时插桩 (compile-time instrumentation) 和运行时库 (run-time library) 两部分组成。&lt;/p>
&lt;p>那么 sanitizer 的运行时库中做了哪些事情呢？&lt;/p>
&lt;p>以 ASan 为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ASan 编译时会在每一处内存读写语句之前插入代码，根据每一次访问的内存所对应的影子内存 ( shadow memory，就是使用额外的内存记录常规内存的状态）的状态来检测本次内存访问是否合法。还会在栈变量和全局变量附近申请额外内存作为危险区用于检测内存溢出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ASan 运行时库中最主要的就是替换了 malloc/free, new/delete 的实现，这样应用程序的内存分配都由 ASan 实现的内存分配器负责。ASan 内存分配器会在它分配的堆内存附近申请额外内存用于检测堆内存溢出，还会将被释放的内存优先放在隔离区 (quarantine) 用于检测像 heap-use-after-free, double-free 这样的堆内存错误。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>ASan 运行时库中实际上不止替换了 malloc/free, new/delete 的函数实现，还替换了非常多的库函数的实现，如：memcpy, memmove, strcpy, strcat, pthread_create 等。&lt;/p>
&lt;p>那么 sanitizer 是如何做到替换 malloc, free, memcpy 这些函数实现的呢？答案就是 sanitizer 中的 interceptor 机制。&lt;/p>
&lt;p>本文以 ASan 为例，分析在 Linux x86_64 环境下 sanitizer interceptor 的实现原理。&lt;/p>
&lt;h2 id="symbol-interposition">Symbol interposition&lt;/h2>
&lt;p>在讲解 sanitizer interceptor 的实现原理之前，我们先来了解一下前置知识：symbol interposition。&lt;/p>
&lt;p>首先我们考虑这样一个问题：如何在我们的应用程序中替换 libc 的 malloc 实现为我们自己实现的版本？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>一个最简单的方式就是在我们的应用程序中定义一个同名的 malloc 函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一种方式就是将我们的 malloc 函数实现在 libmymalloc.so 中，然后在运行我们的应用程序之前设置环境变量 &lt;code>LD_PRELOAD=/path/to/libmymalloc.so&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>那么为什么上述两种方式能生效呢？答案是 symbol interposition。&lt;/p>
&lt;p>&lt;a href="http://www.sco.com/developers/gabi/latest/contents.html">ELF specfication&lt;/a> 在第五章 Program Loading and Dynamic Linking 中提到：&lt;/p>
&lt;blockquote>
&lt;p>When resolving symbolic references, the dynamic linker examines the symbol tables with a breadth-first search. That is, it first looks at the symbol table of the executable program itself, then at the symbol tables of the &lt;code>DT_NEEDED&lt;/code> entries (in order), and then at the second level &lt;code>DT_NEEDED&lt;/code> entries, and so on.&lt;/p>
&lt;/blockquote>
&lt;p>动态链接器 (dynamic linker/loader) 在符号引用绑定 (binding symbol references) 时，以一种广度优先搜索的顺序来查找符号：executable, needed0.so, needed1.so, needed2.so, needed0_of_needed0.so, needed1_of_needed0.so, &amp;hellip;&lt;/p>
&lt;p>如果设置了 LD_PRELOAD，那么查找符号的顺序会变为：executable, preload0.so, preload1.so needed0.so, needed1.so, needed2.so, needed0_of_needed0.so, needed1_of_needed0.so, &amp;hellip;&lt;/p>
&lt;p>如果一个符号在多个组件（executable 或 shared object）中都存在定义，那么动态链接器会选择它所看到的第一个定义。&lt;/p>
&lt;p>我们通过一个例子来理解该过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat main.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> W(), X();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (W() &lt;span style="color:#f92672">+&lt;/span> X()); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat W.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">W&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (a() &lt;span style="color:#f92672">-&lt;/span> b()); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat w.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> b() { &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat X.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">3&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (a() &lt;span style="color:#f92672">-&lt;/span> b()); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> cat x.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> b() { &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">4&lt;/span>); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> gcc &lt;span style="color:#f92672">-&lt;/span>o libw.so &lt;span style="color:#f92672">-&lt;/span>shared w.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> gcc &lt;span style="color:#f92672">-&lt;/span>o libW.so &lt;span style="color:#f92672">-&lt;/span>shared W.c &lt;span style="color:#f92672">-&lt;/span>L. &lt;span style="color:#f92672">-&lt;/span>lw &lt;span style="color:#f92672">-&lt;/span>Wl,&lt;span style="color:#f92672">-&lt;/span>rpath&lt;span style="color:#f92672">=&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> gcc &lt;span style="color:#f92672">-&lt;/span>o libx.so &lt;span style="color:#f92672">-&lt;/span>shared x.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> gcc &lt;span style="color:#f92672">-&lt;/span>o libX.so &lt;span style="color:#f92672">-&lt;/span>shared X.c &lt;span style="color:#f92672">-&lt;/span>L. &lt;span style="color:#f92672">-&lt;/span>lx &lt;span style="color:#f92672">-&lt;/span>Wl,&lt;span style="color:#f92672">-&lt;/span>rpath&lt;span style="color:#f92672">=&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span> gcc &lt;span style="color:#f92672">-&lt;/span>o test&lt;span style="color:#f92672">-&lt;/span>symbind main.c &lt;span style="color:#f92672">-&lt;/span>L. &lt;span style="color:#f92672">-&lt;/span>lW &lt;span style="color:#f92672">-&lt;/span>lX &lt;span style="color:#f92672">-&lt;/span>Wl,&lt;span style="color:#f92672">-&lt;/span>rpath&lt;span style="color:#f92672">=&lt;/span>.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该例子中可执行文件与动态库之间的依赖关系如下图所示：&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/sanitizer-interceptor/2022-10-02-20-18-44-image.png" alt="">&lt;/p>
&lt;p>按照我们前面所说，本例中动态链接器在进行符号引用绑定时，是按照广度优先搜索的顺序，即：test-symbind, libW.so, libX.so, libc.so, libw.so, libx.so 的顺序查找符号定义的。&lt;/p>
&lt;p>动态链接器提供了环境变量 LD_DEBUG 来输出一些调试信息，我们可以通过设置环境变量 LD_DEBUG=&amp;ldquo;symbols:bindings&amp;rdquo; 看下 test-symbind 的 symbol binding 的过程：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ LD_DEBUG=&amp;#34;symbols:bindings&amp;#34; ./test-symbind
1884890: symbol=a; lookup in file=./test-symbind [0]
1884890: symbol=a; lookup in file=./libW.so [0]
1884890: binding file ./libW.so [0] to ./libW.so [0]: normal symbol `a&amp;#39;
1884890: symbol=b; lookup in file=./test-symbind [0]
1884890: symbol=b; lookup in file=./libW.so [0]
1884890: symbol=b; lookup in file=./libX.so [0]
1884890: symbol=b; lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
1884890: symbol=b; lookup in file=./libw.so [0]
1884890: binding file ./libW.so [0] to ./libw.so [0]: normal symbol `b&amp;#39;
1884890: symbol=a; lookup in file=./test-symbind [0]
1884890: symbol=a; lookup in file=./libW.so [0]
1884890: binding file ./libX.so [0] to ./libW.so [0]: normal symbol `a&amp;#39;
1884890: symbol=b; lookup in file=./test-symbind [0]
1884890: symbol=b; lookup in file=./libW.so [0]
1884890: symbol=b; lookup in file=./libX.so [0]
1884890: symbol=b; lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
1884890: symbol=b; lookup in file=./libw.so [0]
1884890: binding file ./libX.so [0] to ./libw.so [0]: normal symbol `b&amp;#39;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>函数 a 在 libW.so 和 libX.so 中都有一份定义，但因为是按照 test-symbind, libW.so, libX.so, libc.so, libw.so, libx.so 的顺序查找符号定义的，所以最终所有对函数 a 的引用都绑定到 libW.so 中函数 a 的实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数 b 在 libw.so 和 libx.so 中都有一份定义，但因为是按照 test-symbind, libW.so, libX.so, libc.so, libw.so, libx.so 的顺序查找符号定义的，所以最终所有对函数 b 的引用都绑定到 libw.so 中函数 b 的实现&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>这样我们就理解为什么上述两种替换 malloc 的方式能生效了：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>方式一：在我们的应用程序中定义一个同名的 malloc 函数。动态链接器在查找符号时 executable 的顺序在 libc.so 之前，因此所有对 malloc 的引用都会绑定到 executable 中 malloc 的实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>方式二：将我们的 malloc 函数实现在 libmymalloc.so 中，然后在运行我们的应用程序之前设置环境变量 LD_PRELOAD=/path/to/libmymalloc.so。动态链接器在查找符号时 libmymalloc.so 的顺序在 libc.so 之前，因此所有对 malloc 的引用都会绑定到 libmymalloc.so 中 malloc 的实现。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>实际上 sanitizer 对于 malloc/free 等库函数的替换正是利用了 symbol interposition 这一特性。下面我们以 ASan 为例来验证一下。&lt;/p>
&lt;p>考虑如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// test.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello AddressSanitizer!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们首先看下 GCC 的行为。&lt;/p>
&lt;p>使用 GCC 开启 ASan 编译 test.cpp ，&lt;code>g++ -fsanitize=address test.cpp -o test-gcc-asan&lt;/code> 得到编译产物 test-gcc-asan。因为 GCC 默认会&lt;strong>动态链接&lt;/strong> ASan 运行时库，所以我们可以使用 &lt;code>objdump -p test-gcc-asan | grep NEEDED&lt;/code> 查看 test-gcc-asan 依赖的动态库 (shared objects)：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ objdump -p test-gcc-asan | grep NEEDED
NEEDED libasan.so.5
NEEDED libstdc++.so.6
NEEDED libm.so.6
NEEDED libgcc_s.so.1
NEEDED libc.so.6
&lt;/code>&lt;/pre>&lt;p>可以清楚的看到在 test-gcc-asan 依赖的动态库中 libasan.so 的顺序是在 libc.so 之前的。实际上链接时参数 &lt;code>-fsanitize=address&lt;/code> 会使得 libasan.so 成为程序的第一个依赖库。&lt;/p>
&lt;p>然后我们再通过环境变量 LD_DEBUG 看下 test-gcc-asan 的 symbol bindding 的过程：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ LD_DEBUG=&amp;#34;bindings&amp;#34; ./test-gcc-asan
3309213: binding file /lib/x86_64-linux-gnu/libc.so.6 [0] to /usr/lib/x86_64-linux-gnu/libasan.so.5 [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
3309213: binding file /lib64/ld-linux-x86-64.so.2 [0] to /usr/lib/x86_64-linux-gnu/libasan.so.5 [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
3309213: binding file /usr/lib/x86_64-linux-gnu/libstdc++.so.6 [0] to /usr/lib/x86_64-linux-gnu/libasan.so.5 [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
&lt;/code>&lt;/pre>&lt;p>可以看到动态链接器将 libc.so, ld-linux-x86-64.so 和 libstdc++.so 中对 malloc 的引用都绑定到了 libasan.so 中的 malloc 实现。&lt;/p>
&lt;hr>
&lt;p>下面我们看下 Clang，因为 Clang 默认是&lt;strong>静态链接&lt;/strong> ASan 运行时库，所以我们就不看 test-clang-asan 所依赖的动态库了，直接看 symbol binding 的过程：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ clang++ -fsanitize=address test.cpp -o test-clang-asan
$ LD_DEBUG=&amp;#34;bindings&amp;#34; ./test-clang-asan
3313022: binding file /lib/x86_64-linux-gnu/libc.so.6 [0] to ./test-clang-asan [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
3313022: binding file /lib64/ld-linux-x86-64.so.2 [0] to ./test-clang-asan [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
3313022: binding file /usr/lib/x86_64-linux-gnu/libstdc++.so.6 [0] to ./test-clang-asan [0]: normal symbol `malloc&amp;#39; [GLIBC_2.2.5]
&lt;/code>&lt;/pre>&lt;p>同样可以看到动态链接器将 libc.so, ld-linux-x86-64.so.2 和 libstdc++.so 中对 malloc 的引用都绑定到了 test-clang-asan 中的 malloc 实现（因为 ASan 运行时库 中实现了 malloc，并且 clang 将 ASan 运行时库静态链接到 test-clang-asan 中）。&lt;/p>
&lt;h2 id="sanitizer-interceptor">Sanitizer interceptor&lt;/h2>
&lt;p>下面我们来在源码的角度，学习下 sanitizer interceptor 的实现。&lt;/p>
&lt;p>阅读学习 LLVM 代码的一个非常有效的方式就是结合对应的测试代码来学习。&lt;/p>
&lt;p>Sanitizer interceptor 存在一个测试文件 interception_linux_test.cpp，&lt;a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/interception/tests/interception_linux_test.cpp">llvm-project/interception_linux_test.cpp at main · llvm/llvm-project · GitHub&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;interception/interception.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;gtest/gtest.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> InterceptorFunctionCalled;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DECLARE_REAL(&lt;span style="color:#66d9ef">int&lt;/span>, isdigit, &lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INTERCEPTOR(&lt;span style="color:#66d9ef">int&lt;/span>, isdigit, &lt;span style="color:#66d9ef">int&lt;/span> d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>InterceptorFunctionCalled;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> d &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> d &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> __interception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST(Interception, Basic) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_TRUE(INTERCEPT_FUNCTION(isdigit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// After interception, the counter should be incremented.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> InterceptorFunctionCalled &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_NE(&lt;span style="color:#ae81ff">0&lt;/span>, isdigit(&lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_EQ(&lt;span style="color:#ae81ff">1&lt;/span>, InterceptorFunctionCalled);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_EQ(&lt;span style="color:#ae81ff">0&lt;/span>, isdigit(&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_EQ(&lt;span style="color:#ae81ff">2&lt;/span>, InterceptorFunctionCalled);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Calling the REAL function should not affect the counter.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> InterceptorFunctionCalled &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_NE(&lt;span style="color:#ae81ff">0&lt;/span>, REAL(isdigit)(&lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_EQ(&lt;span style="color:#ae81ff">0&lt;/span>, REAL(isdigit)(&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EXPECT_EQ(&lt;span style="color:#ae81ff">0&lt;/span>, InterceptorFunctionCalled);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// namespace __interception
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段测试代码基于 sanitizer 的 interceptor 机制替换了 &lt;code>isdigit&lt;/code> 函数的实现，在我们实现的 &lt;code>isdigit&lt;/code> 函数中，每次 &lt;code>isdigit&lt;/code> 函数被调用时都将变量 &lt;code>InterceptorFunctionCalled&lt;/code> 自增 1。然后通过检验变量 &lt;code>InterceptorFunctionCalled&lt;/code> 的值来测试 interceptor 机制的实现是否正确，通过 &lt;code>REAL(isdigit)&lt;/code> 来调用真正的 &lt;code>isdigit&lt;/code> 函数实现。&lt;/p>
&lt;p>上述测试文件 interception_linux_test.cpp 中实现替换 &lt;code>isdigit&lt;/code> 函数的核心部分是如下代码片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>INTERCEPTOR(&lt;span style="color:#66d9ef">int&lt;/span>, isdigit, &lt;span style="color:#66d9ef">int&lt;/span> d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>InterceptorFunctionCalled;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> d &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> d &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INTERCEPT_FUNCTION(isdigit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DECLARE_REAL(&lt;span style="color:#66d9ef">int&lt;/span>, isdigit, &lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>REAL(isdigit)(&lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>INTERCEPTOR(int, isdigit, int d) { ... }&lt;/code> 用于将函数 &lt;code>isdigit&lt;/code> 的实现替换为 { &amp;hellip; } 的实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在代码中调用 &lt;code>isdigit&lt;/code> 之前，需要先调用 &lt;code>INTERCEPT_FUNCTION(isdigit)&lt;/code>。如果 &lt;code>INTERCEPT_FUNCTION(isdigit)&lt;/code> 返回为 true，则说明成功替换了将 libc 中 &lt;code>isdigit&lt;/code> 函数的实现。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>REAL(isdigit)('1')&lt;/code> 用于调用真正的 &lt;code>isdigit&lt;/code> 实现，不过在调用 &lt;code>REAL(isdigit)('1')&lt;/code> 之前需要先 &lt;code>DECLARE_REAL(int, isdigit, int)&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这部分代码在宏展开后的内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// INTERCEPTOR(int, isdigit, int d) 宏展开
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>isdigit_type)(&lt;span style="color:#66d9ef">int&lt;/span> d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> __interception { isdigit_type real_isdigit; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> isdigit(&lt;span style="color:#66d9ef">int&lt;/span> d) __attribute__((weak, alias(&lt;span style="color:#e6db74">&amp;#34;__interceptor_isdigit&amp;#34;&lt;/span>), visibility(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> __attribute__((visibility(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>))) &lt;span style="color:#66d9ef">int&lt;/span> __interceptor_isdigit(&lt;span style="color:#66d9ef">int&lt;/span> d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>InterceptorFunctionCalled;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> d &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> d &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// INTERCEPT_FUNCTION(isdigit) 宏展开
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">::&lt;/span>__interception&lt;span style="color:#f92672">::&lt;/span>InterceptFunction(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;isdigit&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">::&lt;/span>__interception&lt;span style="color:#f92672">::&lt;/span>uptr &lt;span style="color:#f92672">*&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> __interception&lt;span style="color:#f92672">::&lt;/span>real_isdigit,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">::&lt;/span>__interception&lt;span style="color:#f92672">::&lt;/span>uptr) &lt;span style="color:#f92672">&amp;amp;&lt;/span> (isdigit),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">::&lt;/span>__interception&lt;span style="color:#f92672">::&lt;/span>uptr) &lt;span style="color:#f92672">&amp;amp;&lt;/span> __interceptor_isdigit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DECLARE_REAL(int, isdigit, int) 宏展开
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>isdigit_type)(&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> __interception { &lt;span style="color:#66d9ef">extern&lt;/span> isdigit_type real_isdigit; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// REAL(isdigit)(&amp;#39;1&amp;#39;) 宏展开
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>__interception&lt;span style="color:#f92672">::&lt;/span>real_isdigit(&lt;span style="color:#e6db74">&amp;#39;1&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>我们首先看下 INTERCEPTOR 宏做了哪些事情&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先在 __interception namespace 中定义了一个函数指针 real_isdigit，该函数指针实际上后续会被设置为指向真正的 &lt;code>isdigit&lt;/code> 函数地址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后将 &lt;code>isdigit&lt;/code> 函数设置为 weak，并且将 &lt;code>isdigit&lt;/code> 设置成 &lt;code>__interceptor_isdigit&lt;/code> 的 alias 别名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后将我们自己版本的 &lt;code>isdigit&lt;/code> 函数逻辑实现在 &lt;code>__interceptor_isdigit&lt;/code> 函数中&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>根据 symbol interposition 这一节的内容，我们知道：要想替换 libc.so 中 某个函数的实现（不妨把该函数称作 &lt;code>foo&lt;/code>），只需要在 sanitizer runtime library 中定义同名 &lt;code>foo&lt;/code> 函数，然后让 dynamic loader 在查找符号时 sanitizer runtime library 的顺序先于 libc.so 即可。&lt;/p>
&lt;p>那为什么这里要将我们的 &lt;code>isdigit&lt;/code> 函数逻辑实现在函数 &lt;code>__interceptor_isdigit&lt;/code> 中，并且将 &lt;code>isdigit&lt;/code> 设置成 &lt;code>__interceptor_isdigit&lt;/code> 的 alias 别名呢？&lt;/p>
&lt;p>考虑如下场景：假设用户代码中也替换了 &lt;code>isdigit&lt;/code> 函数的实现，添加了自己的逻辑，那么最终 dynamic loader 选择的是用户代码中的 &lt;code>isdigit&lt;/code> 的实现，而不是 sanitizer runtime library 中的 &lt;code>isdigit&lt;/code> 的实现，这样的话 sanitizer 的功能就不能正常工作了。（实际上 sanitizer runtime library 中并没有替换 &lt;code>isdigit&lt;/code> 的实现，这里只是用 &lt;code>isdigit&lt;/code> 举例子便于说明）。&lt;/p>
&lt;p>但是如果我们在 sanitizer runtime library 中将 &lt;code>isdigit&lt;/code> 设置成 &lt;code>__interceptor_isdigit&lt;/code> 的 alias 别名，那么在用户代码中自己替换 &lt;code>isdigit&lt;/code> 实现时就可以显示调用 &lt;code>__interceptor_isdigit&lt;/code> 了。这样既不影响用户自行替换库函数，也不影响 sanitizer 功能的正确运行 ：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __interceptor_isdigit(&lt;span style="color:#66d9ef">int&lt;/span> d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> isdigit(&lt;span style="color:#66d9ef">int&lt;/span> d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fprintf(stderr, &lt;span style="color:#e6db74">&amp;#34;my_isdigit_interceptor&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">__interceptor_isdigit&lt;/span>(d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那在 sanitizer runtime library 中为什么将被替换的函数设置为 weak 呢？&lt;/p>
&lt;p>这是因为如果不设置为 weak ，在静态链接 sanitizer runtime library 时就会因为 multiple definition 而链接失败。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着我们看下 INTERCEPT_FUNCTION 宏做了哪些事情&lt;/p>
&lt;p>INTERCEPT_FUNCTION 宏展开后就是对 __interception::InterceptFunction 函数的调用。&lt;code>InterceptFunction&lt;/code> 函数的定义在 &lt;a href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/interception/interception_linux.cpp">https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/interception/interception_linux.cpp&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> __interception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">GetFuncAddr&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name, uptr wrapper_addr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr &lt;span style="color:#f92672">=&lt;/span> dlsym(RTLD_NEXT, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>addr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If the lookup using RTLD_NEXT failed, the sanitizer runtime library is
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// later in the library search order than the DSO that we are trying to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// intercept, which means that we cannot intercept this function. We still
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// want the address of the real definition, though, so look it up using
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// RTLD_DEFAULT.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> addr &lt;span style="color:#f92672">=&lt;/span> dlsym(RTLD_DEFAULT, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In case `name&amp;#39; is not loaded, dlsym ends up finding the actual wrapper.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// We don&amp;#39;t want to intercept the wrapper and have it point to itself.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> ((uptr)addr &lt;span style="color:#f92672">==&lt;/span> wrapper_addr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">InterceptFunction&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>name, uptr &lt;span style="color:#f92672">*&lt;/span>ptr_to_real, uptr func,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr wrapper) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr &lt;span style="color:#f92672">=&lt;/span> GetFuncAddr(name, wrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>ptr_to_real &lt;span style="color:#f92672">=&lt;/span> (uptr)addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> addr &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (func &lt;span style="color:#f92672">==&lt;/span> wrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// namespace __interception
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实 &lt;code>InterceptFunction&lt;/code> 函数的实现很简单：首先通过函数 &lt;code>GetFuncAddr&lt;/code> 获得原本的名为 name 的函数地址，然后将该地址保存至指针 &lt;code>ptr_to_real&lt;/code> 指向的内存。&lt;/p>
&lt;p>函数 &lt;code>GetFuncAddr&lt;/code> 的代码实现也很简单，核心就是 &lt;a href="https://man7.org/linux/man-pages/man3/dlsym.3.html">dlsym&lt;/a>：&lt;/p>
&lt;pre>&lt;code>RTLD_DEFAULT
Find the first occurrence of the desired symbol using the
default shared object search order. The search will
include global symbols in the executable and its
dependencies, as well as symbols in shared objects that
were dynamically loaded with the RTLD_GLOBAL flag.
RTLD_NEXT
Find the next occurrence of the desired symbol in the
search order after the current object. This allows one to
provide a wrapper around a function in another shared
object, so that, for example, the definition of a function
in a preloaded shared object (see LD_PRELOAD in ld.so(8))
can find and invoke the &amp;quot;real&amp;quot; function provided in
another shared object (or for that matter, the &amp;quot;next&amp;quot;
definition of the function in cases where there are
multiple layers of preloading).
&lt;/code>&lt;/pre>
&lt;p>这也是为什么在函数 &lt;code>GetFuncAddr&lt;/code> 中，先用 &lt;code>dlsym(RTLD_NEXT, name)&lt;/code> 去寻找被 intercepted 函数的真实地址，因为 sanitizer runtime library 是先于 name 函数真正所在的 shared object。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后我们看下 DECLARE_REAL 宏 和 REAL 宏做了哪些事情&lt;/p>
&lt;p>DECLARE_REAL 展开后就是声明了在 __interception namespace 中存在一个指向被替换函数真正实现的函数指针，REAL 宏就是通过这个函数指针来调用被替换函数的真正实现。&lt;/p>
&lt;p>例如，在测试用例中，&lt;code>DECLARE_REAL(int, isdigit, int);&lt;/code> 就是在声明 __interception namespace 中存在一个函数指针 &lt;code>real_isdigit&lt;/code>，该函数指针指向真正的 &lt;code>isdigit&lt;/code> 函数地址，通过 &lt;code>REAL(isdigit)&lt;/code> 来调用真正的 &lt;code>isdigit&lt;/code> 函数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="ps">P.S.&lt;/h2>
&lt;p>&lt;code>__attribute__((alias))&lt;/code> 很有意思：&lt;/p>
&lt;blockquote>
&lt;p>Where a function is defined in the current translation unit, the alias call is replaced by a call to the function, and the alias is emitted alongside the original name. Where a function is not defined in the current translation unit, the alias call is replaced by a call to the real function. Where a function is defined as static, the function name is replaced by the alias name and the function is declared external if the alias name is declared external.&lt;/p>
&lt;/blockquote>
&lt;p>在 ASan runtime library 中 malloc 是 weak 符号，并且 malloc 和 __interceptor_malloc 实际指向同一个地址。&lt;/p>
&lt;p>也就是说 &lt;code>extern &amp;quot;C&amp;quot; void *malloc(size_t size) __attribute__((weak, alias(&amp;quot;__interceptor_malloc&amp;quot;), visibility(&amp;quot;default&amp;quot;)));&lt;/code> 使得在 ASan runtime library 中造了一个弱符号 malloc，然后指向的和 __interceptor_malloc 是同一个地址。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ readelf -sW --dyn-syms $(clang -print-file-name=libclang_rt.asan-x86_64.a) | grep malloc
...
99: 0000000000001150 606 FUNC GLOBAL DEFAULT 3 __interceptor_malloc
102: 0000000000001150 606 FUNC WEAK DEFAULT 3 malloc
$ readelf -sW --dyn-syms $(clang -print-file-name=libclang_rt.asan-x86_64.so) | grep malloc
...
3008: 00000000000fd600 606 FUNC WEAK DEFAULT 12 malloc
4519: 00000000000fd600 606 FUNC GLOBAL DEFAULT 12 __interceptor_malloc
&lt;/code>&lt;/pre>&lt;h2 id="ps2">P.S.2&lt;/h2>
&lt;p>熟悉在 Linux 下 sanitizer interceptor 机制的底层原理后，就很容易明白使用 sanitizer 时遇到的一些问题或坑为什么会是这样的。例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/google/sanitizers/issues/611">Address Sanitizer fails to intercept function in shared library opened with RTLD_DEEPBIND · Issue #611 · google/sanitizers · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/google/sanitizers/issues/796">ASan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD. · Issue #796 · google/sanitizers · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://stackoverflow.com/questions/66971217/is-it-okay-if-asan-runtime-loaded-as-second-library">address sanitizer - Is it okay if ASAN runtime loaded as second library? - Stack Overflow&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://maskray.me/blog/2021-05-16-elf-interposition-and-bsymbolic">ELF interposition and -Bsymbolic | MaskRay&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man3/dlsym.3.html">dlsym(3) - Linux manual pagedlsym(3) - Linux manual page&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/llvm/llvm-project/commit/7fb7330469af52ae1313b2b47c273e62c61a4dd5">asan/tsan: weak interceptors · llvm/llvm-project@7fb7330 · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>How Sanitizer Runtime Initialized</title><link>https://enna1.github.io/post/how-sanitizer-runtime-init/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/how-sanitizer-runtime-init/</guid><description>&lt;p>本文分析了 sanitizer runtime 是如何做到在程序启动之前进行初始化的。&lt;/p>
&lt;h2 id="what-is-a-sanitizer">What is a sanitizer?&lt;/h2>
&lt;p>Sanitizers 是由 Google 开源的动态代码分析工具，包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>AddressSanitizer (ASan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LeakSanitizer (LSan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ThreadSanitizer (TSan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UndefinedBehaviorSanitizer (UBSsan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MemorySanitizer (MSan)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所有的 Sanitizer 都由编译时插桩和运行时库两部分组成，Sanitizer 自 Clang 3.1 和 GCC 4.8 开始被集成在 Clang 和 GCC 中。&lt;/p>
&lt;h2 id="sanitizer-runtime">Sanitizer runtime&lt;/h2>
&lt;p>我们先以 ASan 为例，简单看下 ASan runtime library 做了哪些事情。&lt;/p>
&lt;p>ASan runtime 做的最主要的事情就是替换了 malloc/free, new/delete 的实现。这样应用程序的内存分配都由 ASan 实现的 allocator 来做，就能检测像 heap-use-after-free, double-free 这样的堆错误了。&lt;/p>
&lt;p>程序在启用 ASan 后，virtual address space 会被分成 main application memory 和 shadow memory 两部分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem ||
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// || `[0x00008fff7000, 0x02008fff6fff]` || ShadowGap ||
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow ||
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// || `[0x000000000000, 0x00007fff7fff]` || LowMem ||
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么 ASan shadow memory 是什么时候初始化的？答：在程序启动之前 sanitizer runtime 初始化时做的。&lt;/p>
&lt;p>另外，在使用 ASan 时，我们可以通过环境变量 ASAN_OPTIONS 来设置一些运行时参数，如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>log_path，指定 sanitizer 的报告输出的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>detect_stack_use_after_return，是否检测 stack-use-after-return 类型的 bug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>alloc_dealloc_mismatch，是否检测 alloc-dealloc-mismatch 类型的 bug&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>那么这些通过 ASAN_OPTIONS 设置的运行时参数又是在什么时候被解析生效的呢？答：也是在程序启动之前在 sanitizer runtime 初始化时做的。&lt;/p>
&lt;hr>
&lt;p>ASan runtime 初始化的入口函数是 &lt;code>__asan_init&lt;/code>（感兴趣的话，可以仔细阅读下代码，本文不做此做详细的分析了。我这里截取了与 runtime flags 和 shadow memory 初始化相关的函数）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// compiler-rt/lib/asan/asan_rtl.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__asan_init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AsanActivate();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AsanInitInternal();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AsanInitInternal&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Initialize flags. This must be done early, because most of the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// initialization steps look at flags().
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> InitializeFlags();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Set up the shadow memory.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> InitializeShadowMemory();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那 sanitizer runtime 是怎么做到在程序启动之前执行初始化的相关代码的呢？一言以蔽之： &lt;code>.init_array&lt;/code>。下面我们详细看下是怎么实现的。&lt;/p>
&lt;h2 id="instrumentation">Instrumentation&lt;/h2>
&lt;p>首先看下 ASan 插装代码中与 sanitizer runtime 初始化相关的实现。&lt;/p>
&lt;p>ASan 插装部分的代码实现位于 llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp。有如下代码片段（简化并省略部分代码）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> kAsanInitName[] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;__asan_init&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> kAsanModuleCtorName[] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;asan.module_ctor&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> ModuleAddressSanitizer&lt;span style="color:#f92672">::&lt;/span>instrumentModule(Module &lt;span style="color:#f92672">&amp;amp;&lt;/span>M) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Create a module constructor.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string AsanVersion &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>to_string(GetAsanVersion(M));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string VersionCheckName &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClInsertVersionCheck &lt;span style="color:#f92672">?&lt;/span> (kAsanVersionCheckNamePrefix &lt;span style="color:#f92672">+&lt;/span> AsanVersion) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>tie(AsanCtorFunction, std&lt;span style="color:#f92672">::&lt;/span>ignore) &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createSanitizerCtorAndInitFunctions(M, kAsanModuleCtorName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kAsanInitName, &lt;span style="color:#75715e">/*InitArgTypes=*/&lt;/span>{},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*InitArgs=*/&lt;/span>{}, VersionCheckName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> Priority &lt;span style="color:#f92672">=&lt;/span> GetCtorAndDtorPriority(TargetTriple);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appendToGlobalCtors(M, AsanCtorFunction, Priority);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ModuleAddressSanitizer::instrumentModule(Module &amp;amp;M)&lt;/code> 的实现很简单：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先调用 &lt;code>createSanitizerCtorAndInitFunctions&lt;/code> 创建了一个名为 &lt;code>kAsanModuleCtorName&lt;/code> 的函数，该函数的函数体很简单，就是对 &lt;code>kAsanInitName&lt;/code> 函数和 &lt;code>VersionCheckName&lt;/code> 函数的调用，其中因为 &lt;code>kAsanInitName&lt;/code> 函数没有任何的参数，所以 &lt;code>InitArgTypes&lt;/code> 和 &lt;code>InitArgs&lt;/code> 都是空。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后通过调用 &lt;code>appendToGlobalCtors&lt;/code> 将通过 &lt;code>createSanitizerCtorAndInitFunctions&lt;/code> 创建的函数，添加至 GlobalCtors 中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>可能上述描述的还是不够清晰，下面结合一个例子来进一步说明。&lt;/p>
&lt;p>考虑如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> [] array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> array[argc]; &lt;span style="color:#75715e">// BOOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;a href="https://godbolt.org/z/KxesEK3Wf">Compiler Explorer&lt;/a> 能很方便看到开启 ASan 后（-fsanitize=address）生成的 LLVM IR 是什么样（这里只截取了部分我们关注的 LLVM IR）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-llvm" data-lang="llvm">&lt;span style="display:flex;">&lt;span>@llvm.global_ctors = &lt;span style="color:#66d9ef">appending&lt;/span> &lt;span style="color:#66d9ef">global&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">x&lt;/span> { &lt;span style="color:#66d9ef">i32&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span> ()*, &lt;span style="color:#66d9ef">i8&lt;/span>* }] [{ &lt;span style="color:#66d9ef">i32&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span> ()*, &lt;span style="color:#66d9ef">i8&lt;/span>* } { &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span> ()* @asan.module_ctor, &lt;span style="color:#66d9ef">i8&lt;/span>* &lt;span style="color:#66d9ef">null&lt;/span> }]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> @__asan_init()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">declare&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> @__asan_version_mismatch_check_v8()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">define&lt;/span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> @asan.module_ctor() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">call&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> @__asan_init()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">call&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> @__asan_version_mismatch_check_v8()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ret&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>开启 ASan 后，能明显的看到多了一个函数 &lt;code>asan.module_ctor&lt;/code>，多了一个全局变量 &lt;code>@llvm.global_ctors&lt;/code>。它们分别由 ASan 插装函数 &lt;code>ModuleAddressSanitizer::instrumentModule(Module &amp;amp;M)&lt;/code> 调用 &lt;code>createSanitizerCtorAndInitFunctions&lt;/code> 和 &lt;code>appendToGlobalCtors&lt;/code> 创建的。&lt;/p>
&lt;p>&lt;code>asan.module_ctor&lt;/code> 函数体由两个函数调用组成：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>call void @__asan_init()&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>call void @__asan_version_mismatch_check_v8()&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>函数 &lt;code>__asan_init&lt;/code> 是在 runtime libraray 中实现的，其代码实现我们前面已经给出了；函数 &lt;code>__asan_version_mismatch_check_v8&lt;/code> 也是在 runtime libaray 中实现的，顾名思义就是用于检测 asan instrumentation 和 runtime library 的版本是否匹配。&lt;/p>
&lt;p>然后 &lt;code>@llvm.global_ctors&lt;/code> 中包含了函数 &lt;code>asan.module_ctor&lt;/code> 的指针。&lt;/p>
&lt;p>那么 &lt;code>@llvm.global_ctors&lt;/code> 是什么、是怎么实现的？&lt;/p>
&lt;p>根据 &lt;a href="https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable">https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable&lt;/a> ：&lt;/p>
&lt;blockquote>
&lt;p>The &lt;code>@llvm.global_ctors&lt;/code> array contains a list of constructor functions, priorities, and an associated global or function. The functions referenced by this array will be called in ascending order of priority (i.e. lowest first) when the module is loaded. The order of functions with the same priority is not defined.&lt;/p>
&lt;p>If the third field is non-null, and points to a global variable or function, the initializer function will only run if the associated data from the current module is not discarded. On ELF the referenced global variable or function must be in a comdat.&lt;/p>
&lt;/blockquote>
&lt;p>即 &lt;code>@llvm.global_ctors&lt;/code> 是一个数组，包含了一些 constructor functions。这些 constructor functions 会按照 priority 升序在 module 被加载时被调用。&lt;/p>
&lt;p>但是 llvm 文档中并没有说 &lt;code>@llvm.global_ctors&lt;/code> 是如何做到 “constructor functions 在 module 被加载时被调用“ 的。&lt;/p>
&lt;h2 id="init_array">.init_array&lt;/h2>
&lt;p>实际上 LLVM IR 中的 &lt;code>@llvm.global_ctors&lt;/code> 在生成汇编代码时，对应的是 &lt;code>.init_array&lt;/code>。&lt;/p>
&lt;p>我们还是通过前面用到的示例代码来说明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> [] array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> array[argc]; &lt;span style="color:#75715e">// BOOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过 &lt;code>clang++ -fsanitize=address test.cpp -S&lt;/code> 可以得到开启 ASan 后生成的汇编代码（我们这里省略了 main 函数的汇编代码）：&lt;/p>
&lt;pre tabindex="0">&lt;code> .section .text.asan.module_ctor,&amp;#34;axR&amp;#34;,@progbits
.p2align 4, 0x90 # -- Begin function asan.module_ctor
.type asan.module_ctor,@function
asan.module_ctor: # @asan.module_ctor
pushq %rbp
movq %rsp, %rbp
callq __asan_init@PLT
callq __asan_version_mismatch_check_v8@PLT
popq %rbp
retq
.section .init_array.1,&amp;#34;aw&amp;#34;,@init_array
.p2align 3
.quad asan.module_ctor
&lt;/code>&lt;/pre>&lt;p>首先是 &lt;code>asan.module_ctor&lt;/code> 的汇编实现，没什么特别：就是两条 call 指令，分别对函数 &lt;code>__asan_init&lt;/code> 和 &lt;code>__asan_version_mismatch_check_v8&lt;/code> 的调用。&lt;/p>
&lt;p>需要注意的是 &lt;code>.init_array.1 section&lt;/code>，存储了函数 &lt;code>asan.module_ctor&lt;/code> 的指针。&lt;code>.init_array.1&lt;/code> 中的 &lt;strong>&amp;quot;.1&amp;quot;&lt;/strong> 和 &lt;code>asan.module_ctor&lt;/code> 的 priority 有关，因为 &lt;code>{ i32 **1**, void ()* @asan.module_ctor, i8* null }&lt;/code> 即 &lt;code>asan.module_ctor&lt;/code> 的 priority 是 1，所以这里就是 &lt;code>.init_array.1&lt;/code>&lt;/p>
&lt;p>关于 &lt;code>.init_array&lt;/code>，maskray 的这篇文章写的很详细 &lt;a href="https://maskray.me/blog/2021-11-07-init-ctors-init-array">https://maskray.me/blog/2021-11-07-init-ctors-init-array&lt;/a> 。&lt;/p>
&lt;p>在 ELF 文件被 loader 加载后，会先执行 .init_array section 中的函数，再执行 main 函数。这样就达到了在程序启动之前执行 sanitizer runtime 初始化函数的效果。&lt;/p>
&lt;p>&lt;img src="https://enna1.github.io/blog/sanitizer-runtime-init/2022-08-17-20-05-31-image.png" alt="">&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>总结一下，sanitizer runtime 是如何做到在程序启动之前进行初始化的，以 ASan 为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先 sanitizer runtime library 中存在一个初始化函数 &lt;code>__asan_init&lt;/code>，来做 ASan runtime 的初始化工作，如：初始化 shadow memory、初始化一些运行时参数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后在开启 ASan ，编译时插装这个阶段，会创建一个名为 &lt;code>asan.module_ctor&lt;/code> 的函数，该函数会调用 &lt;code>__asan_init&lt;/code>，然后将 &lt;code>asan.module_ctor&lt;/code> 的函数指针加入到 &lt;code>@llvm.global_ctors&lt;/code> 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在生成汇编代码时，会将 &lt;code>@llvm.global_ctors&lt;/code> 中的函数指针放在 &lt;code>.init_array&lt;/code> section 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后在 loader 加载 ELF 文件时，会先执行 &lt;code>.init_array&lt;/code> 中函数指针指向的函数，然后再执行 &lt;code>main()&lt;/code> 函数，这样就做到在程序启动之前初始化 ASan runtime 了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="ps">P.S.&lt;/h2>
&lt;p>C/C++ 面试有一个常见问题就是问如何实现在 &lt;code>main()&lt;/code> 函数执行之前，执行一条语句： &lt;a href="https://www.zhihu.com/question/26031933">https://www.zhihu.com/question/26031933&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一种解决方案是通过 &lt;code>__attribute((constructor))&lt;/code> 来修饰相关函数，实现该函数在 &lt;code>main()&lt;/code> 函数执行之前被执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还有一种方案是利用全局变量的构造函数在 &lt;code>main()&lt;/code> 函数执行之前执行实现该效果。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>实际上述两种方案在汇编的角度来看是一样的，都是通过 &lt;code>.init_array&lt;/code> section 来实现的。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://maskray.me/blog/2021-11-07-init-ctors-init-array">https://maskray.me/blog/2021-11-07-init-ctors-init-array&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>How To Write A Dumb Sanitizer</title><link>https://enna1.github.io/post/dumb-sanitizer-howto/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://enna1.github.io/post/dumb-sanitizer-howto/</guid><description>&lt;p>本文描述了如何实现一个简单的 sanitizer 。&lt;/p>
&lt;p>本文所实现的 DumbSanitizer 的完整代码见 &lt;a href="https://gist.github.com/Enna1/f8696072bd9dc36ac236ba63839b7c16">DumbSanitizer.patch · GitHub&lt;/a>，基于 llvm 14.0.4。&lt;/p>
&lt;h2 id="introduction--what-is-a-sanitizer">Introduction — What is a sanitizer?&lt;/h2>
&lt;p>Sanitizers 是由 Google 开源的动态代码分析工具，包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>AddressSanitizer (ASan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LeakSanitizer (LSan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ThreadSanitizer (TSan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UndefinedBehaviorSanitizer (UBSsan)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MemorySanitizer (MSan)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>所有的 Sanitizer 都由编译时插桩和运行时库两部分组成，Sanitizer 自 Clang 3.1 和 GCC 4.8 开始被集成在 Clang 和 GCC 中。&lt;/p>
&lt;p>例如 ASan 是用于检测 Use-after-free, heap-buffer-overflow, stack-buffer-overflow 等内存错误的。对于如下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang -O0 -g -fsanitize=address test.cpp &amp;amp;&amp;amp; ./a.out
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> [] array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> array[argc]; &lt;span style="color:#75715e">// BOOM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用命令 &lt;code>clang -O0 -g -fsanitize=address test.cpp&lt;/code> 就可以得到开启 ASan 编译后的产物，然后运行编译产物 a.out 就会得到如下类似输入，说明在运行 a.out 时发现了一个 UAF：&lt;/p>
&lt;pre tabindex="0">&lt;code>=================================================================
==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64 at pc 0x417f6a bp 0x7fff626b3250 sp 0x7fff626b3248
READ of size 4 at 0x603e0001fc64 thread T0
#0 0x417f69 in main test.cpp:5
#1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)
#2 0x417e54 (a.out+0x417e54)
0x603e0001fc64 is located 4 bytes inside of 400-byte region [0x603e0001fc60,0x603e0001fdf0)
freed by thread T0 here:
#0 0x40d4d2 in operator delete[](void*) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:61
#1 0x417f2e in main test.cpp:4
previously allocated by thread T0 here:
#0 0x40d312 in operator new[](unsigned long) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:46
#1 0x417f1e in main test.cpp:3
Shadow bytes around the buggy address:
0x1c07c0003f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=&amp;gt;0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd
0x1c07c0003f90: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x1c07c0003fa0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x1c07c0003fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa
0x1c07c0003fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x1c07c0003fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable: 00
Partially addressable: 01 02 03 04 05 06 07
Heap left redzone: fa
Heap righ redzone: fb
Freed Heap region: fd
Stack left redzone: f1
Stack mid redzone: f2
Stack right redzone: f3
Stack partial redzone: f4
Stack after return: f5
Stack use after scope: f8
Global redzone: f9
Global init order: f6
Poisoned by user: f7
ASan internal: fe
==6254== ABORTING
&lt;/code>&lt;/pre>&lt;h2 id="quick-start--writing-dumb-sanitizer">Quick Start — Writing dumb sanitizer&lt;/h2>
&lt;p>接下来这一节我们就来讲解下怎么实现一个简单的 Sanitizer（本文称之为 DumbSanitizer 或 DbSan）。我们的 DumbSanitizer 实现下述功能：对于程序中的每一个变量，我们都统计该变量在程序运行中被访问了多少次，并且在程序退出时打印出访问次数最多的变量。&lt;/p>
&lt;h3 id="compile-llvm-project-with-compiler-rt">Compile llvm project with compiler-rt&lt;/h3>
&lt;p>如何编译 llvm 可以参考 &lt;a href="https://llvm.org/docs/CMake.html#quick-start">Building LLVM with CMake&lt;/a>，需要注意的是为了使用 Sanitizer 我们需要将 &lt;code>compiler-rt&lt;/code> 加入到 LLVM_ENABLE_PROJECTS 这个 CMake varibale 里。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ git clone -b llvmorg-14.0.4 https://github.com/llvm/llvm-project.git --depth &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd llvm-project
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cmake -DCMAKE_INSTALL_PREFIX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>HOME&lt;span style="color:#e6db74">}&lt;/span>/llvm-bin -DCMAKE_BUILD_TYPE&lt;span style="color:#f92672">=&lt;/span>Release -DLLVM_ENABLE_PROJECTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;clang;compiler-rt&amp;#34;&lt;/span> -DLLVM_TARGETS_TO_BUILD&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;X86&amp;#34;&lt;/span> -DLLVM_ENABLE_DUMP&lt;span style="color:#f92672">=&lt;/span>ON ../llvm-project/llvm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ make -j12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ make install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="implementing-the-instrumentation-pass">Implementing the instrumentation pass&lt;/h3>
&lt;p>我们在本文最开始提到：所有的 Sanitizer 都由编译时插桩和运行时库两部分组成，并且几乎所有的 Sanitizer 的插桩部分都是通过 LLVM pass 的方式实现的。我们的 DumbSanitizer 也不例外。（关于 LLVM pass 的编写，见 &lt;a href="https://llvm.org/docs/WritingAnLLVMPass.html">Writing an LLVM Pass&lt;/a>）&lt;/p>
&lt;p>本节就来说明 DumbSanitizer 的插桩部分是如何实现的。&lt;/p>
&lt;p>这里只对一些关键点进行说明，完整实现见 &lt;a href="https://gist.github.com/Enna1/f8696072bd9dc36ac236ba63839b7c16">DumbSanitizer.patch · GitHub&lt;/a> 中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>llvm-project/llvm/include/llvm/Transforms/Instrumentation/DumbSanitizer.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>llvm-project/llvm/lib/Transforms/Instrumentation/DumbSanitizer.cpp。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>首先说一下，我们实现 “对于程序中的每一个变量，统计该变量在程序运行中被访问了多少次，并且在程序退出时打印出访问次数最多的变量” 该功能的思路：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译时插桩：对于每一次 memory access (load, store)，我们都会在此次 acccess 之前插入一个函数调用 (__dbsan_read, __dbsan_write)，该函数调用是在运行时库中实现的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行时库：维护一个全局 map，该 map 记录了每一个 address 被访问的次数。函数 __dbsan_read, __db_write 的实现就是去更新该 map 中 key 为本次访问变量的 address 所对应的 value 的值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>即，程序使用 DumbSanitizer 编译后，每一次对变量 x 的读/写之前都会先调用 __dbsan_read/__dbsan_write，把变量 x 的地址传过去，__dbsan_read/__dbsan_write 会将 access_count_map[&amp;amp;x]++。在程序退出时根据 access_count_map 的内容就能给出访问次数最多的变量/地址了。&lt;/p>
&lt;p>那么如何实现在每一次 memory access (load, store) 之前都插入一个函数调用 (__dbsan_read, __dbsan_write) 呢？核心代码其实非常简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>SmallVector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Instruction &lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> LoadsAndStores;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>BB : F) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>Inst : BB) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isa&lt;span style="color:#f92672">&amp;lt;&lt;/span>LoadInst&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Inst) &lt;span style="color:#f92672">||&lt;/span> isa&lt;span style="color:#f92672">&amp;lt;&lt;/span>StoreInst&lt;span style="color:#f92672">&amp;gt;&lt;/span>(Inst))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LoadsAndStores.push_back(&lt;span style="color:#f92672">&amp;amp;&lt;/span>Inst);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#f92672">*&lt;/span>Inst : LoadsAndStores) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IRBuilder&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> IRB(Inst);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> IsWrite;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Value &lt;span style="color:#f92672">*&lt;/span>Addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (LoadInst &lt;span style="color:#f92672">*&lt;/span>LI &lt;span style="color:#f92672">=&lt;/span> dyn_cast&lt;span style="color:#f92672">&amp;lt;&lt;/span>LoadInst&lt;span style="color:#f92672">&amp;gt;&lt;/span>(I)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IsWrite &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Addr &lt;span style="color:#f92672">=&lt;/span> LI&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getPointerOperand();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span> (StoreInst &lt;span style="color:#f92672">*&lt;/span>SI &lt;span style="color:#f92672">=&lt;/span> dyn_cast&lt;span style="color:#f92672">&amp;lt;&lt;/span>StoreInst&lt;span style="color:#f92672">&amp;gt;&lt;/span>(I)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IsWrite &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Addr &lt;span style="color:#f92672">=&lt;/span> SI&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getPointerOperand();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (IsWrite) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IRB.CreateCall(DbsanWriteFunc, IRB.CreatePointerCast(Addr, IRB.getInt8PtrTy()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IRB.CreateCall(DbsanReadFunc, IRB.CreatePointerCast(Addr, IRB.getInt8PtrTy()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简单解释一下。其实就是遍历 Function F 中的所有指令，收集其中的 LoadInst 和 StoreInst。然后对于每一个保存起来的 LoadInst 或 StoreInst，通过 IRBuilder 在其之前都插入一条 CallInst，被调函数就是 __dbsan_read 或 __dbsan_write。函数 __dbsan_read 或 __dbsan_write 只有一个参数，该参数就是 LoadInst 或 StoreInst 的 PointerOperand，即读写的 address。&lt;/p>
&lt;h3 id="implementing-the-runtime-library">Implementing the runtime library&lt;/h3>
&lt;p>介绍完编译时插桩的关键点后，再来介绍下运行时库的核心实现。&lt;/p>
&lt;p>DumbSanitizer 运行时库部分的核心实现见 &lt;a href="https://gist.github.com/Enna1/f8696072bd9dc36ac236ba63839b7c16">DumbSanitizer.patch · GitHub&lt;/a> 中的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>llvm-project/compiler-rt/lib/dbsan/dbsan_interface.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>llvm-project/compiler-rt/lib/dbsan/dbsan_interface.cpp&lt;/p>
&lt;/li>
&lt;li>
&lt;p>llvm-project/compiler-rt/lib/dbsan/dbsan_rtl.h&lt;/p>
&lt;/li>
&lt;li>
&lt;p>llvm-project/compiler-rt/lib/dbsan/dbsan_rtl.cpp&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>dbsan_interface.h 和 dbsan_interface.cpp 中是对暴露给外部的函数 __dbsan_read 和 __dbsan_write 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__dbsan_read&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr) { MemoryAccess((uptr)addr, kAccessRead); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">__dbsan_write&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>addr) { MemoryAccess((uptr)addr, kAccessWrite); }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到 __dbsan_read 和 __dbsan_write 的实现就是对函数 MemoryAccess 的包装，MemoryAccess 的实现位于 dbsan_rtl.h 和 dbsan_rtl.cpp。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">MemoryAccess&lt;/span>(uptr addr, AccessType typ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>access_count_map[addr]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr access_count &lt;span style="color:#f92672">=&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>access_count_map[addr];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (access_count &lt;span style="color:#f92672">&amp;gt;&lt;/span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>most_frequently_accessed_count) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>most_frequently_accessed_count &lt;span style="color:#f92672">=&lt;/span> access_count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>most_frequently_accessed_addr &lt;span style="color:#f92672">=&lt;/span> addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MemoryAccess 的实现也很简单，就是更新 access_count_map 中 key 为 addr 的 value 值，然后更新访问次数最多的 address。&lt;/p>
&lt;p>这里 ctx 是运行时库中维护的一个 Context 类型的全局变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Context&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> initialized;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr most_frequently_accessed_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uptr most_frequently_accessed_count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __sanitizer&lt;span style="color:#f92672">::&lt;/span>DenseMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>uptr, uptr&lt;span style="color:#f92672">&amp;gt;&lt;/span> access_count_map;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>most_frequently_accessed_addr 用于记录访问次数最多的地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>most_frequently_accessed_count 用于记录最多的访问次数是多少&lt;/p>
&lt;/li>
&lt;li>
&lt;p>access_count_map 则是记录了每一个地址被访问了多少次&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最后讲一下我们是如何做到程序退出时打印访问次数最多的变量的。其实也很简单，就是通过 atexit 来注册程序退出时执行的函数，在该函数中直接打印我们在 Context 中保存的 most_frequently_accessed_addr 和 most_frequently_accessed_count 即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dbsan_atexit&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __sanitizer&lt;span style="color:#f92672">::&lt;/span>Printf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;#Most frequently accessed address: %p, access count: %zd&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>most_frequently_accessed_addr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>most_frequently_accessed_count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="integrating-the-sanitizer">Integrating the sanitizer&lt;/h3>
&lt;p>实现完 DumbSanitizer 的编译时插桩和运行时库这两个核心部分，剩下的就是将我们的 DumbSanitizer 集成在 clang/llvm 的编译流程中，使得能够通过编译选项 -fsanitize=dumb 来启用 DumbSanitizer。&lt;/p>
&lt;p>这部分修改的文件多且杂，没有什么需要特别说明的地方。这里只给出所需要修改的文件，详见 &lt;a href="https://gist.github.com/Enna1/f8696072bd9dc36ac236ba63839b7c16">DumbSanitizer.patch · GitHub&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>llvm-project/clang/include/clang/Basic/Sanitizers.def，添加 DumbSanitizer 的定义&lt;/p>
&lt;/li>
&lt;li>
&lt;p>llvm-project/clang/include/clang/Driver/SanitizerArgs.h，添加是否启用的 DumbSanitizer 的判断&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 llvm-project/clang/lib/CodeGen/BackendUtil.cpp，将 DumbSanitizer 的插桩 pass 添加至 pass manager&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp，如果启用了 DumbSanitizer，则链接 DumbSanitizer 的运行时库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改 llvm-project/clang/lib/Driver/ToolChains/Linux.cpp，定义 DumbSanitizer 所支持的架构，简单起见我们 DumbSanitizer 只支持 X86_64&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="running-the-dumb-sanitizer">Running the dumb sanitizer&lt;/h3>
&lt;p>本节我们用一个例子来跑下 DumbSanitizer ，看看效果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// clang++ -fsanitize=dumb test.cpp -o test
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBSAN_OPTIONS=&amp;#39;print_frequent_access=1&amp;#39; ./test
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;address of `r` is %p&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>r);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;address of `i` is %p&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里我们在优化等级为 O0 的情况下，开启 DumbSanitizer（注：DumbSanitizer 是在所有的优化 pass 执行后，才执行插桩 pass，即 DumbSanitizer 插桩的是已经优化后的代码，可以尝试改变优化等级查看上述例子程序的输出）。&lt;/p>
&lt;p>在执行编译后的二进制时，我们设置了环境变量 DBSAN_OPTIONS，通过 DBSAN_OPTIONS 中的参数 print_frequent_access 为 1 还是 0 来控制在程序退出时是否打印访问次数最多的变量地址是什么。&lt;/p>
&lt;p>上述例子的运行结果如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>address of `r` is 0x7fff5817396c
address of `i` is 0x7fff58173968
#Most frequently accessed address: 0x7fff58173968, access count: 6
&lt;/code>&lt;/pre>&lt;p>可以看出被访问次数最多的变量是 i，被访问了的 6 次。&lt;/p>
&lt;p>感兴趣可以通过 LLVM IR 来分析这是为什么，这里就不再赘述了。&lt;/p>
&lt;pre tabindex="0">&lt;code>define dso_local noundef i32 @main(i32 noundef %0, i8** noundef %1) #0 {
%3 = alloca i32, align 4
%4 = alloca i32, align 4
%5 = alloca i8**, align 8
%6 = alloca i32, align 4 ; address of r
%7 = alloca i32, align 4 ; address of i
%8 = bitcast i32* %3 to i8*
call void @__dbsan_write4(i8* %8)
store i32 0, i32* %3, align 4
%9 = bitcast i32* %4 to i8*
call void @__dbsan_write4(i8* %9)
store i32 %0, i32* %4, align 4
%10 = bitcast i8*** %5 to i8*
call void @__dbsan_write8(i8* %10)
store i8** %1, i8*** %5, align 8
%11 = bitcast i32* %6 to i8*
call void @__dbsan_write4(i8* %11) ; r = 0
store i32 0, i32* %6, align 4
%12 = bitcast i32* %7 to i8*
call void @__dbsan_write4(i8* %12) ; i = 1
store i32 1, i32* %7, align 4
%13 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i64 0, i64 0), i32* noundef %6)
%14 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([22 x i8], [22 x i8]* @.str.1, i64 0, i64 0), i32* noundef %7)
br label %15
15: ; preds = %24, %2
%16 = bitcast i32* %7 to i8*
call void @__dbsan_read4(i8* %16); i &amp;lt; 2
%17 = load i32, i32* %7, align 4
%18 = icmp slt i32 %17, 2
br i1 %18, label %19, label %29
19: ; preds = %15
%20 = bitcast i32* %6 to i8*
call void @__dbsan_read4(i8* %20) ; r&amp;#39; = r (part1 of r++)
%21 = load i32, i32* %6, align 4
%22 = add nsw i32 %21, 1
%23 = bitcast i32* %6 to i8*
call void @__dbsan_write4(i8* %23) ; r = r&amp;#39; + 1 (part2 of r++)
store i32 %22, i32* %6, align 4
br label %24
24: ; preds = %19
%25 = bitcast i32* %7 to i8*
call void @__dbsan_read4(i8* %25) ; i&amp;#39; = i (part1 of ++i)
%26 = load i32, i32* %7, align 4
%27 = add nsw i32 %26, 1
%28 = bitcast i32* %7 to i8*
call void @__dbsan_write4(i8* %28) ; i = i&amp;#39; + 1 (part2 of ++i)
store i32 %27, i32* %7, align 4
br label %15, !llvm.loop !4
29: ; preds = %15
%30 = bitcast i32* %7 to i8*
call void @__dbsan_read4(i8* %30) ; i&amp;#39; = i (part1 of i + r)
%31 = load i32, i32* %7, align 4
%32 = bitcast i32* %6 to i8*
call void @__dbsan_read4(i8* %32) ; r&amp;#39; = r (part2 of i + r)
%33 = load i32, i32* %6, align 4
%34 = add nsw i32 %31, %33 ; i&amp;#39; + r&amp;#39; (part 3 of i + r)
ret i32 %34
}
&lt;/code>&lt;/pre>&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://github.com/google/sanitizers">GitHub - google/sanitizers: AddressSanitizer, ThreadSanitizer, MemorySanitizer&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/trailofbits/llvm-sanitizer-tutorial">GitHub - trailofbits/llvm-sanitizer-tutorial: An LLVM sanitizer tutorial&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol></description></item></channel></rss>