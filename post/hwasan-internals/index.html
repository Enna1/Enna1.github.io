<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>HWASAN Internals - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="HWASAN Internals"><meta property="og:description" content="本文深入分析了 HWASAN (HardWare-assisted AddressSanitizer) 检测内存错误的原理。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/hwasan-internals/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-12T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/random/><span class=menu__text>random</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>HWASAN Internals</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-04-12T00:00:00Z>April 12, 2023</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#算法>算法</a></li><li><a href=#实现>实现</a><ul><li><a href=#shadow-mapping>shadow mapping</a></li><li><a href=#tagging>tagging</a></li><li><a href=#short-granules>short granules</a></li><li><a href=#hwasan-check-memaccess>hwasan check memaccess</a></li></ul></li><li><a href=#参考链接>参考链接</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>本文深入分析了 HWASAN (HardWare-assisted AddressSanitizer) 检测内存错误的原理。</p><h2 id=概述>概述</h2><p><strong>HWASAN</strong>: <strong>H</strong>ard<strong>W</strong>are-assisted <strong>A</strong>ddress<strong>San</strong>itizer, a tool similar to AddressSanitizer, but based on partial hardware assistance and consumes much less memory.</p><p>这里所谓的 &ldquo;partial hardware assistance&rdquo; 就是指 AArch64 的 <strong>TBI</strong> (Top Byte Ignore) 特性。</p><blockquote><p>TBI (Top Byte Ignore) feature of AArch64: bits [63:56] are ignored in address translation and can be used to store a tag.</p></blockquote><p>以如下代码举例，Linux/AArch64 下将指针 x 的 top byte 设置为 0xfe，不影响程序执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// $ cat tbi.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>volatile</span> x <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>666</span>;
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;address: %p, value: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x, <span style=color:#f92672>*</span>x);
</span></span><span style=display:flex><span>  x <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(<span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>uintptr_t<span style=color:#f92672>&gt;</span>(x) <span style=color:#f92672>|</span> (<span style=color:#ae81ff>0xfeULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>56</span>));
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;address: %p, value: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x, <span style=color:#f92672>*</span>x);
</span></span><span style=display:flex><span>  free(x);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// $ clang++ tbi.cpp &amp;&amp; ./a.out
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>address: <span style=color:#ae81ff>0xaaab1845fe70</span>, value: <span style=color:#ae81ff>666</span>
</span></span><span style=display:flex><span>address: <span style=color:#ae81ff>0xfe00aaab1845fe70</span>, value: <span style=color:#ae81ff>666</span>
</span></span></code></pre></div><p>AArch64 的 TBI 特性使得软件可以在 64-bit 虚拟地址的最高字节中存储任意数据，HWASAN 正是基于 TBI 这一特性设计并实现的内存错误检测工具。</p><p>举个例子，以下代码中存在 heap-buffer-overflow bug：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// cat test.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>volatile</span> x <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    x[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    free(x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 HWASAN 检测上述代码中的 heap-buffer-overflow bug：</p><pre tabindex=0><code>$ clang -fuse-ld=lld -g -fsanitize=hwaddress ./test.c &amp;&amp; ./a.out
==3581920==ERROR: HWAddressSanitizer: tag-mismatch on address 0xec2bfffe0028 at pc 0xaaad830db1a4
WRITE of size 4 at 0xec2bfffe0028 tags: 69/08(69) (ptr/mem) in thread T0
    #0 0xaaad830db1a4 in main ./test.c:4:11
    #1 0xfffd07350da0 in __libc_start_main libc-start.c:308:16
    #2 0xaaad83090820 in _start (./a.out+0x40820)

[0xec2bfffe0000,0xec2bfffe0030) is a small allocated heap chunk; size: 48 offset: 40

Cause: heap-buffer-overflow
0xec2bfffe0028 is located 0 bytes after a 40-byte region [0xec2bfffe0000,0xec2bfffe0028)
allocated by thread T0 here:
    #0 0xaaad83099248 in __sanitizer_malloc.part.13 llvm-project/compiler-rt/lib/hwasan/hwasan_allocation_functions.cpp:151:3
    #1 0xaaad830db17c in main ./test.c:3:31
    #2 0xfffd07350da0 in __libc_start_main libc-start.c:308:16
    #3 0xaaad83090820 in _start (/a.out+0x40820)

Thread: T0 0xeffc00002000 stack: [0xffffc3a10000,0xffffc4210000) sz: 8388608 tls: [0xfffd076a5030,0xfffd076a5e70)
Memory tags around the buggy address (one tag corresponds to 16 bytes):
  0xec2bfffdf800: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdf900: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdfa00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdfb00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdfc00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdfd00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdfe00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffdff00: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
=&gt;0xec2bfffe0000: 69  69 [08] 00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0100: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0200: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0300: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0400: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0500: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0600: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0700: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
  0xec2bfffe0800: 00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
Tags for short granules around the buggy address (one tag corresponds to 16 bytes):
  0xec2bfffdff00: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
=&gt;0xec2bfffe0000: ..  .. [69] ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
  0xec2bfffe0100: ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
See https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html#short-granules for a description of short granule tags
Registers where the failure occurred (pc 0xaaad830db1a4):
    x0  a100ffffc4201580  x1  6900ec2bfffe0028  x2  0000000000000000  x3  0000000000000000
    x4  0000000000000020  x5  0000000000000000  x6  0000000000100000  x7  fffffffffff00005
    x8  6900ec2bfffe0000  x9  6900ec2bfffe0000  x10 0030f15d14c79f97  x11 00ffffffffffffff
    x12 00001f0d780b69d2  x13 0000000000000001  x14 0000ffffc4200b60  x15 0000000000000696
    x16 0000aaad830a3540  x17 000000000000000b  x18 0000000000000100  x19 0000aaad830db600
    x20 0200effd00000000  x21 0000aaad830907f0  x22 0000000000000000  x23 0000000000000000
    x24 0000000000000000  x25 0000000000000000  x26 0000000000000000  x27 0000000000000000
    x28 0000000000000000  x29 0000ffffc4201590  x30 0000aaad830db1a8   sp 0000ffffc4201550
SUMMARY: HWAddressSanitizer: tag-mismatch ./test.c:4:11 in main
</code></pre><p>如上所示，HWASAN 与 ASAN 相比不管是用法 (<code>-fsanitize=hwaddress</code> v.s. <code>-fsanitize=address</code>) 还是检测到错误后的报告都很相似。</p><p>下面对比分析 ASAN 与 HWASAN 检测内存错误的技术原理：</p><p>ASAN (AddressSanitizer)：</p><ul><li><p>使用 shadow memory 技术，每 8-bytes 的 application memory 对应 1-byte 的 shadow memory。</p></li><li><p>使用 redzone 来检测 buffer-overflow。不管是栈内存还是堆内存，在申请内存时都会在原本内存的两侧额外申请一定大小的内存作为 redzone，一旦访问到了 redzone 则说明发生了缓冲区溢出。</p></li><li><p>使用 quarantine 检测 use-after-free。应用程序执行 delete 或 free 释放内存时，并不真正释放，而是放在一个暂存区 (quarantine) 中，一旦访问了位于 quarantine 中的内存则说明访问了已释放的内存。</p></li><li><p>每 1-byte 的 shadow memory 编码表示对应的 8-byte application memory 的信息，每次访问 application memory 之前 ASAN 都会检查对应的 shadow memory 判断本次内存访问是否合法。例如：shadow memory 的值为 0xfd 表示对应的 8-bytes application memory 是 freed memory，所以当访问的 application memory 其 shadow memory byte 为 0xfd 就说明此时访问的是已经释放的内存了即 use-after-free；shadow memory 为 0xfa 表示相应的 application memory 是堆内存的 redzone，所以当访问到的 appllcation memory 其 shadow memory 为 0xfa 就说明此时访问的是堆内存附近的 redzone 发生了堆缓冲区溢出错误即 heap-buffer-overflow</p></li></ul><p>HWASAN (HardWare-assisted AddressSanitizer)</p><ul><li><p>同样使用 shadow memory 技术，不过与 ASAN 不同的是：HWASAN 每 16-bytes 的 application memory 对应 1-byte 的 shadow memory。</p></li><li><p>不依赖 redzone 检测 buffer-overflow，不依赖 quarantine 检测 use-after-free，仅基于 TBI 特性就能检测 buffer-overflow 和 use-after-free。</p></li><li><p>举例说明 HWASAN 检测内存错误的原理</p><p>因为 HWASAN 会将每 16-bytes 的 application memory 都对应 1-byte 的 shadow tag，所以 HWASAN 会将申请的内存都对齐到 16-bytes，因此下图中 new char[20] 实际申请的内存是 32-bytes。</p><p>HWASAN 会生成一个随机 tag 保存在 operator new 返回的指针 p 的 top byte 中，同时会将 tag 保存在 p 指向的内存对应 shadow memory 中。</p><p>为了方便说明，下图中用不同的颜色表示不同的 tag，绿色表示 tag 0xa，蓝色表示 tag 0xb，紫色表示 tag 0xc。</p><ul><li><p>检测 heap-buffer-overflow</p><p>假设 HWASAN 为 <code>new char[20]</code> 生成的 tag 为 0xa 即绿色，所以指针 p 的 top byte 为 0xa。在通过 <code>p[32]</code> 访问内存时，HWASAN 会检查保存在指针 p 的 tag 与 <code>p[32]</code> 指向的内存所对应的 shadow memory 中保存的 tag 是否一致。显然保存在指针 p 的 tag 是绿色 而<code>p[32]</code> 指向的内存所对应的 shadow memory 中保存的 tag 是蓝色，即 tag 是不匹配的，这说明访问 <code>p[32]</code> 时存在内存错误。</p><p><img src=/blog/hwasan-internals/2023-04-08-18-31-23-image.PNG alt></p></li><li><p>检测 use-after-free</p><p>假设 HWASAN 为 <code>new char[20]</code> 生成的 tag 为 0xa 即绿色，所以指针 p 的 top byte 为 0xa。执行 <code>delete[] p</code> 释放内存时，HWASAN 将这块释放的内存 retag 为紫色，即将这块释放的内存对应的 shadow memory 从绿色修改为紫色。在通过 <code>p[0]</code> 访问内存时，HWASAN 会检查保存在指针 p 的 tag 与 <code>p[0]</code> 指向的内存所对应的 shadow memory 中保存的 tag 是否一致。显然保存在指针 p 的 tag 是绿色 而<code>p[0]</code> 指向的内存所对应的 shadow memory 中保存的 tag 是紫色，即 tag 是不匹配的，这说明访问 <code>p[0]</code> 时存在内存错误。</p><p><img src=/blog/hwasan-internals/2023-04-08-18-30-56-image.png alt></p></li></ul></li></ul><h2 id=算法>算法</h2><ul><li><p>shadow memory：每 16-bytes 的 application memory 对应 1-byte 的 shadow memory。</p></li><li><p>每个 heap/stack/global 内存对象都被对齐到 16-bytes，这样每个 heap/stack/global 内存对象至少对应的 1-byte shadow memory。</p></li><li><p>为每一个 heap/stack/global 内存对象生成一个 1-byte 的随机 tag，将该随机 tag 保存到指向这些内存对象的指针的 top byte 中，同样将该随机 tag 保存到这些内存对象对应的 shadow memory 中。</p></li><li><p>在每一处内存读写之前插桩：比较保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 是否一致，如果不一致则报错。</p></li></ul><h2 id=实现>实现</h2><h3 id=shadow-mapping>shadow mapping</h3><p>HWASAN 与 ASAN 一样都使用了 shadow memory 技术。ASAN 默认使用 static shadow mapping，只有对 IOS 和 32-bit Android 平台才使用 dynamic shadow mapping。而 HWASAN 则总是使用 dynamic shadow mapping。</p><ul><li><p>ASAN: static shadow mapping。在 llvm-project/compiler-rt/lib/asan/asan_mapping.h 中预定义了不同平台下 shadow memory 的布局：HighMem, HighShadow, ShadowGap, LowShadow, LowMem 的地址区间。</p><p>Linux/x86_64 下 ASAN 的 shadow mapping 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>||</span> <span style=color:#960050;background-color:#1e0010>`</span>[<span style=color:#ae81ff>0x10007fff8000</span>, <span style=color:#ae81ff>0x7fffffffffff</span>]<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>||</span> HighMem    <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> <span style=color:#960050;background-color:#1e0010>`</span>[<span style=color:#ae81ff>0x02008fff7000</span>, <span style=color:#ae81ff>0x10007fff7fff</span>]<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>||</span> HighShadow <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> <span style=color:#960050;background-color:#1e0010>`</span>[<span style=color:#ae81ff>0x00008fff7000</span>, <span style=color:#ae81ff>0x02008fff6fff</span>]<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>||</span> ShadowGap  <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> <span style=color:#960050;background-color:#1e0010>`</span>[<span style=color:#ae81ff>0x00007fff8000</span>, <span style=color:#ae81ff>0x00008fff6fff</span>]<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>||</span> LowShadow  <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> <span style=color:#960050;background-color:#1e0010>`</span>[<span style=color:#ae81ff>0x000000000000</span>, <span style=color:#ae81ff>0x00007fff7fff</span>]<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>||</span> LowMem     <span style=color:#f92672>||</span>
</span></span></code></pre></div><p>给定 application memory 地址 <code>addr</code>，计算其对应的 shadow memory 地址的公式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>uptr <span style=color:#a6e22e>MemToShadow</span>(uptr addr) { <span style=color:#66d9ef>return</span> (addr <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x7fff8000</span>; }
</span></span></code></pre></div></li><li><p>HWASAN: dynamic shadow mapping。根据 MaxUserVirtualAddress 计算 shadow memory 所需要的总大小 shadow_size，通过 mmap(shadow_size) 得到 shadow memory 区间，再具体划分 HighMem, HighShadow, ShadowGap, LowShadow, LowMem 的地址区间。</p><p>伪算法如下（未考虑对齐）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>kHighMemEnd <span style=color:#f92672>=</span> GetMaxUserVirtualAddress();
</span></span><span style=display:flex><span>shadow_size <span style=color:#f92672>=</span> MemToShadowSize(kHighMemEnd);
</span></span><span style=display:flex><span>__hwasan_shadow_memory_dynamic_address <span style=color:#f92672>=</span> mmap(shadow_size);
</span></span><span style=display:flex><span><span style=color:#75715e>// Place the low memory first.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>kLowMemEnd <span style=color:#f92672>=</span> __hwasan_shadow_memory_dynamic_address <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>kLowMemStart <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// Define the low shadow based on the already placed low memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>kLowShadowEnd <span style=color:#f92672>=</span> MemToShadow(kLowMemEnd);
</span></span><span style=display:flex><span>kLowShadowStart <span style=color:#f92672>=</span> __hwasan_shadow_memory_dynamic_address;
</span></span><span style=display:flex><span><span style=color:#75715e>// High shadow takes whatever memory is left up there.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>kHighShadowEnd <span style=color:#f92672>=</span> MemToShadow(kHighMemEnd);
</span></span><span style=display:flex><span>kHighShadowStart <span style=color:#f92672>=</span> Max(kLowMemEnd, MemToShadow(kHighShadowEnd)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// High memory starts where allocated shadow allows.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>kHighMemStart <span style=color:#f92672>=</span> ShadowToMem(kHighShadowStart);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>uptr <span style=color:#a6e22e>MemToShadow</span>(uptr untagged_addr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (untagged_addr <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>+</span> __hwasan_shadow_memory_dynamic_address;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>uptr <span style=color:#a6e22e>ShadowToMem</span>(uptr shadow_addr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (shadow_addr <span style=color:#f92672>-</span> __hwasan_shadow_memory_dynamic_address) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Linux/AArch64 下 HWASAN 的某种 shadow mapping 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Typical mapping on Linux/AArch64
</span></span></span><span style=display:flex><span><span style=color:#75715e>// with dynamic shadow mapped: [0xefff00000000, 0xffff00000000]:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>||</span> [<span style=color:#ae81ff>0xffff00000000</span>, <span style=color:#ae81ff>0xffffffffffff</span>] <span style=color:#f92672>||</span> HighMem <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> [<span style=color:#ae81ff>0xfffef0000000</span>, <span style=color:#ae81ff>0xfffeffffffff</span>] <span style=color:#f92672>||</span> HighShadow <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> [<span style=color:#ae81ff>0xfefef0000000</span>, <span style=color:#ae81ff>0xfffeefffffff</span>] <span style=color:#f92672>||</span> ShadowGap <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> [<span style=color:#ae81ff>0xefff00000000</span>, <span style=color:#ae81ff>0xfefeefffffff</span>] <span style=color:#f92672>||</span> LowShadow <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span><span style=color:#f92672>||</span> [<span style=color:#ae81ff>0x000000000000</span>, <span style=color:#ae81ff>0xeffeffffffff</span>] <span style=color:#f92672>||</span> LowMem <span style=color:#f92672>||</span>
</span></span></code></pre></div></li></ul><h3 id=tagging>tagging</h3><ul><li><p>stack 内存对象：在编译时插桩阶段，HWASAN 会插入代码来实现对 stack 内存对象的 tagging，将生成的随机 tag 保存在 stack 内存对象指针的 top byte，同时将随机 tag 保存这些 stack 内存对象对应的 shadow memory 中。</p><p>每个 stack 内存对象的 tag 是通过 <code>stack_base_tag ^ RetagMask(AllocaNo)</code> 计算得到的。<code>stack_base_tag</code> 对于不同的 stack frame 是不同的值，<code>RetagMask(AllocaNo)</code> 的实现如下（AllocaNo 可以看作是 stack 内存对象的序号）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#a6e22e>RetagMask</span>(<span style=color:#66d9ef>unsigned</span> AllocaNo) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// A list of 8-bit numbers that have at most one run of non-zero bits.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// x = x ^ (mask &lt;&lt; 56) can be encoded as a single armv8 instruction for these
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// masks.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// The list does not include the value 255, which is used for UAR.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Because we are more likely to use earlier elements of this list than later
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// ones, it is sorted in increasing order of probability of collision with a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// mask allocated (temporally) nearby. The program that generated this list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// can be found at:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>unsigned</span> FastMasks[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>,  <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>64</span>,  <span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>32</span>,  <span style=color:#ae81ff>96</span>,  <span style=color:#ae81ff>224</span>, <span style=color:#ae81ff>112</span>, <span style=color:#ae81ff>240</span>,
</span></span><span style=display:flex><span>                                 <span style=color:#ae81ff>48</span>, <span style=color:#ae81ff>16</span>,  <span style=color:#ae81ff>120</span>, <span style=color:#ae81ff>248</span>, <span style=color:#ae81ff>56</span>,  <span style=color:#ae81ff>24</span>,  <span style=color:#ae81ff>8</span>,   <span style=color:#ae81ff>124</span>, <span style=color:#ae81ff>252</span>,
</span></span><span style=display:flex><span>                                 <span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>28</span>,  <span style=color:#ae81ff>12</span>,  <span style=color:#ae81ff>4</span>,   <span style=color:#ae81ff>126</span>, <span style=color:#ae81ff>254</span>, <span style=color:#ae81ff>62</span>,  <span style=color:#ae81ff>30</span>,  <span style=color:#ae81ff>14</span>,
</span></span><span style=display:flex><span>                                 <span style=color:#ae81ff>6</span>,  <span style=color:#ae81ff>2</span>,   <span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>63</span>,  <span style=color:#ae81ff>31</span>,  <span style=color:#ae81ff>15</span>,  <span style=color:#ae81ff>7</span>,   <span style=color:#ae81ff>3</span>,   <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> FastMasks[AllocaNo <span style=color:#f92672>%</span> std<span style=color:#f92672>::</span>size(FastMasks)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>heap 内存对象：随机 tag 是在运行时申请 heap 内存对象时由 HWASAN 的内存分配器生成的。</p><p>当程序调用 malloc 或者 operator new 申请内存时，HWASAN 的内存分配器会将随机生成的 tag 保存在 malloc 或者 operator new 返回的指针的 top byte 中，同时将随机 tag 保存在这些 heap 内存对象对应的 shadow memory 中。</p><p>当程序调用 free 或者 operator delete 释放内存时，HWASAN 的内存分配器会再次随机生成 tag ，将新生成的随机 tag 保存在正释放的 heap 内存对象对应的 shadow memory 中。</p></li><li><p>global 内存对象：对于每个编译单元内的 global 内存对象，在编译时插桩阶段都会生成对应的 tag，编译单元内的第一个 global 内存对象的 tag 是对当前编译单元文件路径计算 MD5 哈希值然后取第一个字节得到的，编译单元内的后续 global 内存对象的 tag 是基于之前 global 内存对象的 tag 递增得到的。</p><p>在编译时插桩阶段 HWASAN 会插入代码来将生成的随机 tag 保存在 global 内存对象指针的 top byte，而将随机 tag 保存到这些 global 内存对象对应的 shadow memory 中则是由 HWASAN runtime 在程序启动阶段做的。对于每一个 global 内存对象，HWASAN 在编译插桩阶段都会创建一个 descriptor 保存在 &ldquo;hwasan_globals&rdquo; section 中，descriptor 中保存了 global 内存对象的大小以及 tag 等信息，程序启动时 HWASAN runtime 会遍历 &ldquo;hwasan_globals&rdquo; section 中所有的 descriptor 来设置每个 global 内存对象对应的 shadow memory tag。</p></li></ul><h3 id=short-granules>short granules</h3><p>每个 heap/stack/global 内存对象都会被对齐到 16-bytes，heap/stack/global 内存对象原本大小记作 size，如果 <code>size % 16 != 0</code>，那么就需要 padding，heap/stack/global 内存对象最后不足 16-bytes 的部分就被称为 short granule。此时会将 tag 存储到 padding 的最后一个字节，而 padding 所在的 16-bytes 内存对应的 1-byte shadow memory 中存储的则是 short granule size 即 <code>size % 16</code>。</p><p>举例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> buf[<span style=color:#ae81ff>20</span>];
</span></span></code></pre></div><p><code>uint8_t buf[20]</code> 开启 HWASAN 后会变为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> buf[<span style=color:#ae81ff>32</span>]; <span style=color:#75715e>// 20-bytes aligned to 16-bytes -&gt; 32-bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>uint8_t</span> tag <span style=color:#f92672>=</span> __hwasan_generate_tag();
</span></span><span style=display:flex><span>buf[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>=</span> tag;
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)MemToShadow(buf) <span style=color:#f92672>=</span> tag;
</span></span><span style=display:flex><span><span style=color:#f92672>*</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)MemToShadow(buf)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>tagged_buf <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int8_t</span> <span style=color:#f92672>*&gt;</span>(
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>uintptr_t<span style=color:#f92672>&gt;</span>(buf) <span style=color:#f92672>|</span> (tag <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>56</span>));
</span></span><span style=display:flex><span><span style=color:#75715e>// Replace all uses of `buf` with `tagged_buf`
</span></span></span></code></pre></div><p><code>uint_t buf[20]</code> 的最后 4-bytes 就是 short granule，short granule size 即 20 % 16 = 4。</p><p>因为 short granules 的存在，所以在比较保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 是否一致时，需要考虑如下两种可能：</p><ol><li><p>保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 相同。</p></li><li><p>保存在 shadow memory 中的 tag 实际上是 short granule size，保存在指针 top byte 的 tag 等于保存在指针指向的内存所在的 16-bytes 内存的最后一个字节的 tag。</p></li></ol><p><img src=/blog/hwasan-internals/2023-04-12-10-32-16-image.png alt></p><p>为什么需要 short granules ？</p><p>考虑 <code>uint8_t buf[20]</code>，假设代码中存在访问 <code>buf[22]</code> 导致的 buffer-overflow。因为 HWASAN 会将 heap/stack/global 内存对象对齐到 16-bytes，所以实际为 <code>uint8_t buf[20]</code> 申请的空间是 <code>uint8_t buf[32]</code>。</p><p>如果没有 short granules，那么保存在 <code>buf</code> 指针 top byte 的 tag 为 0xa1，保存在 <code>buf[22]</code> 对应的 shadow memory 中的 tag 为 0xa1，尽管访问 <code>buf[22]</code> 时发生了 buffer-overflow，此时 HWASAN 也检测不到，因为保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 是否一致的。</p><p>有了 short granules，保存在 <code>buf</code> 指针 top byte 的 tag 为 0xa1，保存在 <code>buf[22]</code> 对应的 shadow memory 中的 tag 则是 short granule size 即 20 % 16 = 4。访问 <code>buf[22]</code> 时，HWASAN 发现保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 不一致，保存在 <code>buf[22]</code> 对应的 shadow memory 中的 tag 是 short granule size 为 4，这意味着 <code>buf[22]</code> 所在的 16-bytes 内存只有前 4-bytes 是可以合法访问的，而 <code>buf[22]</code> 访问的却是其所在 16-bytes 内存的第 7 个 byte，说明访问 <code>buf[22]</code> 时发生了 buffer-overflow！</p><h3 id=hwasan-check-memaccess>hwasan check memaccess</h3><p>本节说明 HWASAN 如何在每一处内存读写之前通过插桩来比较保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 是否一致的。</p><p>开启 HWASAN 后，HWAddressSanitizer instrumentation pass 会在 LLVM IR 层面进行插桩。默认情况下，HWASAN 在每一处内存读写之前添加对 <code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 的调用。该 <code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 会在生成汇编代码时转换为对相应函数的调用。</p><p>还是以如下代码为例说明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// cat test.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>volatile</span> x <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    x[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    free(x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码 <code>clang -O1 -fsanitize=hwaddress test.c -S -emit-llvm</code> 开启 HWASAN 生成的 LLVM IR 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span>%5 = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>%6 = <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>noalias</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @malloc(<span style=color:#66d9ef>i64</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> <span style=color:#ae81ff>40</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>store</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %6, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>%7 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>%8 = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>inbounds</span> <span style=color:#66d9ef>i32</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %7, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @llvm.hwasan.check.memaccess.shortgranules(<span style=color:#960050;background-color:#1e0010>ptr</span> %__hwasan_shadow_memory_dynamic_address, <span style=color:#960050;background-color:#1e0010>ptr</span> %8, <span style=color:#66d9ef>i32</span> <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>store</span> <span style=color:#66d9ef>i8</span> <span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %8, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>%9 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @free(<span style=color:#960050;background-color:#1e0010>ptr</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> %9)
</span></span></code></pre></div><p><code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 有三个参数：</p><ol><li><p>__hwasan_shadow_memory_dynamic_address</p></li><li><p>本次 memory access 访问的内存地址</p></li><li><p>常数 AccessInfo，编码了本次 memory access 的相关信息。计算公式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int64_t</span> HWAddressSanitizer<span style=color:#f92672>::</span>getAccessInfo(<span style=color:#66d9ef>bool</span> IsWrite,
</span></span><span style=display:flex><span>                                          <span style=color:#66d9ef>unsigned</span> AccessSizeIndex) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (CompileKernel <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>CompileKernelShift) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>         (MatchAllTag.has_value() <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>HasMatchAllShift) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>         (MatchAllTag.value_or(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>MatchAllShift) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>         (Recover <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>RecoverShift) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>         (IsWrite <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>IsWriteShift) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>         (AccessSizeIndex <span style=color:#f92672>&lt;&lt;</span> HWASanAccessInfo<span style=color:#f92672>::</span>AccessSizeShift);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Bit field positions for the accessinfo parameter to
</span></span></span><span style=display:flex><span><span style=color:#75715e>// llvm.hwasan.check.memaccess. Shared between the pass and the backend. Bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 0-15 are also used by the runtime.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> {
</span></span><span style=display:flex><span>  AccessSizeShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#75715e>// 4 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  IsWriteShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  RecoverShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  MatchAllShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>, <span style=color:#75715e>// 8 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  HasMatchAllShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>,
</span></span><span style=display:flex><span>  CompileKernelShift <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><p>IsWrite 布尔值，0 表示本次 memory access 是读操作，1 表示本次 memory access 为 写操作。</p></li><li><p>AccessSizeIndex 由 <code>__builtin_ctz(AccessSize)</code> 计算得到。AccessSize 为 1-byte, 2-bytes, 4-bytes, 8-bytes, 16-bytes 时，AccessSizeIndex 分别为 0, 1, 2, 3, 4。</p></li><li><p>CompileKernel 布尔值，只有 HWASAN 用于 <a href=https://lwn.net/Articles/763684/>KernelHWAddressSanitizer</a> 时 CompileKernel 值才为 1。</p></li><li><p>MatchAllTag 类型为 uint8_t，MatchAllTag 的默认值为 -1，表示没有设置 MatchAllTag。可以通过编译时选项 <code>-mllvm -hwasan-match-all-tag=-1</code> 进行设置。当保存在指针 top byte 的 tag 值 和保存在 shadow memory 中的 tag 不匹配时说明 HWASAN 检测到的内存错误，如果设置了 MatchAllTag，那么 HWASAN 会忽略所有 pointer tag 为 MatchAllTag 时出现的 tag mismatch。</p></li><li><p>Recover 布尔值，0 表示 HWASAN 检测到错误不再继续执行程序，1 表示 HWASAN 检测到错误后继续执行。Recover 默认为 0，在编译时添加参数 <code>-fsanitize-recover=hwaddress</code> 后 Recover 为 1。</p></li></ul></li></ol><p>上述例子 LLVM IR 中，调用 <code>llvm.hwasan.check.memaccess.shortgranules</code> 的第一参数就是 <code>%__hwasan_shadow_memory_dynamic_address</code>，第二个参数是 <code>%8</code> 对应源码中的 <code>x[10]</code> 的地址，第三个参数是常数 <code>18</code> 表示本次内存访问是写入 4-byte 的操作。</p><hr><p><code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 在 AsmPrinter 阶段被转换为汇编代码。对于 AArch64 后端，相关的函数为 <code>LowerHWASAN_CHECK_MEMACCESS()</code>, <code>emitHwasanMemaccessSymbols()</code>，代码位于 llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp。</p><p><code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 会根据参数不同而生成不同的汇编函数。例如上述例子中 <code>call void @llvm.hwasan.check.memaccess.shortgranules(ptr %__hwasan_shadow_memory_dynamic_address, ptr %8, i32 18)</code> 生成的汇编符号/函数名为 <code>__hwasan_check_x0_18_short_v2</code>：</p><ul><li><p>x0 表示本次 memory access 访问的内存地址保存在 X0 寄存器中</p></li><li><p>18 即本次 memory access 的 AccessInfo 的值</p></li></ul><p>另外，AArch64AsmPrinter 在将 <code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 转换为汇编代码时，总是将 __hwasan_shadow_memory_dynamic_address 即 shadow base 保存在 X20 寄存器中。</p><p><code>__hwasan_check_x0_18_short_v2</code> 完整的汇编代码如下：</p><pre tabindex=0><code>__hwasan_check_x0_18_short_v2:
  sbfx    x16, x0, #4, #52    // shadow offset
  ldrb    w16, [x20, x16]     // load shadow tag
  cmp     x16, x0, lsr #56    // extract address tag, compare with shadow tag
  b.ne    .Ltmp0              // jump to short tag handler on mismatch
.Ltmp1:
  ret
.Ltmp0:
  cmp     w16, #15            // is this a short tag?
  b.hi    .Ltmp2              // if not, error
  and     x17, x0, #0xf       // find the address&#39;s position in the short granule
  add     x17, x17, #3        // adjust to the position of the last byte loaded
  cmp     w16, w17            // check that position is in bounds
  b.ls    .Ltmp2              // if not, error
  orr     x16, x0, #0xf       // compute address of last byte of granule
  ldrb    w16, [x16]          // load tag from it
  cmp     x16, x0, lsr #56    // compare with pointer tag
  b.eq    .Ltmp1              // if matches, continue
.Ltmp2:
  // save original x0, x1 on stack (they will be overwritten)
  stp     x0, x1, [sp, #-256]!
  // create frame record
  stp     x29, x30, [sp, #232]
  // set x1 to a constant indicating the type of failure
  mov     x1, #18
  // call runtime function to save remaining registers and report error
  adrp    x16, :got:__hwasan_tag_mismatch_v2
  // (load address from GOT to avoid potential register clobbers in delay load handler)
  ldr     x16, [x16, :got_lo12:__hwasan_tag_mismatch_v2]
  br      x16
</code></pre><hr><p>前面内容提到，HWASAN 在编译插桩时，默认情况下是在每一处内存读写之前添加对 <code>llvm.hwasan.check.memaccess.shortgranules</code> intrinsic 的调用，那非默认情况呢？</p><ul><li><p>如果在编译时添加选项 <code>-mllvm -hwasan-instrument-with-calls=true</code>，那么编译插桩时 HWASAN 在每一处内存读写之前添加的则是对 <code>__hwasan_[load|store][1|2|4|8|16|n]</code> 的函数调用。</p><p>还是以本文开头的示例代码进行说明，<code>clang -O1 -fsanitize=hwaddress -mllvm -hwasan-instrument-with-calls=true test.c -S -emit-llvm</code> 生成的 LLVM IR 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span>  %2 = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %3 = <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>noalias</span> <span style=color:#960050;background-color:#1e0010>ptr</span> @malloc(<span style=color:#66d9ef>i64</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> <span style=color:#ae81ff>40</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %3, <span style=color:#960050;background-color:#1e0010>ptr</span> %2, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %4 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %2, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %5 = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>inbounds</span> <span style=color:#66d9ef>i32</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %4, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>  %6 = <span style=color:#66d9ef>ptrtoint</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %5 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i64</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @__hwasan_store4(<span style=color:#66d9ef>i64</span> %6)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#66d9ef>i32</span> <span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  %7 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %2, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @free(<span style=color:#960050;background-color:#1e0010>ptr</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> %7)
</span></span></code></pre></div><p><code>__hwasan_[load|store][1|2|4|8|16|n]</code> 函数由 HWASAN runtime 中实现，代码位于 compiler-rt/lib/hwasan/hwasan.cpp。根据本次 memory access 为读操作或写操作，调用 <code>___hwasan_load</code> 或 <code>___hwasan_store</code>；根据本次 memory access 读写的内存大小（字节），调用相应的版本，如本次 memory acesss 是对 4-bytes 内存的写操作，HWASAN 插入的是就对 <code>___hwasan_store4</code> 的调用。</p><p><code>__hwasan_[load|store][1|2|4|8|16|n]</code> 函数的实现几乎一致，下面给出 <code>___hwasan_store4</code> 的代码实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>__hwasan_store4</span>(uptr p) {
</span></span><span style=display:flex><span>  CheckAddress<span style=color:#f92672>&lt;</span>ErrorAction<span style=color:#f92672>::</span>Abort, AccessType<span style=color:#f92672>::</span>Store, <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>(p);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>ErrorAction EA, AccessType AT, <span style=color:#66d9ef>unsigned</span> LogSize<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>__attribute__((always_inline, nodebug)) <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> CheckAddress(uptr p) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>InTaggableRegion(p))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  uptr ptr_raw <span style=color:#f92672>=</span> p <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>kAddressTagMask;
</span></span><span style=display:flex><span>  tag_t mem_tag <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(tag_t <span style=color:#f92672>*</span>)MemToShadow(ptr_raw);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (UNLIKELY(<span style=color:#f92672>!</span>PossiblyShortTagMatches(mem_tag, p, <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> LogSize))) {
</span></span><span style=display:flex><span>    SigTrap<span style=color:#f92672>&lt;</span>EA, AT, LogSize<span style=color:#f92672>&gt;</span>(p);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (EA <span style=color:#f92672>==</span> ErrorAction<span style=color:#f92672>::</span>Abort)
</span></span><span style=display:flex><span>      __builtin_unreachable();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__attribute__((always_inline, nodebug)) <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>PossiblyShortTagMatches(tag_t mem_tag, uptr ptr, uptr sz) {
</span></span><span style=display:flex><span>  DCHECK(IsAligned(ptr, kShadowAlignment));
</span></span><span style=display:flex><span>  tag_t ptr_tag <span style=color:#f92672>=</span> GetTagFromPointer(ptr);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ptr_tag <span style=color:#f92672>==</span> mem_tag)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (mem_tag <span style=color:#f92672>&gt;=</span> kShadowAlignment)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ((ptr <span style=color:#f92672>&amp;</span> (kShadowAlignment <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>+</span> sz <span style=color:#f92672>&gt;</span> mem_tag)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>(u8 <span style=color:#f92672>*</span>)(ptr <span style=color:#f92672>|</span> (kShadowAlignment <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>==</span> ptr_tag;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>如果在编译时添加选项 <code>-mllvm -hwasan-inline-all-checks=true</code>，那么编译插桩时 HWASAN 会直接在 LLVM IR 上实现检查保存在指针 top byte 的 tag 和保存在 shadow memory 中的 tag 是否匹配的逻辑。</p><p>还是以本文开头的示例代码进行说明，<code>clang -O1 -fsanitize=hwaddress -mllvm -hwasan-inline-all-checks=true test.c -S -emit-llvm</code> 生成的 LLVM IR 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-llvm data-lang=llvm><span style=display:flex><span>  %5 = <span style=color:#66d9ef>alloca</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %6 = <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>noalias</span>  <span style=color:#960050;background-color:#1e0010>ptr</span> @malloc(<span style=color:#66d9ef>i64</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> <span style=color:#ae81ff>40</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>store</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %6, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %7 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  %8 = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>inbounds</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %7, <span style=color:#66d9ef>i64</span> <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>  %9 = <span style=color:#66d9ef>ptrtoint</span> <span style=color:#960050;background-color:#1e0010>ptr</span> %8 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i64</span>
</span></span><span style=display:flex><span>  %10 = <span style=color:#66d9ef>lshr</span> <span style=color:#66d9ef>i64</span> %9, <span style=color:#ae81ff>56</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; extrac pointer tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %11 = <span style=color:#66d9ef>trunc</span> <span style=color:#66d9ef>i64</span> %10 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  %12 = <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>i64</span> %9, <span style=color:#ae81ff>72057594037927935</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; shadow offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %13 = <span style=color:#66d9ef>lshr</span> <span style=color:#66d9ef>i64</span> %12, <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; shadow base + shadow offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %14 = <span style=color:#66d9ef>getelementptr</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %4, <span style=color:#66d9ef>i64</span> %13
</span></span><span style=display:flex><span>  <span style=color:#75715e>; load shadow tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %15 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %14, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; compare pointer tag with shadow tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %16 = <span style=color:#66d9ef>icmp</span> <span style=color:#66d9ef>ne</span> <span style=color:#66d9ef>i8</span> %11, %15
</span></span><span style=display:flex><span>  <span style=color:#75715e>; jump to short tag handler on mismatch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %16, <span style=color:#66d9ef>label</span> %17, <span style=color:#66d9ef>label</span> %31
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>17</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>; is this a short tag?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %18 = <span style=color:#66d9ef>icmp</span> <span style=color:#66d9ef>ugt</span> <span style=color:#66d9ef>i8</span> %15, <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; if not, error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %18, <span style=color:#66d9ef>label</span> %19, <span style=color:#66d9ef>label</span> %20
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>19</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %25, %20, %17
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> <span style=color:#66d9ef>asm</span> <span style=color:#66d9ef>sideeffect</span> <span style=color:#e6db74>&#34;brk #2320&#34;</span>, <span style=color:#e6db74>&#34;{x0}&#34;</span>(<span style=color:#66d9ef>i64</span> %9)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unreachable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>20</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %17
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>; find the address&#39;s position in the short granule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %21 = <span style=color:#66d9ef>and</span> <span style=color:#66d9ef>i64</span> %9, <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>  %22 = <span style=color:#66d9ef>trunc</span> <span style=color:#66d9ef>i64</span> %21 <span style=color:#66d9ef>to</span> <span style=color:#66d9ef>i8</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; adjust to the position of the last byte loaded
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %23 = <span style=color:#66d9ef>add</span> <span style=color:#66d9ef>i8</span> %22, <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; check that position is in bounds
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %24 = <span style=color:#66d9ef>icmp</span> <span style=color:#66d9ef>uge</span> <span style=color:#66d9ef>i8</span> %23, %15
</span></span><span style=display:flex><span>  <span style=color:#75715e>; if not, error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %24, <span style=color:#66d9ef>label</span> %19, <span style=color:#66d9ef>label</span> %25
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>25</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>; compute address of last byte of granule
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %26 = <span style=color:#66d9ef>or</span> <span style=color:#66d9ef>i64</span> %12, <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>  %27 = <span style=color:#66d9ef>inttoptr</span> <span style=color:#66d9ef>i64</span> %26 <span style=color:#66d9ef>to</span> <span style=color:#960050;background-color:#1e0010>ptr</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; load tag from it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %28 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>i8</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %27, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; compare with pointer tag
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  %29 = <span style=color:#66d9ef>icmp</span> <span style=color:#66d9ef>ne</span> <span style=color:#66d9ef>i8</span> %11, %28
</span></span><span style=display:flex><span>  <span style=color:#75715e>; if mismatche, error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>i1</span> %29, <span style=color:#66d9ef>label</span> %19, <span style=color:#66d9ef>label</span> %30
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>30</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %25
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>br</span> <span style=color:#66d9ef>label</span> %31
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>31</span><span style=color:#960050;background-color:#1e0010>:</span>                                               <span style=color:#75715e>; preds = %0, %30
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>store</span> <span style=color:#66d9ef>i8</span> <span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %8, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>  %32 = <span style=color:#66d9ef>load</span> <span style=color:#66d9ef>volatile</span> <span style=color:#960050;background-color:#1e0010>ptr</span>, <span style=color:#960050;background-color:#1e0010>ptr</span> %5, <span style=color:#66d9ef>align</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>call</span> <span style=color:#66d9ef>void</span> @free(<span style=color:#960050;background-color:#1e0010>ptr</span> <span style=color:#960050;background-color:#1e0010>no</span><span style=color:#66d9ef>undef</span> %32)
</span></span></code></pre></div></li></ul><h2 id=参考链接>参考链接</h2><ul><li><a href=https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html>Hardware-assisted AddressSanitizer Design Documentation</a></li><li><a href=https://github.com/google/sanitizers/tree/master/hwaddress-sanitizer>https://github.com/google/sanitizers/tree/master/hwaddress-sanitizer</a></li></ul></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/llvm/ rel=tag>LLVM</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/hwasan-internals/>HWASAN Internals</a></li><li class=widget__item><a class=widget__link href=/post/inside-asan-allocator/>Inside AddressSanitizer Allocator</a></li><li class=widget__item><a class=widget__link href=/random/2022-12-31-summary/>2022 年度总结</a></li><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-runtime-init/>How Sanitizer Runtime Initialized</a></li><li class=widget__item><a class=widget__link href=/post/gwp-asan-internals/>GWP-ASan Internals</a></li><li class=widget__item><a class=widget__link href=/post/dumb-sanitizer-howto/>How To Write A Dumb Sanitizer</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li><li class=widget__item><a class=widget__link href=/categories/random/>Random</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>