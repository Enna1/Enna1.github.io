<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Dissecting ThreadSanitizer Algorithm - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Dissecting ThreadSanitizer Algorithm"><meta property="og:description" content="本文深入剖析 ThreadSanitizer(V2) 检测 Data Race 背后的算法原理。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/dissecting-thread-sanitizer/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-20T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/random/><span class=menu__text>random</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><link rel=stylesheet href=/js/katex/katex.min.css><script src=/js/katex/katex.min.js></script><script src=/js/katex/contrib/auto-render.min.js></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Dissecting ThreadSanitizer Algorithm</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-20T00:00:00Z>October 20, 2022</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#data-race>Data Race</a></li><li><a href=#happen-before--concurrent>Happen-Before & Concurrent</a></li><li><a href=#lamport-logical-clock>Lamport Logical Clock</a></li><li><a href=#vector-clock>Vector Clock</a></li><li><a href=#data-race-detection>Data Race Detection</a></li><li><a href=#threadsanitizer-internals>ThreadSanitizer Internals</a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>本文深入剖析 ThreadSanitizer(V2) 检测 Data Race 背后的算法原理。</p><h2 id=introduction>Introduction</h2><p>ThreadSanitizer(AKA TSan) 是一个集成在 GCC 和 Clang 中的动态分析工具，能够检测 C++ 代码中大多数的数据竞争 (data race) 。它由编译时插桩和运行时库两部分组成，通过编译和链接时添加参数 <code>-fsanitize=thread</code>，就可以在运行时检测 data race 。</p><h2 id=data-race>Data Race</h2><p>TSan 是检测 data race 的动态分析工具。我们先看下 data race 指的是什么？</p><p><strong>Data Race</strong>：两个线程 <strong>concurrently</strong> 访问了<strong>同一个内存位置 (memory location)</strong>，并且两个线程的访存操作中<strong>至少一个是写操作</strong>。</p><p>注：关于 race condition 和 data race 的区别，见 <a href=https://blog.regehr.org/archives/490>Race Condition vs. Data Race – Embedded in Academia</a></p><p>例如下述代码：两个线程并发地修改整型全局变量 Global 存在 data race。两个线程执行结束后，全局变量 Global 的值可能是 1 也可能是 2。如果是在读写 STL 容器时存在 data race，则可能导致更严重的后果，比如内存破坏、程序崩溃。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> Global;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Thread1</span>() {
</span></span><span style=display:flex><span>  Global <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Thread2</span>() {
</span></span><span style=display:flex><span>  Global <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>根据 data race 的定义，判断代码中是否存在 data race 需要考虑 3 个条件：</p><ol><li>两个线程访问的是否为<strong>同一个 memory location</strong></li><li>两个线程的访存操作中<strong>至少有一个是写操作</strong></li><li>两个线程的访存操作是否 <strong>concurrent</strong></li></ol><p>其中前两个条件很容易判断，所以检测 data race 的要解决的关键问题就是怎么判断两个访存操作是否 <strong>concurrent</strong> <strong>！</strong></p><h2 id=happen-before--concurrent>Happen-Before & Concurrent</h2><p>在介绍如何判断两次访问操作是否是 concurrent 之前，我们需要先引入 happen-before 的定义。</p><p>Happen-before 的定义最开始是在 <a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system</a> 中给出的，描述的是分布式系统中事件之间的一种偏序关系。</p><p>一个分布式系统是由一系列 processes 组成的，每个 process 又由一系列事件组成， 不同的 process 之间是通过收发消息进行通信的。</p><p><em><strong>Happen-before</strong></em> 关系（记作 $\rightarrow$）的定义：</p><ol><li><p>如果事件 $a$ 和事件 $b$ 是在同一个 process 中的事件，并且 $a$ 早于 $b$ 发生，那么 $a \rightarrow b$</p></li><li><p>如果事件 $a$ 和事件 $b$ 是不同 process 中的事件，且 $b$ 是 $a$ 发送的消息的接收者，那么 $a \rightarrow b$</p></li><li><p><em><strong>Happen-before</strong></em> 关系是一种严格<strong>偏序</strong>关系 (strict partial order)，即满足 transitive, irreflexive and antisymmetric</p><ol><li>Transitive。对于任意事件 $a,b ,c$，如果 $a \rightarrow b$ 且 $b \rightarrow c$，那么有 $a \rightarrow c$</li><li>Irreflexive。对于任意事件 $a$，都有 $a \nrightarrow a$</li><li>Antisymmetric。对于任意事件 $a,b$，如果 $a \rightarrow b$，那么有 $b \nrightarrow a$</li></ol></li></ol><p>下面通过一个例子对 happen-before 进行说明：</p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-09-43-40-image.png title alt width=450><p>上图是对一个分布式系统的某一次 trace：</p><ul><li>3 条垂直线分别表示 3 个 process: $P, Q, R$</li><li>垂直线上的点表示事件，在同一条垂直线上纵坐标小的事件发生的时间早于纵坐标大的事件发生的时间。例如事件 $p_1$ 早于事件 $p_2$ 发生</li><li>连接 process 之间的线表示 process 之间通过收发消息进行通信，$p_1 \rightarrow q_2$ 表示 process $P$ 于事件 $p_1$ 向 process $Q$ 发送消息， 这个消息被 process $Q$ 于事件 $q_2$ 接收到</li></ul><p>那么对于上图分布式系统 trace：</p><ul><li>根据 <em><strong>happen-before</strong></em> 的定义能得出：$p_1 \rightarrow r_4$，这是因为 $p_1 \rightarrow q_2$, $q_2 \rightarrow q_4$, $q_4 \rightarrow r_3$, $r_3 \rightarrow r_4$，所以 $p_1 \rightarrow r_4$。即事件 $p1$ 一定是先于事件 $r4$ 发生，不管上述分布式系统事件运行多少次</li><li>尽管根据本次 trace 看来在时间上事件 $q_3$ 是早于事件 $p_3$ 发生的，但是 $q_3 \nrightarrow p_3$ 且 $p_3 \nrightarrow q_3$，即事件 $q_3$ 和事件 $p_3$ 之间是没有 happen-before 关系的。所以不能保证每一次运行，事件 $q_3$ 都是早于事件 $p_3$ 发生的，也有可能在某一次 trace 中事件 $p_3$ 是早于事件 $q_3$ 发生的</li></ul><p>理解了 happen-before 的定义后，我们给出 <strong>concurrent</strong> 的定义：如果 $a \nrightarrow b$ 且 $b \nrightarrow a$，那么称 $a$ 和 $b$ 是 <strong>concurrent</strong> 的。</p><p>这样我们就能够将判断两次访存操作之间是否 concurrent 转化为了判断两次访存操作之间是否存在 happen-before 关系。</p><p>那么如何判断两次访存操作之间是否存在 happen-before 关系呢？答案是 Vector Clock。在介绍 Vector Clock 之前，我们需要先了解下 Lamport Logical Clock。</p><h2 id=lamport-logical-clock>Lamport Logical Clock</h2><p>Lamport logical clock 算法是由 Leslie Lamport 在 <a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system</a> 中提出的一种简单的逻辑时钟算法，用于描述分布式计算机系统中事件的偏序关系。</p><p>算法如下：</p><ol><li>每个 Process $P_i$ 都持有一个逻辑时钟 $Clock_i$，process $P_i$ 在每次本地事件发生之前，都将 $Clock_i$ 自增 1</li><li>Process $P_i$ 向其他 Process 发送消息时，先执行步骤 1，然后将 $Clock_i$ 的值包含在消息中一并发送出去</li><li>Process $P_j$ 接收到 Process $P_i$ 发送来的消息时，获取消息中携带的 $Clock_i$ 的值，与自身的 $Clock_j$ 取最大值，然后在认为收到消息之前将 $Clock_j$ 自增 1</li></ol><p>根据 lamport logical clock 算法流程和 happen-before 定义易得：对于任意两个事件，如果事件 $a$ <em><strong>happen-before</strong></em> 事件 $b$，那么 $Clock(a) &lt; Clock(b)$。</p><p>下面通过例子来说明 lamport logical clock 算法流程：</p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-09-51-37-image.png title alt width=250><ul><li>初始时，Process $P$ 和 Process $Q$ 的逻辑时钟的值都为 0</li><li>Process $P$ 发生本地事件 $p_1$，逻辑时钟 $Clock_p$ 的值由 0 更新为 1。Process $Q$ 发生本地事件 $q_1$，逻辑时钟 $Clock_q$ 的值由 0 更新为 1</li><li>Process $P$ 于事件 $p_2$ 向 Process $Q$ 发送消息，先自增逻辑时钟 $Clock_p$ 的值，由 1 更新为 2。然后将此时 $Clock_p$ 的值（即 2）包含在消息中一并发送出去</li><li>Process $Q$ 接收到 Process $P$ 发送来的消息，获取消息中携带的逻辑时钟的值（即 2），首先将逻辑时钟 $Clock_q$ 的值更新为消息中携带的逻辑时钟的值与此时自身逻辑时钟 $Clock_q$ 的值的最大值（即 $Clock_q$ 更新为 2 和 2 的最大值，还是 2），然后再将 $Clock_q$ 自增 1（即 $Clock_q$ 的值由 2 更新为 3 ）</li><li>&mldr;</li></ul><p>但是 lamport logical clock 是存在局限性的：</p><ul><li>只能保证：如果 $a \rightarrow b$，那么 $Clock(a) &lt; Clock(b)$</li><li>但是 $Clock(a) &lt; Clock(b)$ 不意味着 $a \rightarrow b$，即我们不能基于 $Clock(a) &lt; Clock(b)$ 来判定事件 $a$ <em><strong>happen-before</strong></em> 事件 $b$</li></ul><p>例如 $Clock_p(p1)= 1 &lt; 2 = Clock_q(q2) $，但是实际上 $p_1$ <em><strong>happen-before</strong></em> $p_2$ 是不成立！也就是说，事件 $p_1$ 和事件 $p_2$ 之间谁都可能早于另外一个事件发生。</p><p>我们前面将 data race 检测问题转化为了判断两次访存操作之间是否存在 happen-before 关系的问题。但是由于 lamport logical lock 的局限性，我们不能直接将 lamport logic clock 应用于 data race 的检测。</p><h2 id=vector-clock>Vector Clock</h2><p>Colin Fidge 和 Friedemann Mattern 提出的 vector clock 解决了 lamport logic clock 的上述局限性</p><p>vector clock 算法如下：</p><ul><li>每一个 process $P_i$ 都对应一个 vector clock $VC_i$，$VC_i$ 是由 n 个元素组成的向量，n 是分布式系统中 process 的数量。每个 process $P_i$ 的 $VC_i$ 都被初始化为 0</li><li>每当 process $P_i$ 发生本地事件之前，更新 vector clock：$VC_i[i] = VC_i[i] + 1$</li><li>Process $P_i$ 向其他 Process 发送消息时，先更新 vector clock：$VC_i[i] = VC_i[i] + 1$，然后将 $VC_i$ 的值包含在消息中</li><li>process $P_j$ 接收由 process $P_i$ 发送来的 message，更新 vector clock：$VC_j[j] = VC_j[j] + 1,
VC_j[k] = max(VC_j[k], VC_i[k])\ \textup{for all process}\ k$</li></ul><p>下面还是通过一个例子来说明 vector clock 的算法流程：</p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-10-23-24-image.png title alt width=450><ul><li><p>初始时 $VC_1 = VC_2 = VC_3= [0,0,0]$</p></li><li><p>Process $P$ 发生内部事件 $p_1$，更新 vector clock：$VC_1 = [0+1,0,0]=[1,0,0]$</p></li><li><p>Process $Q$ 发生内部事件$p_2$，更新 vector clock：$VC_2 = [0,0+1,0] = [0,1,0]$</p></li><li><p>Process $R$ 发生内部事件 $p_3$，更新 vector clock：$VC_3 = [0,0,0+1]=[0,0,1]$</p></li><li><p>process $Q$ 于事件 $q_2$ 接收由 process $P$ 于事件 $p_2$ 发送的消息，更新 vector clock：</p><ul><li>$VC_1[1] = 1 + 1 = 2, VC_1 = [2, 0, 0]$</li><li>$VC_2[2] = 1 + 1 = 2, VC_2 = [0,2,0]$</li><li>$VC_2 = max(VC_1, VC_2) = [max(2,0), max(0,2), max(0,0)]=[2,2,0]$</li></ul></li><li><p>&mldr;</p></li></ul><p>Vector clock 解决了 lamport logical clock 的局限性，满足如下性质：</p><ul><li>如果事件 $a$ <em><strong>happen-before</strong></em> 事件 $b$，那么 $VC(a) &lt; VC(b)$</li><li>如果 $VC(a) &lt; VC(b)$，那么事件 $a$ <em><strong>happen-before</strong></em> 事件 $b$</li></ul><p>即 $p_a \rightarrow q_b \quad \textup{iff} \quad VC_p(a) &lt; VC_q(b)$</p><p>Vector clock 上的偏序关系如下：</p><ul><li>$VC_p = VC_q \quad \textup{iff} \enspace \forall k, \enspace VC_p[k] = VC_q[k]$</li><li>$VC_p \neq VC_q \quad \textup{iff} \enspace \exist k, \enspace VC_p[k] \neq VC_q[k]$</li><li>$VC_p \leq VC_q \quad \textup{iff} \enspace \forall k, \enspace VC_p[k] \leq VC_q[k]$</li><li>$VC_p &lt; VC_q \quad \textup{iff} \enspace (VC_p \le VC_q \enspace \textup{and} \enspace VC_p \neq VC_q)$</li></ul><p>根据 $p_a \rightarrow q_b \quad \textup{iff} \quad VC_p(a) &lt; VC_q(b)$ 这个性质，我们就能使用 vector clock 来判断两次访存操作之间是否存在 happen-before 关系，即能够基于 vector clock 算法来检测多线程程序中的 data race。</p><h2 id=data-race-detection>Data Race Detection</h2><p>我们前面在介绍 lamport logic clock 和 vector clock 时都是以分布式系统中的事件之间序关系为背景进行介绍的。</p><p>实际上多线程程序也可以看作是一个分布式系统。我们对上述 vector clock 算法稍加修改，就可以应用于检测多线程程序中的 data race：</p><ul><li>符号定义：<ul><li>$\mathbb{VC_1} \sqsubseteq \mathbb{VC_2}\quad\textbf{iff}\quad\forall t.\ \mathbb{VC_1}(t) \leq \mathbb{VC_2}(t)$</li><li>$\mathbb{VC_1} \sqcup \mathbb{VC_2} \quad=\quad \lambda t.\ max(\mathbb{VC_1}(t), \mathbb{VC_2}(t))$</li></ul></li><li>每个线程 $t$ 都对应一个 vector clock $\mathbb{VC}_t$，初始值为 0。对于任意一个线程 $u$，$\mathbb{VC}_t(u)$ 记录的其实是与线程 $t$ 的当前操作满足 happen-before 关系的线程 $u$ 的上一次操作的 clock。如果把线程 $u$ 的上一次操作记为 $O_u$，把线程 $t$ 的当前操作记为 $O_t$，那么有 $O_u\ \text{happen-before}\ O_t$</li><li>每一个锁 $m$ 都对应一个 vector clock $\mathbb{L}_m$</li><li>每一个变量 $x$都对应两个 vector clock: $\mathbb{W}_x$ 和 $\mathbb{R}_x$。对于任意一个线程 $t$，$\mathbb{W}_x[t]$ 和 $\mathbb{R}_x[t]$ 记录了线程 $t$ 对变量 $x$ 的最后一次读/写的 clock<ul><li>线程 $t$ 对变量 $x$ 的读时，会将 $\mathbb{R}_x[t]$ 的值更新为 $\mathbb{VC}_t[t]$ 的值</li><li>程序 $t$ 对变量 $x$ 的写时，会将 $\mathbb{W}_x[t]$ 的值更新为 $\mathbb{VC}_t[t]$ 的值</li></ul></li><li>程序中执行同步和线程操作时，算法会更新相应的 vector clock：<ul><li>$rel(t, m)$。线程 $u$ 释放了锁 $m$，先将 $\mathbb{L}_m$ 的值更新为 $\mathbb{VC}_u$ 的值，再将 $\mathbb{VC}_u[u]++$</li><li>$acq(t, m)$。线程 $t$ 获取了锁 $m$，将 $\mathbb{VC}_t$ 的值更新为 $\mathbb{VC}_t \sqcup \mathbb{L}_m$ 的值</li><li>$fork(t, u)$。先将 $\mathbb{VC}_u$ 的值更新为 $\mathbb{VC}_u \sqcup \mathbb{VC}_t$，再将 $\mathbb{VC}_t[t]++$</li><li>$join(t, u)$。先将 $\mathbb{VC}_t$ 的值更新为 $\mathbb{VC}_t\sqcup \mathbb{VC}_u$，再将 $\mathbb{VC}_u[u]++$</li></ul></li><li>判断是否存在 data race：<ul><li>假设当前线程 $u$ 读变量 $x$，如果满足 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$，那么当前线程 $u$ 对变量 $x$ 的读与之前其他线程对变量 $x$ 的写不存在 data race</li><li>假设当前线程 $u$ 写变量 $x$，如果 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 且 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 那么当前线程 $u$ 对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读不存在 data race</li></ul></li></ul><hr><p>下面还是通过一个例子来说明如何应用 vector clock 检测多线程程序中的 data race：</p><ul><li><p>考虑多线程程序中有两个线程 A 和 B，有一个锁 $m$ ，还有一个变量 $x$</p></li><li><p>线程 $A$ 对应的 vector clock 记作 $\mathbb{VC}_A$，线程 $B$ 对应的 vector clock 记作 $\mathbb{VC}_B$，锁 $m$ 对应的 vector clock 记作 $\mathbb{L}_m$，变量 $x$ 对应的写/读 vector clock 记作 $\mathbb{W}_x$ 和 $\mathbb{R}_x$</p></li><li><p>假设多线程程序某一个时刻的运行状态如下图所示：</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-32-22-image.png alt></p></li><li><p>此时线程 $A$ 执行语句 <code>x = 0</code> 写变量 $x$，我们需要检查当前线程对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 和 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。</p><p>显然 $[3, 0] \sqsubseteq [4,1]$ 和 $[0, 1] \sqsubseteq [4,1]$ 都满足，即本次线程 $A$ 执行语句 <code>x = 0</code> 写变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间不存在 data race</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-34-10-image.png alt></p></li><li><p>因为线程 $A$ 执行语句 <code>x = 0</code> 写了变量 $x$，我们要更新 $\mathbb{W}_x$ 的值，将 $\mathbb{W}_x[A]$ 的值更新为 $\mathbb{VC}_A[A]$ 的值：</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-34-59-image.png alt></p></li><li><p>程序继续执行，此时线程 $A$ 执行语句 <code>rel(m)</code> 释放锁 $m$，先将 $\mathbb{L}_m$ 的值更新为 $\mathbb{VC}_A$ 的值，再将 $\mathbb{VC}_A[A]++$</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-40-30-image.png alt></p></li><li><p>程序继续执行，此时线程 $B$ 执行语句 <code>acq(m)</code> 申请锁 $m$，将 $\mathbb{VC}_B$ 的值更新为 $\mathbb{VC}_B \sqcup \mathbb{L}_m$ 的值</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-41-22-image.png alt></p></li><li><p>线程 $B$ 执行语句 <code>x = 1</code> 写变量 $x$ ，我们需要检查当前线程对变量 $x$ 的写与之前其他线程对变量 $x$ 的写和读之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 和 $\mathbb{R_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。</p><p>显然 $[4, 0] \sqsubseteq [4,8]$ 和 $[0, 1] \sqsubseteq [4,8]$ 都满足，即本次线程 $B$ 执行语句 <code>x = 1</code> 写变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间不存在 data race。</p><p>因为线程 $B$ 执行语句 <code>x = 1</code> 写变量 $x$，我们要更新 $\mathbb{W}_x$ 的值，将 $\mathbb{W}_x[B]$ 的值更新为 $\mathbb{VC}_B[B]$ 的值：</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-43-57-image.png alt></p></li><li><p>线程 $A$ 执行语句 <code>y = x</code> 读变量 $x$，我们需要检查当前线程对变量 $x$ 的读与之前其他线程对变量 $x$ 的写之间是否存在 data race，即判断 $\mathbb{W_x} \sqsubseteq \mathbb{VC_u}$ 是否满足。</p><p>显然 $[4, 8] \sqsubseteq [5,1]$ <strong>不满足</strong>，即本次线程 $B$ 执行语句 <code>x = 1</code> 写变量 $x$ 与之前其他线程对变量 $x$ 的读之间<strong>存在 data race</strong>。</p><p>即我们检测到线程 $A$ 执行语句 <code>y = x</code> 读变量 $x$ 与之前其他线程对变量 $x$ 的写和读之间<strong>存在 data race</strong>。更具体地说是线程 $A$ 执行语句 <code>y = x</code> 读变量 $x$ 与之前线程 $B$ 执行语句 <code>x = 1</code> 读变量 $x$ 存在 data race。</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-11-45-55-image.png alt></p></li></ul><h2 id=threadsanitizer-internals>ThreadSanitizer Internals</h2><p>ThreadSanitizer 检测 data race 的思想其实就是基于 vector clock 算法的，只不过在实现时做了一些取舍。比如对于每一个变量 $x$，ThreadSanitizer 不会记录所有线程最近一次对变量 $x$ 的读写，ThreadSanitizer 只会记录最近 4 次对变量 $x$ 的读写。</p><p>ThreadSanitizer 由编译时插桩和运行时库两部分组成。</p><ul><li>编译时插桩：对于每一次 memory access (load, store)，都会在此次 acccess 之前插入一个函数调用 (<code>__tsan_read</code>, <code>__tsan_write</code>)，该函数调用是在运行时库中实现的。</li><li>运行时库：在 <code>__tsan_read</code>, <code>__tsan_write</code> 中实现 data race 检测的核心逻辑，判断本次访问是否存在 data race。劫持了很多函数实现如 libc 和 pthread，在申请锁、释放锁，fork/join 线程时更新 vector clock 。</li></ul><p>例如，本文最开始提到的全局变量数据竞争的代码片段使用 ThreadSanitizer 插桩后的代码变为如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> global;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Thread1</span>() {
</span></span><span style=display:flex><span>  __tsan_func_entry(__builtin_return_address(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>  __tsan_write4(<span style=color:#f92672>&amp;</span>global);
</span></span><span style=display:flex><span>  global <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  __tsan_func_exit();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Thread2</span>() {
</span></span><span style=display:flex><span>  __tsan_func_entry(__builtin_return_address(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>  __tsan_write4(<span style=color:#f92672>&amp;</span>global);
</span></span><span style=display:flex><span>  global <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  __tsan_func_exit();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意到：在 <code>global = 1</code> 和 <code>global = 2</code> 之前都插入了对 <code>__tsan_write4</code> 的函数调用。</p><hr><p>启用 ThreadSanitizer 后，在程序运行过程中，每一个线程都会保存一个 vector clock，每 8-bytes 的应用程序内存都对应有 4 个 8-bytes 的 shadow word。每个 shadow word 都用于记录一次访问操作，记录 TID（线程 id）、Epoch（访存操作发生时线程 TID 此时的 local time）、Pos:Size（标识本次访存访问的是当前 8-bytes 的哪几个 bytes）、IsWrite（标识本次访存操作是读还是写）。</p><p>每次读写变量 $x$ 时，由于程序被 ThreadSanitizer 插桩，所以在执行读写操作之前，都会调用函数 <code>__tsan_read</code> 或 <code>__tsan_write</code>，在<code>__tsan_read</code> 和 <code>__tsan_write</code>的函数实现中，首先找到变量 $x$ 所在的 8-bytes 内存区域。然后找到这 8-bytes 内存所对应的 4 个 shadow word，检查当前这一次对变量 $x$ 的读写与shadow word 中记录的最近 4 次读写是否存在 data race。最后更新 shadow word 的内容，记录本次对变量 $x$ 的读写，保证 shadow word 记录的是最近 4 次对变量 $x$ 的读写。</p><p><img src=/blog/dissecting-thread-sanitizer/2022-10-20-12-04-08-image.png alt></p><p>完整的 ThreadSanitizer 算法的伪代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>HandleMemoryAccess</span>(thread_state, tid, pc, addr, size, is_write, is_atomic):
</span></span><span style=display:flex><span>  shadow_mem <span style=color:#f92672>=</span> MemToShadow(addr) <span style=color:#75715e># the type of shadow_mem is uint64_t*</span>
</span></span><span style=display:flex><span>  IncrementThreadClock(tid)
</span></span><span style=display:flex><span>  LogEvent(tid, pc)
</span></span><span style=display:flex><span>  new_shadow_word <span style=color:#f92672>=</span> ShadowWord(tid, CurrentClock(tid), addr, size, is_write, is_atomic)
</span></span><span style=display:flex><span>  stored <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>    raced <span style=color:#f92672>=</span> UpdateOneShadowState(thread_state, shadow_mem, i, new_shadow_word, stored)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> raced:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> stored:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Evict a random Shadow Word</span>
</span></span><span style=display:flex><span>    shadow_mem[Random(<span style=color:#ae81ff>4</span>)] <span style=color:#f92672>=</span> store_word <span style=color:#75715e># Atomic</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>UpdateOneShadowState</span>(shadow_mem, idx, new_shadow_word, stored):
</span></span><span style=display:flex><span> old_shadow_word <span style=color:#f92672>=</span> shadow_mem[idx] <span style=color:#75715e># Atomic</span>
</span></span><span style=display:flex><span> <span style=color:#75715e># The old state is empty</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> old_shadow_word <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> stored:
</span></span><span style=display:flex><span>     StoreIfNotYetStored(shadow_mem[idx], store_word)
</span></span><span style=display:flex><span>     stored <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span> <span style=color:#75715e># Is the memory access equal to the previous?</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> AccessedSameRegion(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> SameThreads(old_shadow_word, new_shadow_word): <span style=color:#75715e># same thread</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> IsRWWeakerOrEqual(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>       StoreIfNotYetStored(shadow_mem[idx], store_word)
</span></span><span style=display:flex><span>       stored <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> HappensBefore(old_shadow_word, thread_state):
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> IsBothReadsOrAtomic(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#75715e># race!</span>
</span></span><span style=display:flex><span>   ReportRace(old_shadow_word, new_shadow_word)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> true
</span></span><span style=display:flex><span> <span style=color:#75715e># Do the memory access intersect?</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> AccessedIntersectingRegions(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> SameThreads(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> IsBothReadsOrAtomic(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> HappensBefore(old_shadow_word, thread_state):
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>   <span style=color:#75715e># race!</span>
</span></span><span style=display:flex><span>   ReportRace(old_shadow_word, new_shadow_word)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> true
</span></span><span style=display:flex><span> <span style=color:#75715e># The accesses do not intersect, do nothing</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>StoreIfNotYetStored</span>(shadow_mem, store_word):
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>shadow_mem <span style=color:#f92672>=</span> store_word <span style=color:#75715e># Atomic</span>
</span></span><span style=display:flex><span>  store_word <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>IsRWWeakerOrEqual</span>(old_shadow_word, new_shadow_word):
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> (old_shadow_word<span style=color:#f92672>.</span>is_atomic <span style=color:#f92672>&gt;</span> new_shadow_word<span style=color:#f92672>.</span>is_atomic) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        (old_shadow_word<span style=color:#f92672>.</span>is_atomic <span style=color:#f92672>==</span> new_shadow_word<span style=color:#f92672>.</span>is_atomic <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>         <span style=color:#960050;background-color:#1e0010>!</span>old_shadow_word<span style=color:#f92672>.</span>is_write <span style=color:#f92672>&gt;=</span> <span style=color:#960050;background-color:#1e0010>!</span>new_shadow_word<span style=color:#f92672>.</span>is_write)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>HappensBefore</span>(old_shadow_word, thread_state):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> thread_state<span style=color:#f92672>.</span>vector_clock<span style=color:#f92672>.</span>get(old_shadow_word<span style=color:#f92672>.</span>tid) <span style=color:#f92672>&gt;=</span> old_shadow_word<span style=color:#f92672>.</span>epoch
</span></span></code></pre></div><h2 id=references>References</h2><ol><li><a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>Lamport, L., 1978. Time, clocks, and the ordering of events in a distributed system.Communications of the ACM,21(7), pp.558-565.</a></li><li><a href=https://users.soe.ucsc.edu/~cormac/papers/pldi09.pdf>Cormac Flanagan and Stephen N. Freund. 2009. FastTrack: efficient and precise dynamic race detection. (PLDI &lsquo;09)</a></li><li><a href="https://gcc.gnu.org/wiki/cauldron2012?action=AttachFile&amp;do=get&amp;target=kcc.pdf">Finding races and memory errors with GCC instrumentation. (GNU Tools Cauldron 2012)</a></li><li><a href=https://developers.google.com/google-test-automation-conference/2013/presentations-day2#Day2Presentation6>AddressSanitizer, ThreadSanitizer and MemorySanitizer &ndash; Dynamic Testing Tools for C++. (Google Test Automation Conference)</a></li><li><a href=https://en.wikipedia.org/wiki/Lamport_timestamp>https://en.wikipedia.org/wiki/Lamport_timestamp</a></li><li><a href=https://en.wikipedia.org/wiki/Vector_clock>https://en.wikipedia.org/wiki/Vector_clock</a></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/llvm/ rel=tag>LLVM</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/learn-comdat-with-inline-functions/>Learn COMDAT with inline functions</a></li><li class=widget__item><a class=widget__link href=/post/learn-relocation-by-debugging-a-hwasan-linker-error/>Learn Relocation by Debugging a HWASAN Linker Error</a></li><li class=widget__item><a class=widget__link href=/random/2023-5-15-a-whirlwind-tour-of-the-llvm-optimizer/>A whirlwind tour of the LLVM optimizer</a></li><li class=widget__item><a class=widget__link href=/post/hwasan-internals/>HWASAN Internals</a></li><li class=widget__item><a class=widget__link href=/post/inside-asan-allocator/>Inside AddressSanitizer Allocator</a></li><li class=widget__item><a class=widget__link href=/random/2022-12-31-summary/>2022 年度总结</a></li><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li><li class=widget__item><a class=widget__link href=/categories/random/>Random</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/paper-reading/ title="Paper Reading">Paper Reading</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>