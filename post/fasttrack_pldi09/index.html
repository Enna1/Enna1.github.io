<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>FastTrack: efficient and precise dynamic race detection - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="FastTrack: efficient and precise dynamic race detection"><meta property="og:description" content="根据 AddressSanitizer, ThreadSanitizer, and MemorySanitizer: Dynamic Testing Tools for C++ (GTAC'2013)，TSan V2 使用的 fast happens-before 算法，类似于 FastTrack(PLDI'09) 中提出的算法。
本文是对 FastTrack: efficient and precise dynamic race detection (PLDI'09) 这篇论文的学习笔记。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/fasttrack_pldi09/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-20T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><link rel=stylesheet href=/js/katex/katex.min.css><script src=/js/katex/katex.min.js></script><script src=/js/katex/contrib/auto-render.min.js></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>FastTrack: efficient and precise dynamic race detection</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-02-20T00:00:00Z>February 20, 2022</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#preliminaries>Preliminaries</a><ul><li><a href=#data-race>Data Race</a></li><li><a href=#concepts>Concepts</a></li></ul></li><li><a href=#vector-clock-and-djit-algorithm>Vector Clock and $DJIT^+$ Algorithm</a><ul><li><a href=#vector-clock>Vector Clock</a></li><li><a href=#djit-algorithm>$DJIT^+$ Algorithm</a></li></ul></li><li><a href=#fasttrack-algorithm>FastTrack Algorithm</a><ul><li><a href=#type-of-data-race>Type of Data Race</a></li><li><a href=#analysis-detail>Analysis Detail</a></li><li><a href=#algorithm-pseudo-code>Algorithm Pseudo Code</a></li><li><a href=#example>Example</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>根据 <a href=http://goo.gl/FPVd8>AddressSanitizer, ThreadSanitizer, and MemorySanitizer: Dynamic Testing Tools for C++ (GTAC'2013)</a>，TSan V2 使用的 fast happens-before 算法，<strong>类似</strong>于 FastTrack(PLDI'09) 中提出的算法。</p><p>本文是对 <a href=https://users.soe.ucsc.edu/~cormac/papers/pldi09.pdf>FastTrack: efficient and precise dynamic race detection (PLDI'09)</a> 这篇论文的学习笔记。</p><h2 id=preliminaries>Preliminaries</h2><h3 id=data-race>Data Race</h3><p>在 FastTrack(PLDI'09) 论文中，全文都用的是 race condition，根据 <a href=https://blog.regehr.org/archives/490>Race Condition vs. Data Race. EMBEDDED IN ACADEMIA</a> 中给出的关于 race condition 和 data race 的定义，该论文中应该实际指代的应该是 data race。本文全都使用 “data race” 。</p><p>首先看 data race 的定义：</p><ul><li><p>A race condition occurs when a program’s execution contains two accesses to the same memory location that are not ordered by the happens-before relation, where at least one of the accesses is a write. &mdash;&mdash; from FastTrack: efficient and precise dynamic race detection (PLDI'09)</p></li><li><p>A data race is a situation when two threads concurrently access a shared memory location and at least one of the accesses is a write. &mdash;&mdash; from ThreadSanitizer: data race detection in practice (WBIA’09)</p></li></ul><p>即，如果两个线程访问同一个内存位置 (memory location)，至少有一个访问是写操作，并且两个线程访问内存位置的访问顺序是不确定，则说明存在 data race。</p><p>举一个非常简单的 data race 的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> Global;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Thread1</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>x) {
</span></span><span style=display:flex><span>  Global<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Thread2</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>x) {
</span></span><span style=display:flex><span>  Global<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  pthread_t t[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>  pthread_create(<span style=color:#f92672>&amp;</span>t[<span style=color:#ae81ff>0</span>], NULL, Thread1, NULL);
</span></span><span style=display:flex><span>  pthread_create(<span style=color:#f92672>&amp;</span>t[<span style=color:#ae81ff>1</span>], NULL, Thread2, NULL);
</span></span><span style=display:flex><span>  pthread_join(t[<span style=color:#ae81ff>0</span>], NULL);
</span></span><span style=display:flex><span>  pthread_join(t[<span style=color:#ae81ff>1</span>], NULL);
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;%d&#34;</span>, Global);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行上述代码，输出是不确定的：有时候是 1，有时候是 2。</p><h3 id=concepts>Concepts</h3><p>一个程序中有很多个线程，每一个线程用 $t \in Tid$ 表示，这些线程读写的变量用 $x \in Var$ 表示，锁用 $m \in Lock$ 表示。</p><p>线程 $t$ 能执行的<strong>操作</strong>包括：</p><ul><li><p>$rd(t, x)$ 和 $wr(t, x)$ 分别表示 线程 $t$ 读 $x$，线程 $t$ 写 $x$</p></li><li><p>$acq(t, m)$ 和 $rel(t, m)$ 分别表示 获取锁 $m$，释放锁 $m$</p></li><li><p>$fork(t, u)$ 表示线程 $t$ fork 一个新的线程 $u$</p></li><li><p>$join(t, u)$ 表示线程 $t$ 阻塞直至线程 $u$ 终止执行</p></li></ul><p>happen-before 的定义（尝试用中文表述总觉得词不达意，摆烂直接用英文原文）：</p><p>A trace $\alpha$ captures an execution of a multithreaded program by listing the sequence of operations performed by the various threads.</p><p><strong>The happens-before relation</strong> $&lt;<em>\alpha$ for a trace $\alpha$ is the smallest transitively-closed relation over the operations in $\alpha$ such that the relation $a &lt;</em>\alpha b$ holds whenever $a$ occurs before $b$ in $\alpha$ and one of the following holds:</p><ul><li><p>Program order: The two operations are performed by the same thread.</p></li><li><p>Locking: The two operations acquire or release the same lock.</p></li><li><p>Fork-join: One operation is $fork(t, u)$ or $join(t, u)$ and the other operation is by thread $u$.</p></li></ul><p>如果 $a$ happens before $b$，那么 $b$ happens after $a$</p><p>如果两个线程访问同一个内存位置 (memory location)，至少有一个访问是写操作，并且这两个访问操作之间没有 happen-before 关系，那么说明这两个访存操作之间存在 data race。</p><h2 id=vector-clock-and-djit-algorithm>Vector Clock and $DJIT^+$ Algorithm</h2><h3 id=vector-clock>Vector Clock</h3><p>假设程序中有 n 个线程，每个线程都对应一个 n 个元素的 vector，称为 vector clock。</p><p>Vector clock 之间是存在偏序关系 $\sqsubseteq$ 的。</p><p>$\sqcup$ 表示两个 vector clock 之间的交汇 (join) 操作。</p><p>$\bot_C$ 表示最小的 vector clock 。</p><p>$inc_t$ 表示递增 vector clock 的表示线程 $t$ 的那个元素。</p><p>形式化表示如下：</p><ul><li><p>$C_1 \sqsubseteq C_2\quad\textbf{iff}\quad\forall t.;C_1(t) \leq C_2(t)$</p></li><li><p>$C_1 \sqcup C_2 \quad=\quad \lambda t.;max(C_1(t), C_2(t))$</p></li><li><p>$\bot_C \quad=\quad \lambda t.;0$</p></li><li><p>$inc_t(C)\quad=\quad\lambda u.;\textbf{if};u = t;\textbf{then};C(u)+1;\textbf{else};C(u)$</p></li></ul><hr><p>举个例子帮忙理解 vector clock 。</p><p>假设程序中有 2 个线程 $t_1$ 和 $t_2$ ，假设 $t_1$ 的 vector clock $C_1$ 为 $&lt;4, 0>$，$t_2$ 的 vector clock $C_2$ 为 $&lt;5, 8>$ 。</p><ul><li><p>因为 $4 \leq 5$ ，$0 \leq 8$ 所以 $C_1 \sqsubseteq C_2$</p></li><li><p>$C_1 \sqcup C_2 ;=;&lt;max(4, 5), max(0, 8)> ;=;&lt;5, 8>$</p></li><li><p>因为此例中只有 2 个线程所以 $\bot_C =; &lt;0, 0>$</p></li><li><p>$inc_{t1}(C_1) =; &lt;4+1, 0> ;=;&lt;5, 0>$，
$inc_{t2}(C_1);=;&lt;4, 0+1> ; =; &lt;4, 1>$，
$inc_{t1}(C_2);=;&lt;5+1, 8> ;=;&lt;6, 8>$，
$inc_{t2}(C_2);=;&lt;5, 8+1> ;=;&lt;5, 9>$</p></li></ul><h3 id=djit-algorithm>$DJIT^+$ Algorithm</h3><p>$DJIT^+$ Algorithm 就是基于 vector clock 来检测 data race 的：</p><ul><li><p>每个线程 $t$ 都对应一个 vector clock $\mathbb{C}_t$，对于任意一个线程 $u$， $\mathbb{C}_t(u)$ 记录了与线程 $t$ 的当前操作满足 happen-before 关系的线程 u 的上一次操作的 clock（如果把线程 $u$ 的上一次操作记为 $O_u$，把线程 $t$ 的当前操作记为 $O_t$，那么有 $O_u;\text{happen-before};O_t$）</p></li><li><p>每一个锁 $m$ 也对应一个 vector clock $\mathbb{L}_m$</p></li><li><p>每一个变量 $x$ 对应两个 vector clock $\mathbb{W}_x$ 和 $\mathbb{R}_x$。对于任意一个线程 $t$ ，$\mathbb{W}_x$ 和 $\mathbb{R}_x$ 记录了线程 $t$ 对变量 $x$ 的最后一次读/写的 clock</p><ul><li><p>线程 $t$ 对变量 $x$ 的读时，会将 $\mathbb{R}_x[t]$ 的值更新为 $\mathbb{C}_t(t)$ 的值</p></li><li><p>程序 $t$ 对变量 $x$ 的写时，会将 $\mathbb{W}_x[t]$ 的值更新为 $\mathbb{C}_t(t)$ 的值</p></li></ul></li><li><p>程序中执行同步和线程操作时，算法会更新相应的 vector clock：</p><ul><li><p>线程 $u$ 释放了锁 $m$，$DJIT^+$ 会先将 $\mathbb{L}_m$ 的值更新为 $\mathbb{C}_u$ 的值，再将 $\mathbb{C}_u$ 的值更新为 $inc_u(\mathbb{C}_u)$</p></li><li><p>线程 $t$ 获取了锁 $m$，$DJIT^+$ 会将 $\mathbb{C}_t$ 的值更新为 $\mathbb{C}_t \sqcup \mathbb{L}_m$ 的值。</p></li><li><p>$fork(t, u)$，$DJIT^+$ 会先将 $\mathbb{C}_u$ 的值更新为 $\mathbb{C}_u \sqcup \mathbb{C}_t$，再将 $\mathbb{C}_t$ 的值更新为 $inc_t(\mathbb{C}_t)$</p></li><li><p>$join(t, u)$，$DJIT^+$ 会先将 $\mathbb{C}_t$ 的值更新为 $\mathbb{C}_t\sqcup \mathbb{C}_u$，再将 $\mathbb{C}_u$ 的值更新为 $inc_u(\mathbb{C}_u)$</p></li></ul></li><li><p>如何判断是否存在 data race：</p><ul><li><p>假设当前线程 $u$ 读变量 $x$ ，如果 $\mathbb{W}_x \sqsubseteq \mathbb{C}_u$ 那么当前线程 $u$ 对变量 $x$ 的读则与之前其他线程对变量 $x$ 的写不存在 data race</p></li><li><p>假设当前线程 $u$ 写变量 $x$ ，如果 $\mathbb{W}_x \sqsubseteq \mathbb{C}_u$ 且 $\mathbb{R}_x \sqsubseteq \mathbb{C}_u$ 那么当前线程 u 对变量 $x$ 的写则与之前其他线程对变量 $x$ 的写和读不存在 data race</p></li></ul></li></ul><p>我们用如下例子来理解 $DJIT^+$ 是如何检测 data race 的：</p><p><img src=/blog/fasttrack_pldi09/Figure-1.png alt></p><p>如上图所示，程序中有两个线程，线程 0 和线程 1。线程 0 对应的 vector clock 为 $\mathbb{C}_0$，线程 1 对应的 vector clock 为 $\mathbb{C}_1$，锁 $m$ 对应的 vector clock 为 $\mathbb{L}_m$，并且我们用 vector clock $\mathbb{W}_x$ 来记录前一次对变量 $x$ 的写操作。</p><ol><li><p>初始状态时，$\mathbb{C}_0$ 为 &lt;4, 0>，$\mathbb{C}_1$ 为 &lt;0, 8>，$\mathbb{L}_m$ 为 &lt;0, 0>（即 $\bot_C$），$\mathbb{W}_x$ 为 &lt;0, 0>（即 $\bot_C$）</p></li><li><p>线程 0 写变量 $x$，vector clock $\mathbb{W}_x[0]$ 的值更新为 $\mathbb{C}_0[0]$ 的值，所以 $\mathbb{W}_x$ 的值由 &lt;0, 0>更新为 &lt;4, 0>，其余 vector clock 的值不变</p></li><li><p>线程 0 释放锁 $m$，vector clock $\mathbb{L}_m$ 的值更新为 $\mathbb{C}_0$ 的值 &lt;4, 0>，然后 vector clock $\mathbb{C}_0$ 的值更新为 $inc_0(\mathbb{C}_0)$ 即 &lt;5, 0>，其余 vector clock 的值不变</p></li><li><p>线程 1 获取锁 $m$，vector clock $\mathbb{C}_1$ 的值更新为 $\mathbb{C}_1 \sqcup \mathbb{L}_m$ 即 &lt;0, 8> $\sqcup$ &lt;4, 0> = &lt;4, 8>，其余 vector clock 的值不变</p></li><li><p>线程 1 写变量 $x$，由于 $\mathbb{C}_1$ 为 &lt;4, 8>，$\mathbb{W}_x$ 为 &lt;4, 0>，所以 $\mathbb{W}_x;\sqsubseteq;\mathbb{C}_1$，也就是说 $\mathbb{wr(0, x)};\text{happen-before};\mathbb{wr(1, x)}$，所以线程 1 写变量 $x$ 与线程 0 写变量 $x$ 之间没有 data race。最后还要更新 $\mathbb{W}_x[1]$ 为 $\mathbb{C}_1[1]$ ，即 $\mathbb{W}_x$ 的值由 &lt;4, 0> 变为 &lt;4, 8>，其余 vector clock 的值不变</p></li></ol><h2 id=fasttrack-algorithm>FastTrack Algorithm</h2><p>上述基于 vector clock 的 $DJIT^+$ Algorithm 的缺点就是性能开销。如果程序中有 n 个线程，那么每一个 vector clock 都需要 $O(n)$ 的空间，并且对 vector clock 的操作 (copying, comparing, joining, etc) 都要花费 $O(n)$ 的时间。</p><p><strong>key observation</strong>：作者通过收集大量的 Java 程序信息发现：在所有需要被 data race detector 监测的操作（$rd$, $wr$, $acq$, $rel$, $fork$, $join$, &mldr;）中，同步 (synchronization) 操作 (lock acquires and releases, forks, joins, waits, notifies, etc) 出现的次数只占很少的比例；而对数组和对象字段的读写则占了被监测操作的 96% 。</p><p><strong>key insight</strong>：超过 99% 的读写操作，我们并不需要使用 vector clock 来表示其 happen-before 关系，只需使用一种更轻量级 happen-before 表示方式即可，只在必要时 fallback 为 vector clock 。</p><p>还是用上面这个例子来进行说明，这次我们不再使用 vector clock 来记录每个线程对变量 $x$ 的写操作，只记录上一次是哪个线程写了变量 $x$ ：</p><p><img src=/blog/fasttrack_pldi09/Figure-2.png alt></p><p>我们把 clock $c$ 和 thread $t$ 组成的对组 (pair) 叫作 $epoch$，记作 $c@t$。epoch 与 vector clock 存在如下关系：$c@t \preceq C\quad\textbf{iff}\quad c \leq C(t)$ 。</p><p>在上面这个例子中，对于 $\mathbb{W}_x$ 我们只需要使用 $epoch$ 记录上一次是哪个线程写了变量 $x$ ：</p><ol><li><p>初始状态时，$\mathbb{C}_0$ 为 &lt;4, 0>，$\mathbb{C}_1$ 为 &lt;0, 8>，$\mathbb{L}_m$ 为 &lt;0, 0>（即 $\bot_C$），$\mathbb{W}_x$ 为 $\bot_e$</p></li><li><p>线程 0 写变量 $x$，将 epoch $\mathbb{W}_x$ 的值更新为 $4@0$，表示线程 0 在 clock 为 4 时写了变量 $x$</p></li><li><p>线程 0 释放锁 $m$，vector clock $\mathbb{L}_m$ 的值更新为 $\mathbb{C}_0$ 的值 &lt;4, 0>，然后 vector clock $\mathbb{C}_0$ 的值更新为 $inc_0(\mathbb{C}_0)$ 即 &lt;5, 0>，其余 vector clock 的值不变</p></li><li><p>线程 1 获取锁 $m$，vector clock $\mathbb{C}_1$ 的值更新为 $\mathbb{C}_1 \sqcup \mathbb{L}_m$ 即 &lt;0, 8> $\sqcup$ &lt;4, 0> = &lt;4, 8>，其余 vector clock 的值不变</p></li><li><p>线程 1 写变量 $x$，由于 $\mathbb{C}_1$ 为 &lt;4, 8>，$\mathbb{W}_x$ 为 $4@0$，所以有 $\mathbb{W}_x=4@0 \preceq;&lt;4,8>;=\mathbb{C}_1$，也就是说 $\mathbb{wr(0, x)};\text{happen-before};\mathbb{wr(1, x)}$，所以线程 1 写变量 $x$ 与线程 0 写变量 $x$ 之间没有 data race。最后还要更新 $\mathbb{W}_x$ 为 $8@1$，表示线程 1 在 clock 为 8 时写了变量 $x$，其余 vector clock 的值不变</p></li></ol><p>在这个例子中，我们用 epoch 来代替 vector clock $\mathbb{W}_x$ 后，在判断 $wr(1, x)$ 是否与 $wr(0, x)$ 之间存在 data race 时，将 $O(n)$ 的 vector clock 之间的比较操作 $\sqsubseteq$ 替换优化为了 $O(1)$ 的 epoch 与 vector clock 之间的比较操作 $\preceq$ 。</p><p>下面我们系统地学习一下 FastTrack Algorithm 是如何检测 data race 的。</p><h3 id=type-of-data-race>Type of Data Race</h3><p>data race 可以根据观测到的读写操作的先后顺序可以分为以下三类：</p><ul><li><p><strong>write-write</strong> data race。</p><p>对于 write-write 这种 data race，我们没有必要使用完整的 vector clock 记录所有线程对变量 $x$ 的写操作，只记录上一次是哪个线程写了变量 $x$ 就足够了。假设程序执行至某一时刻，对变量 $x$ 的读写操作还没有出现过 data race，那么所有对变量 $x$ 的写操作都是按照 happen-before 关系排序好的，所以为了检测后续对变量 $x$ 的写与之前对变量 $x$ 的写之间是否存在 write-write data race，我们需要记录的关键信息就是最近的一次对变量 $x$ 的写是在哪一 clock 由哪一 thread 完成的。如前所述，我们把 clock $c$ 和 thread $t$ 组成的对组 (pair) 叫作 $epoch$，记作 $c@t$。epoch 与 vector clock 存在如下关系：$c@t \preceq C\quad\textbf{iff}\quad c \leq C(t)$ 。所以检测是否存在 write-write data race，我们只需花费 $O(1)$ 的时间开销比较 epoch 与 vector clock 之间是否满足 $\preceq$ 关系即可。</p></li><li><p><strong>write-read</strong> data race</p><p>一旦我们用 epoch 来记录上一次对变量 $x$ 的写，检测是否存在 write-read data race 也变得非常简单。假设线程 $t$ 读变量 $x$ 时的 vector clock 是 $\mathbb{C}_t$，我们只需花费 $O(1)$ 的时间开销比较 $\mathbb{W}_x\preceq\mathbb{C}_t$ 是否满足，就可以判断上一次对变量 $x$ 的写操作是否 happen-before 这一次对变量 $x$ 的读操作，以检测是否存在 write-read data race 。</p></li><li><p><strong>read-write</strong> data race</p><p>与 write-write data race 和 write-read data race 的检测相比，read-write data race 的检测则相对复杂一些。因为在没有 data race 的程序中，对变量 $x$ 的多个读操作也可能是 concurrent 的。假设程序执行至某一个时刻，对变量 $x$ 的两个读操作 $rd(0, x)$ 和 $rd(1, x)$ 是 concurrent 的，即有可能 $rd(0, x)$ 先执行，也有可能 $rd(1, x)$ 先执行，那么就算我们知道 $wr(_, x);\text{happen-before};rd(0,x)$ ，我们也无法判断 $wr(_, x);\text{happen-before};rd(1,x)$ 是否成立。因此，我们需要使用完整的 vector clock $R_x$ 来记录对变量 $x$ 的读操作。</p><p>FastTrack 使用一种自适应的 (adaptive) 方式来记录对变量 $x$ 的读：如果当前对变量 $x$ 的读操作 happen-after 所有之前对变量 $x$ 的读操作，那么我们只需要使用 epoch 来记录这一次最新的对变量 $x$ 的读即可。如果对变量 $x$ 的读操作之间是 concurrent 的，我们转而使用 vector clock 来记录对变量 $x$ 的读操作。</p></li></ul><h3 id=analysis-detail>Analysis Detail</h3><p>FastTrack 是一个 online algorithm，对于被测程序，FastTrack 会维护一个程序状态 $\sigma$，每当程序执行一个操作 $a$ 时，FastTrack 会相应地更新状态：$\sigma \Rightarrow^a \sigma&rsquo;$ 。</p><p>$\sigma=(C,L,R,W)$ 是一个四元组：</p><ul><li><p>$C_t$ 表示当前线程 $t$ 的 vector clock</p></li><li><p>$L_m$ 表示上一次释放锁 $m$ 对应的 vector clock</p></li><li><p>$R_x$ 表示上一次对变量 $x$ 读对应的 epoch 或 vector clock</p></li><li><p>$W_x$ 表示上一次对变量 $x$ 写对应的 epoch</p></li></ul><p>状态 $\sigma$ 的初始值为：</p><p>$\sigma_0 = (\lambda t. inc_t(\bot_V), \lambda m.\bot_V, \lambda x.\bot_e, \lambda x.\bot_e)$</p><p>$E(t)$ 表示线程 $t$ 的当前 epoch $c@t$，其中 $c=C_t(t)$ 即线程 $t$ 的当前 clock 。</p><p>$R$ 是一个函数，$R_x$ 是 $R(x)$ 的缩写，$R[x := V ]$ 表示将 $R(x)$ 修改为 $V$，其余部分不变。</p><p>下图详细给出了针对不同的操作，FastTrack 是如何更新程序状态 $\sigma$（在每种操作的右边同时给出了作者在 benchmarks 中观察到的不同操作的出现占比）：</p><p><img src=/blog/fasttrack_pldi09/Figure-3-FastTrackAlgo.png alt></p><h4 id=read-operations>Read Operations</h4><p>Read Operations 又细分为 4 条规则：</p><ul><li><p><strong>[FT READ SAME EPOCH]</strong></p><p>此时程序执行的操作是 $rd(t, x)$，即线程 $t$ 读变量 $x$。如果 $R_x = E(t)$，即前一次对变量 $x$ 读与这一次对变量 $x$ 读，是同一个线程在同一 clock 时刻对变量 $x$ 读，那么不用更新程序状态 $\sigma$</p></li><li><p><strong>[FT READ SHARED]</strong></p><p>此时程序执行的操作是 $rd(t, x)$，即线程 $t$ 读变量 $x$。如果此时 $R_x$ 已经是用 vector clock 表示的 ($R_x \in VC$)，并且前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的读 ($W_x \preceq C_t$)，那么我们只需要把 vector clock $R_x$ 中线程 $t$ 的那部分更新为 $C_t(t)$ 即可，形式化表示 $R&rsquo; = R[x:=R_x(t:=C_t(t))]$</p></li><li><p><strong>[FT READ EXCLUSIVE]</strong></p><p>此时程序执行的操作是 $rd(t, x)$，即线程 $t$ 读变量 $x$。如果此时 $R_x$ 是用 epoch 表示的 ($R_x \in Epoch$)，并且前一次对变量 $x$ 的读 happen-before 此时线程 $t$ 对变量 $x$ 的读 ($$R_x \preceq C_t$)，前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的读 ($W_x \preceq C_t$)，那么我们只需更新 epoch $R_x$ 为 $E(t)$ 即可。$E(t)$ 表示线程 $t$ 的当前 epoch $c@t$，其中 $c=C_t(t)$ 即线程 $t$ 的当前 clock</p></li><li><p><strong>[FT READ SHARE]</strong></p><p>此时程序执行的操作是 $rd(t, x)$，即线程 $t$ 读变量 $x$。如果此时 $R_x$ 是用 epoch 表示的 ($R_x = c@u$)，并且前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的读 ($W_x \preceq C_t$)，但是前一次对变量 $x$ 的读与此时线程 $t$ 对变量 $x$ 的读没有 happen-before 关系 ($$R_x \preceq C_t$)，那么我们需把 epoch $R_x$ 转换为 vector clock $R_x$，线程 $u$ 的 clock 是 c，线程 t 的 clock 是 $C_t(t)$。形式化表示 $V=\bot_V[t:=C_t(t), u:=c], R&rsquo;=R[x:=V]$</p></li></ul><h4 id=write-operations>Write Operations</h4><ul><li><p><strong>[FT WRITE SAME EPOCH]</strong></p><p>此时程序执行的操作是 $wr(t, x)$，即线程 $t$ 写变量 $x$。如果 $W_x = E(t)$，即前一次对变量 $x$ 写与这一次对变量 $x$ 写，是同一个线程在同一 clock 时刻对变量 $x$ 写，那么不用更新程序状态 $\sigma$。</p></li><li><p><strong>[FT WRITE EXCLUSIVE]</strong></p><p>此时程序执行的操作是 $wr(t, x)$，即线程 $t$ 写变量 $x$。如果此时 $R_x$ 是用 epoch 表示的 ($R_x \in Epoch$)，并且前一次对变量 $x$ 的读 happen-before 此时线程 $t$ 对变量 $x$ 的写 ($R_x \preceq C_t$)，前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的写 ($W_x \preceq C_t$)，那么我们只需要把 epoch $W_x$ 中更新为 $E_t(t)$ 即可，形式化表示 $W&rsquo; = W[x:=E(t)]$</p></li><li><p><strong>[FT WRITE SHARED]</strong></p><p>此时程序执行的操作是 $wr(t, x)$，即线程 $t$ 写变量 $x$。如果此时 $R_x$ 已经是用 vector clock 表示的 ($R_x \in VC$)，并且前面所有对变量 $x$ 的读 happen-before 此时线程 $t$ 对变量 $x$ 的写 ($R_x \sqsubseteq C_t$)，前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的写 ($W_x \preceq C_t$)，那么我们把 epoch $W_x$ 中更新为 $E(t)$ ，并且把 $R_x$ 更新为 $\bot_e$ 。</p><p>将 $R_x$ 更新为 $\bot_e$ 是因为后续对变量 $x$ 的写操作不可能与此时 $R_x$ 中记录的对变量 $x$ 的写操作有 data race 了，所以我们无需再记录之前对变量 $x$ 的写了。</p><p>形式化表示 $W&rsquo; = W[x:=E(t)], R&rsquo;= R[x:=\bot_e]$</p></li></ul><h4 id=other-operations>Other Operations</h4><p>Other operations包括 acquire, release, fork 和 join，FastTrack algorithm 对这些操作的处理与 $DJIT^+$ algorithm 类似：</p><ul><li><p><strong>[FT ACQUIRE]</strong></p><p>此时程序执行的操作是 $acq(t, m)$，线程 $t$ 获取了锁 $m$ 。将 $C_t$ 的值更新为 $C_t \sqcup L_m$ 的值</p></li><li><p><strong>[FT RELEASE]</strong></p><p>此时程序执行的操作是 $rel(t, m)$，线程 $t$ 释放了锁 $m$ 。将 $L_m$ 的值更新为 $C_t$ 的值，再将 $C_t$ 的值更新为 $inc_t(C_t)$</p></li><li><p><strong>[FT FORK]</strong></p><p>此时程序执行的操作是 $fork(t, u)$ 。先将 $C_u$ 的值更新为 $C_u \sqcup C_t$，再将 $C_t$ 的值更新为 $inc_t(C_t)$</p></li><li><p><strong>[FT JOIN]</strong></p><p>此时程序执行的操作是 $join(t, u)$ 。先将 $C_t$ 的值更新为 $C_t\sqcup C_u$，再将 $C_u$ 的值更新为 $inc_u(C_u)$</p></li></ul><h3 id=algorithm-pseudo-code>Algorithm Pseudo Code</h3><p>FastTrack Algorithm 的伪代码实现如下，就是对上一节 Analysis Detail 的实现，此处不再赘述：</p><p><img src=/blog/fasttrack_pldi09/Figure-4-FastTrackAlgoCode.png alt></p><h3 id=example>Example</h3><p>最后，我们再用一个例子来理解 FastTrack 是如何检测 data race 的：</p><p><img src=/blog/fasttrack_pldi09/Figure-5.png alt></p><p>初始状态时，$W_x$ 和 $R_x$ 都是 $\bot_e$ ，表示变量 $x$ 还没有被写和读过。</p><ol><li><p>线程 0 写变量 $x$，epoch $W_x$ 的值更新为线程 0 的当前 epoch $c@t$，即 $7@0$</p></li><li><p>$fork(0, 1)$ 。先将 $C_1$ 的值更新为 $C_1 \sqcup C_0$ 即 &lt;7,1>，再将 $C_0$ 的值更新为 $inc_0(C_0)$ 即 &lt;8, 0></p></li><li><p>线程 1 读变量 $x$，因为前一次对变量 $x$ 的写 happen-before 此时线程 1 对变量 $x$ 的读 ($W_x=7@0\preceq;&lt;7,1>;=C_1$)，所有没有 write-read data race。 因为之前 $R_x$ 是 $\bot_e$，所以只需要用 epoch 来表示 $R_x$ 即可，将 $R_x$ 的值更新为线程 1 的当前 epoch $c@t$，即 $1@1$</p></li><li><p>线程 0 读变量 $x$，因为前一次对变量 $x$ 的写 happen-before 此时线程 0 对变量 $x$ 的读 ($W_x=7@0\preceq;&lt;8,0>;=C_0$)，所有没有 write-read data race。但是前一次对变量 $x$ 的读与此时线程 0 对变量 $x$ 的读没有 happen-before 关系 ($R_x =1@1\npreceq;&lt;8,0>;=C_0$) 。所以需要用 vector clock 替代 epoch 来表示 $R_x$ ，将 $R_x$ 的值更新为 &lt;8, 1></p></li><li><p>线程 1 读变量 $x$，因为前一次对变量 $x$ 的写 happen-before 此时线程 1 对变量 $x$ 的读 ($W_x=7@0\preceq;&lt;7,1>;=C_1$)，所以没有 write-read data race。 因为 $R_x$ 已经是是 vector clock 表示了，所以只需要把 vector clock $R_x$ 中线程 1 的那部分更新为 $C_1(1)$ 即可。因为 $R_x(1)$ 是 1，$C_1(1)$ 也是 1，vector clock $R_x$ 更新前后都是 &lt;8, 1></p></li><li><p>$join(0, 1)$，先将 $C_0$ 的值更新为 $C_0 \sqcup C_1$ 即 &lt;8,1>，再将 $C_1$ 的值更新为 $inc_1(C_1)$ 即 &lt;7, 2></p></li><li><p>线程 0 写变量 $x$，此时 $R_x$ 已经是用 vector clock 表示的，并且前面所有对变量 $x$ 的读 happen-before 此时线程 0 对变量 $x$ 的写，没有 read-write data race ($R_x=;&lt;8,1>;\sqsubseteq;&lt;8,1>;=C_0$)，前一次对变量 $x$ 的写 happen-before 此时线程 $t$ 对变量 $x$ 的写，没有 write-write data race ($W_x =7@0\preceq;&lt;8,1>=C_0$)，我们把 $W_x$ 中更新为线程 0 的当前 epoch即 $8@0$ ，并且把 $R_x$ 更新为 $\bot_e$ 。</p></li><li><p>线程 0 读变量 $x$，因为前一次对变量 $x$ 的写 happen-before 此时线程 0 对变量 $x$ 的读 ($W_x=8@0\preceq;&lt;8,1>;=C_0$)，所以没有 write-read data race。 因为之前 $R_x$ 是 $\bot_e$，所以只需要用 epoch 来表示 $R_x$ 即可，将 $R_x$ 的值更新为线程 0 的当前 epoch $c@t$，即 $8@0$</p></li></ol><p>最终 FastTrack 发现程序中没有 data race 。</p><h2 id=conclusions>Conclusions</h2><p>本文是对知名的 data race 检测算法 FastTrack 的学习笔记。</p><p>FastTrack 算法是对 $DJIT^+$ 算法的一个优化，本质上都是基于 vector clock 检测 data tace 的，FastTrack 通过（在某些情况下）使用 epoch 代替 vector clock 来获得更好的空间复杂度和时间复杂度。</p><p>最后说一下，由于手工验证 data race detector 检测出来的 data race 是不是误报是非常困难的，所以对于 data race 的检测，我们希望 data race detector 报告出来的 data race 都是真的，而不是误报。在实践中，我们通常会用动态分析来做 data race 的检测，保证没有误报，比如 TSan 就是 data race 的动态分析工具。</p><p>理解了 FastTrack 算法后，再去阅读 TSan 源码，理解 TSan 背后的算法就会变得容易些。下一篇文章就是 ThreadSanitizer 底层算法的基本原理。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/data-race/ rel=tag>Data Race</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-runtime-init/>How Sanitizer Runtime Initialized</a></li><li class=widget__item><a class=widget__link href=/post/gwp-asan-internals/>GWP-ASan Internals</a></li><li class=widget__item><a class=widget__link href=/post/dumb-sanitizer-howto/>How To Write A Dumb Sanitizer</a></li><li class=widget__item><a class=widget__link href=/post/treeclock_asplos22/>A Tree Clock Data Structure for Causal Orderings in Concurrent Executions</a></li><li class=widget__item><a class=widget__link href=/post/fasttrack_pldi09/>FastTrack: efficient and precise dynamic race detection</a></li><li class=widget__item><a class=widget__link href=/post/slp-vectorizer_pldi00/>Exploiting Superword Level Parallelism with Multimedia Instruction Sets</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2022 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>