<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Inside AddressSanitizer Allocator - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Inside AddressSanitizer Allocator"><meta property="og:description" content="本文深入分析了 AddressSanitizer Allocator 的实现。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/inside-asan-allocator/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-26T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/random/><span class=menu__text>random</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Inside AddressSanitizer Allocator</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-02-26T00:00:00Z>February 26, 2023</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#memory-chunk>Memory Chunk</a></li><li><a href=#size-class>Size Class</a><ul><li><a href=#allocationsize-to-classid>AllocationSize To ClassId</a></li><li><a href=#classid-to-allocationsize>ClassId To AllocationSize</a></li></ul></li><li><a href=#asanthreadlocalmallocstorage>AsanThreadLocalMallocStorage</a></li><li><a href=#primaryallocatorsizeclassallocator64>PrimaryAllocator(SizeClassAllocator64)</a></li><li><a href=#secondaryallocatorlargemmapallocator>SecondaryAllocator(LargeMmapAllocator)</a></li><li><a href=#the-flow-of-asan_allocate>The flow of asan_allocate()</a></li><li><a href=#the-flow-of-asan_deallocate>The flow of asan_deallocate()</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>本文深入分析了 AddressSanitizer Allocator 的实现。</p><p>AddressSanitizer 通过 intercept malloc/free, new/delete 的调用，使得开启 ASan 后程序的内存分配和释放都由 ASan allocator 负责，本文深入分析了 AddressSanitizer Allocator 的实现。</p><p>ASan allocator 与其他 allocator 有一些明显不同的点，例如：</p><ul><li><p>为了检测 heap-buffer-overflow，ASan allocator 在分配内存时会在用户申请的内存左右两侧多申请内存作为 redzone，这样一旦访问到 redzone 就说明发生了溢出，这样 ASan 就检测到了 heap-buffer-overflow。</p></li><li><p>为了检测 heap-use-after-free, double-free，程序调用 free/delete 释放内存时，ASan allocator 并不会真正释放内存，而是先将其放入暂存区 quarantine，当 quarantine 满了以后才会去真正释放以前被放入 quarantine 的内存。这样一旦访问了已释放的内存，只要该已释放的内存还处于 quarantine 中，ASan 就能检测到发生了 heap-use-after-free。</p></li></ul><h2 id=memory-chunk>Memory Chunk</h2><p>每当调用 malloc 或 new 申请一块内存时，ASan allocator 真正申请的内存大小是比用户请求的内存大小更大的。这是因为：一方面需要额外的内存来保存一些信息，如：用户申请内存的大小、申请内存时的 stacktrace 等；另一方面也需要在用户申请的内存左右两侧多申请内存作为 redzone，用于检测 heap-buffer-overflow bug。</p><p>我们将 ASan allocator 实际申请的内存块称为 memory chunk。由 ASan allocator 分配得到的 memory chunk 的布局如下所示：</p><pre tabindex=0><code> L L L L L L H H U U U U U U R R
   L -- left redzone words (0 or more bytes)
   H -- ChunkHeader (16 bytes), which is also a part of the left redzone.
   U -- user memory.
   R -- right redzone (0 or more bytes)
</code></pre><p>如上所示，memory chunk 中返回给用户使用的内存称为 user memory。ASan allocator 额外申请的紧邻 user memory 左右两侧的额外内存就是 redzone。</p><ul><li><p>left redzone 的最后 16 bytes 同时作为 ChunkHeader，存储一些当前 chunk 的状态，如：用户申请的内存大小、申请内存时的 stacktrace 等。因此 left redzone 最小为 16-bytes，即 ChunkHeader 的大小。</p></li><li><p>right redzone 最小为 0-bytes，即存在没有 right redzone 的情况。具体什么情况需要 right redzone、什么情况不需要 right redzone，本文靠后内容会详细说明。</p></li></ul><p>当 left redzone 的大小大于 ChunkHeader 的大小（即 16-bytes）时，ASan allocator 会将 magic value: kAllocBegMagic 存储到 memory chunk 的第一个 8-bytes 中，将 ChunkHeader 的地址保存在 memory chunk 的第二个 8-bytes 中：</p><pre tabindex=0><code> M B L L L L L L L L L  H H U U U U U U
   |                    ^
   ---------------------|
   M -- magic value kAllocBegMagic
   B -- address of ChunkHeader pointing to the first &#39;H&#39;
</code></pre><p>ChunkHeader 的代码实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChunkHeader</span> {
</span></span><span style=display:flex><span>  atomic_uint8_t chunk_state;
</span></span><span style=display:flex><span>  u8 alloc_type : <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  u8 lsan_tag : <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// align &lt; 8 -&gt; 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// else      -&gt; log2(min(align, 512)) - 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  u8 user_requested_alignment_log : <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  u16 user_requested_size_hi;
</span></span><span style=display:flex><span>  u32 user_requested_size_lo;
</span></span><span style=display:flex><span>  atomic_uint64_t alloc_context_id;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kChunkHeaderSize <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(ChunkHeader);
</span></span><span style=display:flex><span>COMPILER_CHECK(kChunkHeaderSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>);
</span></span></code></pre></div><ul><li><p>chunk_state 顾名思义表示 chunk 的状态，有 3 种可能取值：</p><ul><li><p>CHUNK_INVALID: either just allocated by underlying allocator, but chunk is not yet ready, or almost returned to undelying allocator and chunk is already meaningless.</p></li><li><p>CHUNK_ALLOCATED: the chunk is allocated and not yet freed.</p></li><li><p>CHUNK_QUARANTINE: the chunk was freed and put into quarantine zone.</p></li></ul></li><li><p>alloc_type 有 3 种可能取值：</p><ul><li><p>FROM_MALLOC：表示当前 chunk 是通过 <code>malloc</code>, <code>calloc</code>, <code>realloc</code> 申请的</p></li><li><p>FROM_NEW：表示当前 chunk 是通过 <code>operator new</code> 申请的</p></li><li><p>FROM_NEW_BR：表示当前 chunk 是通过 <code>operator new[]</code> 申请的</p></li></ul></li><li><p>lsan_tag 是 LeakSanitizer 用的，本文不涉及</p></li><li><p>user_requested_alignment_log 用于表示用户申请的内存指定的对齐 alignment</p></li><li><p>user_requested_size_hi, user_requested_size_lo 用于表示用户申请的内存大小 size</p></li><li><p>alloc_context_id 保存的是申请内存的线程 id 和 stacktrace。关于 sanitizer 是是如何获取和保存 stack trace 的，可以参考 <a href=https://enna1.github.io/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace - Enna1&rsquo;s website</a></p></li></ul><hr><p>当应用程序申请一块内存时，ASan allocator 需要计算为 user memory 添加 redzone 后所需要的内存大小 needed_size，伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>uptr <span style=color:#a6e22e>ComputeNeededSize</span>(uptr size, uptr alignment) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> uptr min_alignment <span style=color:#f92672>=</span> ASAN_SHADOW_GRANULARITY;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (alignment <span style=color:#f92672>&lt;</span> min_alignment)
</span></span><span style=display:flex><span>      alignment <span style=color:#f92672>=</span> min_alignment;
</span></span><span style=display:flex><span>  uptr rz_log <span style=color:#f92672>=</span> ComputeRZLog(size);
</span></span><span style=display:flex><span>  uptr rz_size <span style=color:#f92672>=</span> RZLog2Size(rz_log);
</span></span><span style=display:flex><span>  uptr rounded_size <span style=color:#f92672>=</span> RoundUpTo(Max(size, kChunkHeader2Size), alignment);
</span></span><span style=display:flex><span>  uptr needed_size <span style=color:#f92672>=</span> rounded_size <span style=color:#f92672>+</span> rz_size;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (alignment <span style=color:#f92672>&gt;</span> min_alignment)
</span></span><span style=display:flex><span>      needed_size <span style=color:#f92672>+=</span> alignment;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>PrimaryAllocator<span style=color:#f92672>::</span>CanAllocate(needed_size, alignment))
</span></span><span style=display:flex><span>      needed_size <span style=color:#f92672>+=</span> rz_size;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> needed_size;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><p>首先根据用户申请的内存大小计算所需的 redzone 大小 rz_size。基本逻辑是用户申请的内存越大，则对应的 redzone 就越大。并且如前所述， rz_size 最小就是 ChunkHeader 的大小 16-bytes。</p></li><li><p>计算 rounded_size 是将 <code>Max(size, kChunkHeader2Size)</code> 对齐至 alignment，这是因为：对于已经释放的内存，ASan 需要像用 <code>atomic_uint64_t alloc_context_id</code> 保存申请内存的线程 id 和 stacktrace 一样，使用 <code>atomic_uint64_t free_context_id</code> 记录释放内存的线程 id 和 stacktrace。通过 <code>Max(size, kChunkHeader2Size)</code> 使得 chunk 中 user memory 的大小至少为 kChunkHeader2Size，这样 ASan 就可以通过复用 user memory 来保存 free_context_id 了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChunkBase</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ChunkHeader {
</span></span><span style=display:flex><span>  atomic_uint64_t free_context_id;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kChunkHeader2Size <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(ChunkBase) <span style=color:#f92672>-</span> kChunkHeaderSize;
</span></span><span style=display:flex><span>COMPILER_CHECK(kChunkHeader2Size <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>16</span>);
</span></span></code></pre></div></li><li><p><code>if (!PrimaryAllocator::CanAllocate()) needed_size += rz_size;</code> ASan allocator 由 PrimaryAllocator 和 SecondaryAllocator 组成，优先从 PrimaryAllocator 中分配内存。由 PrimaryAllocator 分配的 chunk 只有 left redzone 没有 right redzone，这是因为 PrimaryAllocator 保证相同大小的 chunk 是相邻分布的，所以对于当前 chunk，可以使用相邻的右侧 chunk 的 left redzone 作为当前 chunk 的 right redzone。而 SecondaryAllocator 则没有这个保证，所以需要额外申请 rz_size 大小内存作为 right redzone。</p></li></ol><h2 id=size-class>Size Class</h2><p>应用程序在申请内存时，ASan allocator 首先会计算添加 redzone 后所需要的内存大小 needed_size，如果小于等于 128KB，那么会由 PrimaryAllocator 进行分配。PrimaryAllocator 将分配的内存大小划分为了 53 个类别，称为 <strong>size class</strong>，每个 size class 都对应一个大小，比如 16-bytes, 32-bytes, 48-bytes。PrimaryAllocator 在真正申请内存时会 needed_size 向上取整到 size class 的大小，例如应用程序申请 8-bytes 的内存，添加 redzone 后所需要的内存大小 needed_size 为 24-bytes，然后会将 24-bytes RoundUp 到最近的 size class 2 对应的大小 32-bytes，最终 PrimaryAllocator 在真正申请内存时申请的大小是 32-bytes。</p><p>SizeClassMap 用于将 allocation sizes 映射到对应的 size class，以及根据 size class 得到其对应的 allocation size。SizeClassMap 在代码实现时被实现为一个模版类，包含以下模版参数：</p><ul><li><p>kMinSizeLog: defines the class 1 as 2^kMinSizeLog.</p></li><li><p>kMaxSizeLog: defines the last class as 2^kMaxSizeLog.</p></li><li><p>kMidSizeLog: the classes starting from 1 increase with step 2^kMinSizeLog until 2^kMidSizeLog.</p></li><li><p>kNumBits: the number of non-zero bits in sizes after 2^kMidSizeLog.
E.g. with kNumBits==3 all size classes after 2^kMidSizeLog look like 0b1xx0..0, where x is either 0 or 1.</p></li></ul><p>ASan 使用的 SizeClassMap 模版参数为：kNumBits=3, kMinSizeLog=4, kMidSizeLog=8, kMaxSizeLog=17，具体的 size class 和 allocation size 的对应关系如下表：</p><table><thead><tr><th>size class</th><th>allocation size (bytes)</th><th></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Class 0 always corresponds to size 0</td></tr><tr><td>1</td><td>16</td><td>KMinSize (2^kMinSizeLog = 2^4 = 16)</td></tr><tr><td>2</td><td>32</td><td>diff: +16</td></tr><tr><td>3</td><td>48</td><td></td></tr><tr><td>4</td><td>64</td><td></td></tr><tr><td>5</td><td>80</td><td></td></tr><tr><td>6</td><td>96</td><td></td></tr><tr><td>7</td><td>112</td><td></td></tr><tr><td>8</td><td>128</td><td></td></tr><tr><td>9</td><td>144</td><td></td></tr><tr><td>10</td><td>160</td><td></td></tr><tr><td>11</td><td>176</td><td></td></tr><tr><td>12</td><td>192</td><td></td></tr><tr><td>13</td><td>208</td><td></td></tr><tr><td>14</td><td>224</td><td></td></tr><tr><td>15</td><td>240</td><td></td></tr><tr><td>16</td><td>256</td><td>KMidSize = 2^KMidSizeLog = 2^8 = 256 = 0b100000000</td></tr><tr><td>17</td><td>320</td><td>diff: +64, 320 = 0b101000000</td></tr><tr><td>18</td><td>384</td><td>diff: +64, 384 = 0b110000000</td></tr><tr><td>19</td><td>448</td><td>diff: +64, 448 = 0b111000000</td></tr><tr><td>20</td><td>512</td><td>diff: +64, 512 = 0b1000000000</td></tr><tr><td>21</td><td>640</td><td>diff: +128, 640 = 0b1010000000</td></tr><tr><td>22</td><td>768</td><td>diff: +128, 768 = 0b1100000000</td></tr><tr><td>23</td><td>896</td><td>diff: +128, 896 = 0b1110000000</td></tr><tr><td>24</td><td>1024</td><td>diff: +128, 1024 = 0b10000000000</td></tr><tr><td>25</td><td>1280</td><td>diff: +256, 1280 = 0b10100000000</td></tr><tr><td>26</td><td>1536</td><td>diff: +256, 1536 = 0b11000000000</td></tr><tr><td>27</td><td>1792</td><td>diff: +256, 1792 = 0b11100000000</td></tr><tr><td>&mldr;</td><td></td><td></td></tr><tr><td>52</td><td>131072</td><td>kMaxSize = 2^kMaxSizeLog = 2^17 = 131072</td></tr></tbody></table><h3 id=allocationsize-to-classid>AllocationSize To ClassId</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMinSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> kMinSizeLog;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMidSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> kMidSizeLog;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMidClass <span style=color:#f92672>=</span> kMidSize <span style=color:#f92672>/</span> kMinSize;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr S <span style=color:#f92672>=</span> kNumBits <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr M <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> S) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> uptr <span style=color:#a6e22e>ClassID</span>(uptr size) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (UNLIKELY(size <span style=color:#f92672>&gt;</span> kMaxSize))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;=</span> kMidSize)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> (size <span style=color:#f92672>+</span> kMinSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&gt;&gt;</span> kMinSizeLog;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> uptr l <span style=color:#f92672>=</span> MostSignificantSetBitIndex(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> uptr hbits <span style=color:#f92672>=</span> (size <span style=color:#f92672>&gt;&gt;</span> (l <span style=color:#f92672>-</span> S)) <span style=color:#f92672>&amp;</span> M;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> uptr lbits <span style=color:#f92672>=</span> size <span style=color:#f92672>&amp;</span> ((<span style=color:#ae81ff>1U</span> <span style=color:#f92672>&lt;&lt;</span> (l <span style=color:#f92672>-</span> S)) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> uptr l1 <span style=color:#f92672>=</span> l <span style=color:#f92672>-</span> kMidSizeLog;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> kMidClass <span style=color:#f92672>+</span> (l1 <span style=color:#f92672>&lt;&lt;</span> S) <span style=color:#f92672>+</span> hbits <span style=color:#f92672>+</span> (lbits <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li><p>当 AllocationSize &lt;= kMidSize 时，SizeClass 对应的 AllocationSize 都是以 kMinSize=2^kMinSizeLog=16 的 step 进行增长的，所以我们可以通过 <code>(size + kMinSize - 1) >> kMinSizeLog</code> 得到 AllocationSize 对应的 SizeClass 大小。</p><p>例如：AllocationSize 为 160 时，对应的 SizeClass 为 <code>(160 + 16 - 1) >> 4</code> 即 10。</p></li><li><p>当 AllocationSize > KMidSize 时，计算 AllocationSize 对应的 SizeClass 稍显复杂。</p><p>首先我们需要明确 AllocationSize > KMidSize 时，AllocationSize 的增长方式：因为 kNumBits=3，所以 kMidSize=256 之后的 AllocationSize 的二进制表示都是形如 0b1xx0..0，x 的可能取值是 0 或 1。kMidSize=256，二进制表示为 0b100000000，所以 256 后面紧跟的 4 个 AllocationSize 分别是 0b<strong>101</strong>000000, 0b<strong>110</strong>000000, 0b<strong>111</strong>000000, 0b<strong>1000</strong>000000。</p><p>从 KMidSize=256 开始，每隔 2^(kNumBits-1)=4 个 SizeClass，AllocationSize 的最高有效位会左移一次。</p><ul><li><p>SizeClass: 16, AllocationSize=0b100000000</p></li><li><p>SizeClass: 17, AllocationSize=0b101000000</p></li><li><p>SizeClass: 18, AllocationSize=0b110000000</p></li><li><p>SizeClass: 19, AllocationSize=0b111000000</p></li><li><p>SizeClass: 20, AllocationSize=0b1000000000</p></li></ul><p>所以对于一个给定的 AllocationSize=0b1xx0..0 来说，我们可以将它拆分成两部分：<code>AllocationSize = 0b1xx0..0 = 0b1000..0 + 0b0xx0..0</code>，我们将 0b<strong>1</strong>000..0 记作 AllocationSizeBase，将 0b0<strong>xx0.00</strong> 记作 AllocationSizeOffset。</p><ol><li><p>首先计算其 AllocationSize 最高有效位的下标索引，其最高有效位的位置相比 KMidSize 的最高有效位的位置左移了 x 位，那么 AllocationSizeBase 所对应的 SizeClass 就是 kMidClass + x * 2^(kNumBits-1)</p></li><li><p>然后再看 AllocationSize 最高有效位后的 kNumBits - 1 位，该 kNumBits - 1 位构成的数与 (2^(kNumBits-1) - 1) 做<strong>与运算</strong>得到的值就是给定的 AllocationSize 相比 AllocationSizeBase 又增加了几个 SizeClass</p></li></ol><p>我们以 AllocationSize 为 640 为例进行说明：</p><ol><li><p>640=0b1010000000，最高有效位是第 9 位；KMidSize = 256 = 0b100000000，其最高有效位是第 8 位，那么 0b1000000000 = 512 对应的 ClassId 就是 kMidClass + (9 - 8) * 2^(kNumBits-1) = 16 + 1 * 2^(3-1) = 20</p></li><li><p>640=0b1010000000，最高有效位后的 kNumBit-1=2 位就是 0b01，0b01 & (2^(kNumBits-1) - 1) = 0b01 & 3 = 1</p></li><li><p>所以 AllocationSize = 640 对应的 ClassId 就是 20 + 1 = 21</p></li></ol></li></ul><h3 id=classid-to-allocationsize>ClassId To AllocationSize</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMinSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> kMinSizeLog;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMidSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> kMidSizeLog;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr kMidClass <span style=color:#f92672>=</span> kMidSize <span style=color:#f92672>/</span> kMinSize;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr S <span style=color:#f92672>=</span> kNumBits <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> uptr M <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> S) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> uptr <span style=color:#a6e22e>Size</span>(uptr class_id) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Estimate the result for kBatchClassID because this class does not know
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the exact size of TransferBatch. It&#39;s OK since we are using the actual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// sizeof(TransferBatch) where it matters.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (UNLIKELY(class_id <span style=color:#f92672>==</span> kBatchClassID))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> kMaxNumCachedHint <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(uptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (class_id <span style=color:#f92672>&lt;=</span> kMidClass)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> kMinSize <span style=color:#f92672>*</span> class_id;
</span></span><span style=display:flex><span>    class_id <span style=color:#f92672>-=</span> kMidClass;
</span></span><span style=display:flex><span>    uptr t <span style=color:#f92672>=</span> kMidSize <span style=color:#f92672>&lt;&lt;</span> (class_id <span style=color:#f92672>&gt;&gt;</span> S);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> t <span style=color:#f92672>+</span> (t <span style=color:#f92672>&gt;&gt;</span> S) <span style=color:#f92672>*</span> (class_id <span style=color:#f92672>&amp;</span> M);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li><p>当 class_id &lt;= kMidClass 时，class_id 对应的 AllocationSize 都是以 kMinSize=2^kMinSizeLog=16 的 step 进行增长的，所以我们可以通过 kMinSize*class_id 得到 class_id 对应的 AllocationSize。</p></li><li><p>当 class_id > kMidClass 时，因为从 kMidClass=16 开始，每隔 2^(kNumBits-1)=4 个 SizeClass，AllocationSize 就会增大一倍。</p><p>对于一个给定的 AllocationSize=0b1xx0..0 来说，我们可以将它拆分成两部分：<code>AllocationSize = 0b1xx0..0 = 0b1000..0 + 0b0xx0..0</code>，我们将 0b<strong>1</strong>000..0 记作 AllocationSizeBase，将 0b0<strong>xx0.00</strong> 记作 AllocationSizeOffset。</p><p><code>t = kMidSize &lt;&lt; (class_id >> S)</code> 就是计算 AllocationSizeBase 的值，<code>(t >> S) * (class_id & M)</code> 就是计算 AllocationSizeOffset 的值</p></li></ul><h2 id=asanthreadlocalmallocstorage>AsanThreadLocalMallocStorage</h2><p>对于每个线程，ASan 都为其开辟了一块特殊的空间，称为 <strong>AsanThreadLocalMallocStorage</strong>。AsanThreadLocalMallocStorage 的结构如下图所示：</p><p><img src=/blog/inside-asan-allocator/3c751d85af7ef5665daa62ed784feed6ac4c9ace.png alt></p><p>AsanThreadLocalMallocStorage 包含两个成员变量：quarantine_cache 和 allocator_cache。</p><ul><li><p>quarantine_cache</p><p>当应用程序释放 memory chunk 时，并不会直接将其释放，而是会将其（实际上是指向该 memory chunk 的指针）保存在当前线程的 quarantine_cache 中。如果当前线程的 quarantine_cache 中保存的所有 memory chunks 的总大小超过了阈值 thread_local_quarantine_size_kb（默认为 1024KB，可以通过环境变量 ASAN_OPTIONS 进行设置），则会将当前线程 quarantine_cache 中保存的 chunks 转移到全局 central quarantine 中。而当全局 central quarantine 中保存的所有 chunks 的总大小超过了阈值 quarantine_size_mb（默认为 256MB，可以通过环境变量 ASAN_OPTIONS 进行设置），才会真正释放这些 memory chunks。</p><p>quarantine_cache 有两个成员变量：<code>atomic_uintptr_t size_</code> 和 <code>IntrusiveList&lt;QuarantineBatch> list_</code>。</p><ul><li><p><code>atomic_uintptr_t size_</code>：用于记录 quarantine_cache 中保存的所有 chunks 的大小之和。</p></li><li><p><code>IntrusiveList&lt;QuarantineBatch> list_</code>：当应用程序释放 memory chunk 时，会将指向该 chunk 的指针保存在 list_ 的最后一个 QuarantineBatch 中。每个 QuarantineBatch 中最多保存 1021 个指向已释放的 chunk 的指针，一旦 QuarantineBatch 占满后，会新创建一个 QuarantineBatch 添加至 list_ 末尾。</p></li></ul></li><li><p>allocator_cache：</p><p>对于小于等于 128KB 的内存分配申请，会优先从 allocator_cache 中选择提前从 PrimaryAllocator 分配好的保存在 allocator_cache 中的空闲 chunk 返回。由于每个线程都有一个 allocator_cache，因此从 allocator_cache 中取一个空闲 chunk 返回给应用程序是不需要加锁的，开销很小。</p><p>allocator_cache 的关键成员变量是 <code>PerClass per_class_[kNumClasses]</code>，每个 PerClass 对应一个 SizeClass。以 per_class_[1] 为例，per_class_[1].size = 16 表明 per_class_[1].chunks 中保存的是提前由 PrimaryAllocator 分配好的大小为 16-bytes 的 chunks；per_class_[1].count 表示当前 per_class_[1].chunks 中空闲的 chunk 的数量；当 per_class_[1].count = 0 即 per_class_[1].chunks 中没有空闲的 memory chunks 时，会从 PrimaryAllocator 中分配 per_class_[1].max_count / 2 = 256 / 2 = 128 个大小为 16-bytes 的 memory chunks 保存至 per_class_[1].chunks 中，供后续使用。不同的 per_class_[i]，其 max_count 是不同的，例如 per_class_[1].max_count = 256, per_class_[24].max_count = 128, per_class_[52].max_count = 2。</p></li></ul><h2 id=primaryallocatorsizeclassallocator64>PrimaryAllocator(SizeClassAllocator64)</h2><p>ASan allocator 的 PrimaryAllocator 就是代码中的 SizeClassAllocator64。PrimaryAllocator 用于处理 128KB 以内的内存分配。PrimaryAllocator 维护了一个 address space，结构如下图所示：</p><p><img src=/blog/inside-asan-allocator/e276938890af4aa53aa0ce9a27a2c6e63804943f.png alt></p><p>Address space 由两部分组成：一块大小为 kSpaceSize 的连续内存地址空间，本文中称之为 RegionSpace；一块大小为 AdditionalSize 的连续内存地址空间，本文中称之为 RegionInfoSpace。</p><ul><li><p>RegionSpace</p><p>RegionSpace 的起始地址是 kSpaceBeg = 0x600000000000，结束地址是 SpaceEnd = kSpaceBeg + kSpaceSize = 0x600000000000 + 0x40000000000 = 0x640000000000。RegionSpace 被平均分为 kNumClassesRounded = 64 个 Region，每个 Region 的大小都是 0x1000000000。不同的 Region 用于不同的 SizeClass 的内存分配，例如 Region of ClassId1 用于 16-bytes memory chunk 的分配，Region of ClassId2 用于 32-bytes memory chunk 的分配。</p><p>每个 Region 又是由 UserChunk, MetaChunk 和 FreeArray 组成的，而实际上 ASan 没有 MetaChunk，所以 Region 其实是由 UserChunk 和 FreeArray 组成的。UserChunk 就是后续返回给用户的 chunk，同一 Region 的 UserChunk 大小是固定的，例如 Region of ClassId1 中的 UserChunk 的大小就是 16-bytes。每个 Region 的最后 1/8 大小用作 FreeArray，FreeArray 中保存了空闲的可用于分配的 UserChunk（在代码实现上， FreeArray 中存储的是空闲的 UserChunk 的地址相对于其所在 Region 起始地址的相对偏移，相对偏移用 4-bytes 整型来存储，这样可以节省空间）。</p></li><li><p>RegionInfoSpace</p><p>RegionInfoSpace 起始地址就是 RegionSpace 的结束地址。每一个 Region 都会对应一个 RegionInfo，RegionInfo 中保存了对应的 Region 的相关信息，如 Region 中已经分配给用户的内存大小，详见结构体 RegionInfo 的定义。</p></li></ul><h2 id=secondaryallocatorlargemmapallocator>SecondaryAllocator(LargeMmapAllocator)</h2><p>ASan allocator 的 SecondaryAllocator 就是代码中的 LargeMmapAllocator。LargeMmapAllocator 用于处理大于 128KB 的内存分配，顾名思义 LargeMmapAllocator 是通过 mmap 来分配内存的。</p><p>由 SecondaryAllocator 负责分配的内存会额外申请 page_size_ 大小的内存用作额外的 Header：</p><ul><li><p>map_beg 就是 SecondaryAllocator 通过 mmap 申请内存的起始地址</p></li><li><p>map_size 即 SecondaryAllocator 实际分配的内存大小</p></li><li><p>size 是为用户申请的内存 user memory 添加 left redzone, right redzone 后所需要的内存大小 needed_size</p></li><li><p>chunk_idx 就是这块 SecondaryAllocator 申请的内存的索引</p></li></ul><p><img src=/blog/inside-asan-allocator/17f5e7268583a90ca1879c5d39d88d209ea1ad9e.png alt></p><p>SecondaryAllocator 会维护一个数组 ptr_array_，该数组中保存的是指向 SecondaryAllocator 已分配内存的 Header 的指针：</p><p><img src=/blog/inside-asan-allocator/00d2ede99be2fc0eb375ea439dda0294a3839963.png alt></p><p>给定一个指针 ptr，SecondaryAllocator 在判断该指针 ptr 是否指向一块内存由自己分配的chunk 时，就是通过遍历 ptr_array_ 查看 <code>ptr_array_[i]->map_beg &lt;= ptr &lt; ptr_array_[i]->map_beg + ptr_array_[i]->map_size</code> 是否满足。</p><h2 id=the-flow-of-asan_allocate>The flow of asan_allocate()</h2><p>我们将 ASan allocator 分配内存的流程抽象为 <code>asan_allocate()</code>，流程图如下所示：</p><p><img src=/blog/inside-asan-allocator/dfc21568b22771cc9718eae247460e64a7ba4811.png alt></p><ol><li><p>用户申请的内存大小是 user_requested_size，首先计算添加 redzone 后所需要的内存大小 needed_size。</p></li><li><p>如果 needed_size 超过了 ASan 能够申请的最大内存大小 kMaxAllowedMallocSize = 0x10000000000，那么根据在环境变量 ASAN_OPTIONS 中是否设置了 may_return_null=1 而选择报错 &ldquo;allocation-size-too-big&rdquo; 并终止程序还是返回 nullptr。</p></li><li><p>如果 needed_size &lt;= 128KB，那么由 thread local allocator cache 负责分配，执行步骤 4。否则由 SecondaryAllocator 负责分配，执行步骤 5。</p></li><li><p>对于 &lt;= 128KB 的内存分配由 thread local allocator cache 负责。如果当前线程的 allocator cache 有 SizeClassMap::ClassId(needed_size) 的空闲 chunk，那么直接将空闲 chunk 返回给用户。如果没有的话，则先向 PrimaryAllocator 申请一些 SizeClassMap::ClassId(needed_size) 的 chunks，补充至当前线程的 allocator cache 中，然后再将空闲可用的 chunk 返回给用户。</p></li><li><p>对于 > 128KB 的内存分配由 SecondaryAllocator 负责，SecondaryAllocator 通过 mmap 申请内存返回给用户。</p></li><li><p>如果在步骤 4 或步骤 5 中没有足够的内存可供分配，则报错 &ldquo;out-of-memory&rdquo; 并终止程序。</p></li><li><p>成功申请到了内存后，设置 ChunkHeader：alloc_type, user_requested_alignment_log, user_requested_size, alloc_context_id。</p></li><li><p>将 chunk 中 user memory 对应的 shadow memory 的每个字节的值都设置为表示 addressable 的 magic value，将 chunk 中 redzone 对应的 shadow memory 的每个字节的值设置为表示 redzone 的 magic value: kAsanHeapLeftRedzoneMagic。</p></li><li><p>然后 malloc_fill 就是填充 user memory 的内容，通过 memset 将 user memory 的值设置为 0xbe，默认情况下最多只填充 user memory 的前 4KB。可以通过在环境变量 ASAN_OPTIONS 设置 max_malloc_fill_size 来控制最多填充 user memory 的多少个字节，默认 max_malloc_fill_size=0x1000；可以通过在环境变量 ASAN_OPTIONS 设置 malloc_fill_byte 即用于填充 user memory 每个字节的值，默认malloc_fill_byte=0xbe。</p></li><li><p>最后将 ChunkHeader 中的 chunk_state 更新为 CHUNK_ALLOCATED，返回给用户一个指向 chunk 中 user memory 的指针。至此，ASan allocator 分配内存的流程结束。</p></li></ol><h2 id=the-flow-of-asan_deallocate>The flow of asan_deallocate()</h2><p>我们将 ASan allocator 释放内存的流程抽象为 <code>asan_deallocate()</code>，流程图如下所示：</p><p><img src=/blog/inside-asan-allocator/fb0a999302bb8b253329a5b679c52430fc10f38b.png alt></p><ol><li><p>首先查看当前正在释放的 chunk 的 ChunkHeader，如果 chunk_state 不是 CHUNK_ALLOCATED，报错 &ldquo;double-free&rdquo; 或 &ldquo;bad-free&rdquo; 并终止程序，否则继续执行步骤 2。</p></li><li><p>首先更新当前正在释放的 chunk 的 ChunkHeader，将 chunk_state 更新为 CHUNK_QUARANTINE。</p></li><li><p>检查 alloc_type 和 dealloc_type 是否匹配，例如申请内存时使用的 <code>operator new[]</code> 而是释放内存时却使用的 <code>operator delete</code> 这种情况。如果 alloc_type 和 dealloc_type 不匹配，报错 &ldquo;alloc-dealloc-mismatch&rdquo; 并终止程序。</p></li><li><p>更新 ChunkHeader，设置 dealloc_context_id 即释放内存的 stacktrace 和 thread id。</p></li><li><p>free_fill 填充 user memory 的内容：通过 memset 将 user memory 的值设置为 0x55。默认情况下不填充 user memory，可以通过环境变量 ASAN_OPTIONS 设置 max_free_fill_size 来控制最多填充 user memory 的多少个字节，默认 max_free_fill_size=0，即不填充；可以通过环境变量 ASAN_OPTIONS 设置 free_fill_byte 即用于填充 user memory 每个字节的值，默认 free_fill_byte=0x55。</p></li><li><p>将正在释放的 chunk 中 user memory 对应的 shadow memory 每个字节的值设置为 kAsanHeapFreeMagic，表示这块内存在语义上已经被释放了，实际上并没有释放而是被放入了 quarantine 中。</p></li><li><p>将被释放的 chunk 添加至当前线程的 quarantine cache 中。如果当前线程的 quarantine cache 中保存的所有已释放的 chunks 的大小之和不超过 thread_local_quarantine_size_kb（默认为 1024KB，可以通过环境变量 ASAN_OPTIONS 进行设置），则 <code>asan_deallocate()</code> 的流程结束，否则继续执行步骤 8。</p></li><li><p>将当前线程的 quarantine cache 转移 transfer 到全局 central quarantine 中。如果当前线程的 quarantine cache 中保存的所有已释放的 chunks 的大小之和不超过 quarantine_size_mb（默认为 256MB，可以通过环境变量 ASAN_OPTIONS 进行设置），则 <code>asan_deallocate()</code> 的流程结束，否则继续执行步骤 9。</p></li><li><p>不停地从全局 central quarantine 队列中取出 chunk（记作 extracted chunks），直至全局 central quarantine 中剩余的 chunks 的大小之和不超过 quarantine_size_mb 的 90%。</p></li><li><p>更新 extracted chunks 的 ChunkHeader，将 chunk_state 更新为 CHUNK_INVALID。</p></li><li><p>将 extracted chunks 中 user memory 对应的 shadow memory 每个字节的值设置为 kAsanHeapLeftRedzoneMagic，表示这些 extraced chunks 已经真正被释放了，不再保存在 quarantine 中，交由 PrimaryAllocator 或 SecondaryAllocator 去释放。</p></li><li><p>判断每一个 extracted chunk 在申请时是由 PrimaryAllocator 或 SecondaryAllocator 分配的。如果是由 PrimaryAllocator 分配的，那么执行步骤 13 交给 PrimaryAllocator 释放；如果是由 SecondaryAllocator 分配的，那么执行步骤 14 交给 SecondaryAllocator 释放。</p></li><li><p>由 PrimaryAllocator 释放 extracted chunk，首先查看 extraced chunk 属于哪一个 size class，如果当前线程 allocator cache 中该 size class 的空闲 chunks 已经满了 (per_class_[size_class].count == per_class_[size_class].max_count)，那么将该 size class 的空闲 chunks 的一半归还给 PrimaryAllocator，保存在 PrimaryAllocator 对应的 Region 的 FreeArray 中，PrimaryAllocator 会定期将 FreeArray 中的 chunks 归还给操作系统。最后将 extracted chunk 添加至当前线程 allocator cache 中对应的 per_class_ 中。执行步骤 15。</p></li><li><p>由 SecondaryAllocator 释放 extracted chunk，因为申请时是通过 mmap 分配的，所以直接通过 unmap 释放。执行步骤 15。</p></li><li><p>至此，ASan allocator 释放内存的流程结束。</p></li></ol><h2 id=summary>Summary</h2><p>本文分析了 ASan allocator 的实现，还是有很多细节没有详细讨论的，如：</p><ul><li><p>thread local allocator cache(SizeClassAllocator64LocalCache) 是怎么向 PrimaryAllocator(SizeClassAllocator64) 申请一些 chunks 补充至 thread local allocator cache 的</p></li><li><p>thread local allocator cache(SizeClassAllocator64LocalCache) 是怎么向 PrimaryAllocator(SizeClassAllocator64) 归还 chunks 的</p></li><li><p>PrimaryAllocator(SizeClassAllocator64) 又是怎么将内存归还操作系统的</p></li></ul><p>本文没有将这些细节事无巨细地写下来，可以阅读 ASan 代码来学习这些细节。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/llvm/ rel=tag>LLVM</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/hwasan-internals/>HWASAN Internals</a></li><li class=widget__item><a class=widget__link href=/post/inside-asan-allocator/>Inside AddressSanitizer Allocator</a></li><li class=widget__item><a class=widget__link href=/random/2022-12-31-summary/>2022 年度总结</a></li><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-runtime-init/>How Sanitizer Runtime Initialized</a></li><li class=widget__item><a class=widget__link href=/post/gwp-asan-internals/>GWP-ASan Internals</a></li><li class=widget__item><a class=widget__link href=/post/dumb-sanitizer-howto/>How To Write A Dumb Sanitizer</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li><li class=widget__item><a class=widget__link href=/categories/random/>Random</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>