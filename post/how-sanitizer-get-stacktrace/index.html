<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>How Sanitizer Get Stack Trace - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="How Sanitizer Get Stack Trace"><meta property="og:description" content="本文以 ASan 为例分析 sanitizer runtime 是如何获取和保存 stack trace 的。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/how-sanitizer-get-stacktrace/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-18T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/random/><span class=menu__text>random</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>How Sanitizer Get Stack Trace</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2022-10-18T00:00:00Z>October 18, 2022</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#stack-unwinding>Stack unwinding</a><ul><li><a href=#frame-pointer>Frame pointer</a></li><li><a href=#dwarf-call-frame-information>DWARF Call Frame Information</a></li></ul></li><li><a href=#sanitizer-stack-trace>Sanitizer stack trace</a><ul><li><a href=#unwindfast>UnwindFast</a></li><li><a href=#unwindslow>UnwindSlow</a></li></ul></li><li><a href=#stackdepot>StackDepot</a></li><li><a href=#references>References</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>本文以 ASan 为例分析 sanitizer runtime 是如何获取和保存 stack trace 的。</p><p>Sanitizer 非常好用的一个原因就是报告的内容非常详细。例如 ASan 检测到一个 heap-use-after-free 类型的 bug，在报告中不仅会给出执行哪行代码时触发了 heap-use-after-free，还会给出这块堆内存是在哪里被申请的，又是在哪里被释放的。</p><p>例如下面这个 heap-use-after-free 的例子：</p><ul><li><p>&ldquo;READ of size 4 at 0x603e0001fc64 thread T0&rdquo; 给出的是触发 heap-use-after-free 的 stack trace</p></li><li><p>&ldquo;freed by thread T0 here:&rdquo; 给出的是堆内存被释放时的 stack trace</p></li><li><p>&ldquo;previously allocated by thread T0 here:&rdquo; 给出的是堆内存被申请时的 stack trace</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// clang -O0 -g -fsanitize=address test.cpp &amp;&amp; ./a.out
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>array <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>delete</span> [] array;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> array[argc];  <span style=color:#75715e>// BOOM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><pre tabindex=0><code>=================================================================
==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64 at pc 0x417f6a bp 0x7fff626b3250 sp 0x7fff626b3248
READ of size 4 at 0x603e0001fc64 thread T0
    #0 0x417f69 in main test.cpp:5
    #1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)
    #2 0x417e54 (a.out+0x417e54)
0x603e0001fc64 is located 4 bytes inside of 400-byte region [0x603e0001fc60,0x603e0001fdf0)
freed by thread T0 here:
    #0 0x40d4d2 in operator delete[](void*) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:61
    #1 0x417f2e in main test.cpp:4
previously allocated by thread T0 here:
    #0 0x40d312 in operator new[](unsigned long) llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:46
    #1 0x417f1e in main test.cpp:3
Shadow bytes around the buggy address:
  0x1c07c0003f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c07c0003f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c07c0003f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c07c0003f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c07c0003f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=&gt;0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd
  0x1c07c0003f90: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x1c07c0003fa0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
  0x1c07c0003fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa
  0x1c07c0003fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c07c0003fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe
==6254== ABORTING
</code></pre><p>本文以 ASan 为例分析 sanitizer runtime 是如何获取 stack trace 的。</p><h2 id=stack-unwinding>Stack unwinding</h2><p>在分析 sanitizer runtime 关于 stack trace 的具体实现之前，我们先来学习下 stack unwinding。</p><p>关于 stack unwinding，maskray 这篇文章 <a href=https://maskray.me/blog/2020-11-08-stack-unwinding>Stack unwinding | MaskRay</a> 写的非常好。本节的内容都是从 maskray 这篇文章习来的。</p><p>Stack unwinding 主要用于获取 stack trace 或 实现 C++ exception。</p><p>Stack unwinding 可以分为两类：</p><ul><li>synchronous: 由程序自身触发的，只发生在函数调用处（在 function body 内，不会出现在 prologue/epilogue 处)。</li><li>asynchronous: 由 garbage collector, signal 或外部程序触发，这类 stack unwinding 可以发生在函数 prologue/epilogue 处。</li></ul><p>Sanitizer 的 stack unwinding 就是 synchronous stack unwinding，由 sanitizer runtime 自身触发。例如 sanitizer runtime 在 malloc/free 时会通过 stack unwinding 获取 stack trace。</p><p>因此本文中我们只讨论 synchronous stack unwinding（而且我也不了解 asynchronous stack unwinding，以后有时间可以学习下）。</p><h3 id=frame-pointer>Frame pointer</h3><p>最朴素的 stack unwinding 就是基于 frame (base) pointer [%rbp] 来实现的。如果编译时添加了选项 <code>-fno-omit-frame-pointer</code>，那么在函数 prologue/epilogue 处会有如下指令：</p><pre tabindex=0><code>pushq %rbp
movq %rsp, %rbp
...
popq %rbp
ret
</code></pre><p>函数 prologue 处 <code>pushq %rbp</code> 将 caller 的 frame pointer 值压栈，<code>movq %rsp, %rbp</code> 将寄存器 %rbp 的值更新为保存 caller frame pointer 的栈地址。这样，一旦我们获取了当前函数的 frame pointer 的值，将其解引用后就可以得到 caller 的 frame pointer 的值，不停地解引用就能获取到所有栈帧的 frame pointer。</p><p>我们可以将 stack frame 抽象为如下结构体：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>stack_frame</span> {
</span></span><span style=display:flex><span>  stack_frame<span style=color:#f92672>*</span> nextFrame;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> returnAddress;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>以如下汇编代码为例进行说明：在 x86_64 下，caller 会在执行 call 指令时会将当前函数的下一条指令地址压栈，然后跳转到 callee 的入口处继续执行，接着在 callee 的第一条指令就是 <code>pushq %rbp</code> 将寄存器 %rbp 的值压栈。这两条指令合作将 struct stack_frame 的内容填充好。</p><pre tabindex=0><code>main:                                   # @main
        pushq   %rbp
        movq    %rsp, %rbp
        subq    $16, %rsp
        movl    $0, -4(%rbp)
        movl    $2, %edi
        callq   foo(int) # Pushes address of next instruction onto stack,
                         # populating &#39;returnAddress&#39; member of &#39;stack_frame&#39;.
                         # Then jumps to &#39;callee&#39; address(i.e. function foo).
        addl    $1, %eax
        addq    $16, %rsp
        popq    %rbp
        retq

foo:                                # @foo(int)
        pushq   %rbp       # Push rbp (stack_frame ptr) onto stack (populates &#39;nextFrame&#39; member)
        movq    %rsp, %rbp # Update rbp to point to new stack_frame
        subq    $16, %rsp. # Reserve an additional 16 bytes of stack-space
        movl    %edi, -4(%rbp)
        movl    -4(%rbp), %edi
        callq   bar(int)
        addl    $2, %eax
        addq    $16, %rsp. # Restore rsp
        popq    %rbp       # Pop rbp from stack
        retq               # Pop return address from top of stack and jump to it
</code></pre><p>因此我们可以通过 <code>_builtin_frame_address(0)</code> 得到当前函数的 frame pointer 值，解引用 frame pointer 即可得到 nextFrame 和 returnAddress，不断重复，这样我们就能获取到 stack trace 了。</p><p>一个简单的 unwinding 代码示例实现 test_unwind.cpp 如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#ae81ff>1</span>  <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#f92672>&lt;</span>stdio.h<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>3</span>  __attribute__((noinline)) <span style=color:#66d9ef>void</span> fast_unwind() {
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>frame <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>)__builtin_frame_address(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span> <span style=color:#ae81ff>5</span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span> <span style=color:#ae81ff>6</span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;frame pointer is: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, frame);
</span></span><span style=display:flex><span> <span style=color:#ae81ff>7</span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>pc <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>*</span>)frame[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span> <span style=color:#ae81ff>8</span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;pc is: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pc);
</span></span><span style=display:flex><span> <span style=color:#ae81ff>9</span>      <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>new_frame <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>)(<span style=color:#f92672>*</span>frame);
</span></span><span style=display:flex><span> <span style=color:#ae81ff>10</span>      <span style=color:#a6e22e>if</span> (<span style=color:#f92672>*</span>new_frame <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>*</span>frame) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>11</span>      frame <span style=color:#f92672>=</span> new_frame;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>12</span>    }
</span></span><span style=display:flex><span> <span style=color:#ae81ff>13</span>  }
</span></span><span style=display:flex><span> <span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>15</span>  <span style=color:#a6e22e>__attribute__</span>((noinline)) <span style=color:#66d9ef>int</span> bar(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span> <span style=color:#ae81ff>16</span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span> <span style=color:#ae81ff>17</span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>18</span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span> <span style=color:#ae81ff>19</span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>20</span>    fast_unwind();
</span></span><span style=display:flex><span> <span style=color:#ae81ff>21</span>    <span style=color:#66d9ef>return</span> bar(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> bar(n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span> <span style=color:#ae81ff>22</span>  }
</span></span><span style=display:flex><span> <span style=color:#ae81ff>23</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>24</span>  <span style=color:#a6e22e>__attribute__</span>((noinline)) <span style=color:#66d9ef>int</span> foo(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span> <span style=color:#ae81ff>25</span>    <span style=color:#66d9ef>return</span> bar(n)<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>26</span>  }
</span></span><span style=display:flex><span> <span style=color:#ae81ff>27</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>28</span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span> <span style=color:#ae81ff>29</span>    <span style=color:#66d9ef>return</span> foo(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span> <span style=color:#ae81ff>30</span>  }
</span></span></code></pre></div><pre tabindex=0><code>$ clang++ test_unwind.cpp -g -no-pie -fno-omit-frame-pointer &amp;&amp; ./a.out
frame pointer is: 0x7ffcbde94c10
pc is: 0x4011ec
frame pointer is: 0x7ffcbde94c30
pc is: 0x401233
frame pointer is: 0x7ffcbde94c50
pc is: 0x401259

$ llvm-symbolizer -iCfe a.out 0x4011ec 0x401233 0x401259
bar(int)
test-stack-trace/test_unwind.cpp:21:14
foo(int)
test-stack-trace/test_unwind.cpp:25:16
main
test-stack-trace/test_unwind.cpp:29:16
</code></pre><p>但是这种基于 frame pointer 实现 stack unwinding 的方式有很大的局限性：编译器默认只有在 O0 优化等级下会添加 <code>-fno-omit-frame-pointer</code> 编译选项，并且预留一个寄存器用于存储 frame pointer 与不预留一个寄存器存储 frame pointer 相比会有额外的性能开销。</p><h3 id=dwarf-call-frame-information>DWARF Call Frame Information</h3><p>另一种 stack unwinding 的实现方式就是基于 DWARF Call Frame Information 来实现的，由 compiler/assembler/linker/libunwind 提供相应支持。</p><p>我们还是以例子进行说明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> cat test.cpp
</span></span><span style=display:flex><span>__attribute__((noinline)) <span style=color:#66d9ef>int</span> bar(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bar</span>(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> bar(n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__attribute__((noinline)) <span style=color:#66d9ef>int</span> foo(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bar</span>(n)<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> foo(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 生成 test_unwind.s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>$</span> clang<span style=color:#f92672>++</span> <span style=color:#f92672>-</span>O1 test.cpp <span style=color:#f92672>-</span>S
</span></span></code></pre></div><p>我们可以在 test.s 中看到 .cfi_def_cfa_offset, .cfi_offset 这样的 <a href=https://sourceware.org/binutils/docs/as/CFI-directives.html>CFI directives</a>，assembler/linker 会根据这些 CFI directives 生成 .eh_frame section，最终用于 stack unwinding。</p><p>例如在汇编文件 test.s 中函数 bar 对应的汇编代码中有如下内容：</p><pre tabindex=0><code>_Z3bari:                                # @_Z3bari
    .cfi_startproc
# %bb.0:                                # %entry
    pushq    %rbp
    .cfi_def_cfa_offset 16
    pushq    %rbx
    .cfi_def_cfa_offset 24
    pushq    %rax
    .cfi_def_cfa_offset 32
    .cfi_offset %rbx, -24
    .cfi_offset %rbp, -16
    testl    %edi, %edi
    jle    .LBB0_1
</code></pre><p>我们手动将 <code>.cfi_offset %rbp, -16</code> 修改为 <code>.cfi_offset %rbp, -24</code>，然后将 test.s 编译为可执行文件，并用 gdb 调试看下会有什么影响：</p><pre tabindex=0><code>$ clang test.s
$ gdb ./a.out
(gdb) b bar
(gdb) r
(gdb) ni
(gdb) ni
(gdb) ni
(gdb) disassemble
Dump of assembler code for function _Z3bari:
   0x0000000000401110 &lt;+0&gt;:    push   %rbp
   0x0000000000401111 &lt;+1&gt;:    push   %rbx
   0x0000000000401112 &lt;+2&gt;:    push   %rax
=&gt; 0x0000000000401113 &lt;+3&gt;:    test   %edi,%edi
(gdb) i r rbx rbp
rbx            0x0                 0
rbp            0x401170            0x401170 &lt;__libc_csu_init&gt;
(gdb) bt
#0  0x0000000000401110 in bar(int) ()
#1  0x0000000000401156 in foo(int) ()
#2  0x000000000040116b in main ()
(gdb) f 1
#1  0x0000000000401156 in foo(int) ()
(gdb) i r rbx rbp
rbx            0x0                 0
rbp            0x0                 0x0
</code></pre><p>我们让程序停在 bar 函数中 <code>test %edi,%edi</code> 处，然后运行程序。可以看到在断点处 rbp 的值是 0x401170，rbx 的值是 0，跳转至 frame 1 后，再次看 rbp 的值，此时变为了 0。然而应当跳转至 frame 1 处和 rbp 的值也应该是 0x401170，变成 0 是因为我们将汇编文件 test.s 中 <code>.cfi_offset %rbp, -16</code> 修改为了 <code>.cfi_offset %rbp, -24</code>。而 cfi_offset -24 处存储的是 %rbx 的值，%rbx 的值是 0，所以 gdb 将 frame 1 的 %rbp 的值恢复为了 0。</p><p>这样我们通过这样一个简单的例子管中窥豹了解了基于 DWARF Call Frame Information 的 stack unwinding。</p><h2 id=sanitizer-stack-trace>Sanitizer stack trace</h2><p>Sanitizer runtime 在 stack unwinding 时，有两种策略：fast unwind 和 slow unwind，sanitizer runtime 优先使用 fast unwind。</p><p>在 sanitizer runtime 中有很多地方都需要收集 stack trace，例如在 malloc/free 被调用时收集 stack trace。在 ASan runtime library 中 intercptor malloc/free 函数实现中就通过宏 <code>GET_STACK_TRACE_MALLOC</code> 和 <code>GET_STACK_TRACE_FREE</code> 来获取 stack trace 保存至 BufferedStackTrace 类型的变量 stack 中，然后将 stack 作为参数传给函数 <code>asan_malloc</code>, <code>asan_free</code> 保存起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// compiler-rt/lib/asan/asan_malloc_linux.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>INTERCEPTOR(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>, malloc, uptr size) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (DlsymAlloc<span style=color:#f92672>::</span>Use())
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> DlsymAlloc<span style=color:#f92672>::</span>Allocate(size);
</span></span><span style=display:flex><span>  ENSURE_ASAN_INITED();
</span></span><span style=display:flex><span>  GET_STACK_TRACE_MALLOC;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>asan_malloc</span>(size, <span style=color:#f92672>&amp;</span>stack);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>INTERCEPTOR(<span style=color:#66d9ef>void</span>, free, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (DlsymAlloc<span style=color:#f92672>::</span>PointerIsMine(ptr))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> DlsymAlloc<span style=color:#f92672>::</span>Free(ptr);
</span></span><span style=display:flex><span>  GET_STACK_TRACE_FREE;
</span></span><span style=display:flex><span>  asan_free(ptr, <span style=color:#f92672>&amp;</span>stack, FROM_MALLOC);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>GET_STACK_TRACE_MALLOC</code> 和 <code>GET_STACK_TRACE_FREE</code> 宏展开后经过一系列的调用，最终执行的是 <code>BufferedStackTrace::Unwind()</code>：</p><p><code>BufferedStackTrace::Unwind()</code> 函数的各个参数含义如下：</p><ul><li><p>max_depth：设置 unwind 最大回溯的深度。</p></li><li><p>pc: the pc will be in the position 0 of the resulting stack trace. 即 unwind 起始处的 pc，是通过 <code>__builtin_return_address(0)</code> 得到的。</p></li><li><p>bp: the bp may refer to the current frame or to the caller&rsquo;s frame. 即 unwind 起始处的 frame address，是通过 <code>__builtin_frame_address(0)</code> 得到的。</p></li><li><p>context: 通常为 nullptr。在 Android lollipop 版本之前，从 signal handler 中 unwind 要基于 libcorkscrew.so，需要用到 signal handler 提供的 context 参数。</p></li><li><p>stack_top, stack_bottom: unwind 起始处所在线程的线程栈底和线程栈顶，主要用于判断采取 fast unwind 时 unwind 过程何时终止。</p></li><li><p>request_fast_unwind: 表示是使用 fast unwind 还是 slow unwind。在环境变量 ASAN_OPTIONS 中可以设置运行时参数 fast_unwind_on_check, fast_unwind_on_fatal, fast_unwind_on_malloc，sanitizer 会根据这些参数的设置以及运行环境是否支持选择使用 fast unwind 还是 slow unwind。</p><ul><li><p>fast_unwind_on_check: If available, use the fast frame-pointer-based unwinder on internal CHECK failures. Defaults to false.</p></li><li><p>fast_unwind_on_fatal: If available, use the fast frame-pointer-based unwinder on fatal errors. Defaults to false.</p></li><li><p>fast_unwind_on_malloc: If available, use the fast frame-pointer-based unwinder on malloc/free. Defaults to true.</p></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// compiler-rt/lib/sanitizer_common/sanitizer_stacktrace_libcdep.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> BufferedStackTrace<span style=color:#f92672>::</span>Unwind(u32 max_depth, uptr pc, uptr bp, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>context,
</span></span><span style=display:flex><span>                                uptr stack_top, uptr stack_bottom,
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>bool</span> request_fast_unwind) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ensures all call sites get what they requested.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CHECK_EQ(request_fast_unwind, WillUseFastUnwind(request_fast_unwind));
</span></span><span style=display:flex><span>  top_frame_bp <span style=color:#f92672>=</span> (max_depth <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> bp : <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Avoid doing any work for small max_depth.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (max_depth <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (max_depth <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    trace_buffer[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pc;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>WillUseFastUnwind(request_fast_unwind)) {
</span></span><span style=display:flex><span><span style=color:#75715e>#if SANITIZER_CAN_SLOW_UNWIND
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (context)
</span></span><span style=display:flex><span>      UnwindSlow(pc, context, max_depth);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>UnwindSlow</span>(pc, max_depth);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If there are too few frames, the program may be built with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// -fno-asynchronous-unwind-tables. Fall back to fast unwinder below.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>||</span> size <span style=color:#f92672>&gt;=</span> max_depth)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UNREACHABLE(<span style=color:#e6db74>&#34;slow unwind requested but not available&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  UnwindFast(pc, bp, stack_top, stack_bottom, max_depth);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=unwindfast>UnwindFast</h3><p>UnwindFast 其实就是基于 frame pointer 的 unwind，具体实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_stacktrace.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> BufferedStackTrace<span style=color:#f92672>::</span>UnwindFast(uptr pc, uptr bp, uptr stack_top,
</span></span><span style=display:flex><span>                                    uptr stack_bottom, u32 max_depth) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// TODO(yln): add arg sanity check for stack_top/stack_bottom
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  CHECK_GE(max_depth, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> uptr kPageSize <span style=color:#f92672>=</span> GetPageSizeCached();
</span></span><span style=display:flex><span>  trace_buffer[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pc;
</span></span><span style=display:flex><span>  size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (stack_top <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4096</span>) <span style=color:#66d9ef>return</span>;  <span style=color:#75715e>// Sanity check for stack top.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  uhwptr <span style=color:#f92672>*</span>frame <span style=color:#f92672>=</span> GetCanonicFrame(bp, stack_top, stack_bottom);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Lowest possible address that makes sense as the next frame pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Goes up as we walk the stack.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  uptr bottom <span style=color:#f92672>=</span> stack_bottom;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Avoid infinite loop when frame == frame[0] by using frame &gt; prev_frame.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (IsValidFrame((uptr)frame, stack_top, bottom) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>         IsAligned((uptr)frame, <span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>frame)) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>         size <span style=color:#f92672>&lt;</span> max_depth) {
</span></span><span style=display:flex><span>    uhwptr pc1 <span style=color:#f92672>=</span> frame[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Let&#39;s assume that any pointer in the 0th page (i.e. &lt;0x1000 on i386 and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// x86_64) is invalid and stop unwinding here.  If we&#39;re adding support for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// a platform where this isn&#39;t true, we need to reconsider this check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (pc1 <span style=color:#f92672>&lt;</span> kPageSize)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pc1 <span style=color:#f92672>!=</span> pc) {
</span></span><span style=display:flex><span>      trace_buffer[size<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> (uptr) pc1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    bottom <span style=color:#f92672>=</span> (uptr)frame;
</span></span><span style=display:flex><span>    frame <span style=color:#f92672>=</span> GetCanonicFrame((uptr)frame[<span style=color:#ae81ff>0</span>], stack_top, bottom);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> uhwptr <span style=color:#f92672>*</span><span style=color:#a6e22e>GetCanonicFrame</span>(uptr bp,
</span></span><span style=display:flex><span>                                      uptr stack_top,
</span></span><span style=display:flex><span>                                      uptr stack_bottom) {
</span></span><span style=display:flex><span>  CHECK_GT(stack_top, stack_bottom);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (uhwptr<span style=color:#f92672>*</span>)bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Check if given pointer points into allocated stack area.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>IsValidFrame</span>(uptr frame, uptr stack_top, uptr stack_bottom) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> frame <span style=color:#f92672>&gt;</span> stack_bottom <span style=color:#f92672>&amp;&amp;</span> frame <span style=color:#f92672>&lt;</span> stack_top <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span> (uhwptr);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=unwindslow>UnwindSlow</h3><p>UnwindSlow 就是基于 libunwind 提供的接口 <code>_Unwind_Backtrace</code> 来实现的 unwind：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_unwind_linux_libcdep.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> BufferedStackTrace<span style=color:#f92672>::</span>UnwindSlow(uptr pc, u32 max_depth) {
</span></span><span style=display:flex><span>  CHECK_GE(max_depth, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>  size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  UnwindTraceArg arg <span style=color:#f92672>=</span> {<span style=color:#66d9ef>this</span>, Min(max_depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, kStackTraceMax)};
</span></span><span style=display:flex><span>  _Unwind_Backtrace(Unwind_Trace, <span style=color:#f92672>&amp;</span>arg);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We need to pop a few frames so that pc is on top.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  uptr to_pop <span style=color:#f92672>=</span> LocatePcInTrace(pc);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// trace_buffer[0] belongs to the current function so we always pop it,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// unless there is only 1 frame in the stack trace (1 frame is always better
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// than 0!).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1-frame stacks don&#39;t normally happen, but this depends on the actual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// unwinder implementation (libgcc, libunwind, etc) which is outside of our
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// control.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (to_pop <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    to_pop <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  PopStackFrames(to_pop);
</span></span><span style=display:flex><span>  trace_buffer[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> pc;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UnwindTraceArg</span> {
</span></span><span style=display:flex><span>  BufferedStackTrace <span style=color:#f92672>*</span>stack;
</span></span><span style=display:flex><span>  u32 max_depth;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_Unwind_Reason_Code <span style=color:#a6e22e>Unwind_Trace</span>(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Unwind_Context</span> <span style=color:#f92672>*</span>ctx, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>param) {
</span></span><span style=display:flex><span>  UnwindTraceArg <span style=color:#f92672>*</span>arg <span style=color:#f92672>=</span> (UnwindTraceArg<span style=color:#f92672>*</span>)param;
</span></span><span style=display:flex><span>  CHECK_LT(arg<span style=color:#f92672>-&gt;</span>stack<span style=color:#f92672>-&gt;</span>size, arg<span style=color:#f92672>-&gt;</span>max_depth);
</span></span><span style=display:flex><span>  uptr pc <span style=color:#f92672>=</span> Unwind_GetIP(ctx);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> uptr kPageSize <span style=color:#f92672>=</span> GetPageSizeCached();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Let&#39;s assume that any pointer in the 0th page (i.e. &lt;0x1000 on i386 and
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// x86_64) is invalid and stop unwinding here.  If we&#39;re adding support for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// a platform where this isn&#39;t true, we need to reconsider this check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>&lt;</span> kPageSize) <span style=color:#66d9ef>return</span> UNWIND_STOP;
</span></span><span style=display:flex><span>  arg<span style=color:#f92672>-&gt;</span>stack<span style=color:#f92672>-&gt;</span>trace_buffer[arg<span style=color:#f92672>-&gt;</span>stack<span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> pc;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (arg<span style=color:#f92672>-&gt;</span>stack<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>==</span> arg<span style=color:#f92672>-&gt;</span>max_depth) <span style=color:#66d9ef>return</span> UNWIND_STOP;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> UNWIND_CONTINUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>_Unwind_Backtrace</code> 的函数原型如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// _Unwind_Backtrace() is a gcc extension that walks the stack and calls the
</span></span></span><span style=display:flex><span><span style=color:#75715e>// _Unwind_Trace_Fn once per frame until it reaches the bottom of the stack
</span></span></span><span style=display:flex><span><span style=color:#75715e>// or the _Unwind_Trace_Fn function returns something other than _URC_NO_REASON.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>_Unwind_Reason_Code</span> (<span style=color:#f92672>*</span>_Unwind_Trace_Fn)(<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_Unwind_Context</span> <span style=color:#f92672>*</span>,
</span></span><span style=display:flex><span>                                                <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> _Unwind_Reason_Code <span style=color:#a6e22e>_Unwind_Backtrace</span>(_Unwind_Trace_Fn, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
</span></span></code></pre></div><p><code>_Unwind_Backtrace</code> 在 stack unwinding 时，对于每一个 frame 都会调用回调函数 <code>Unwind_Trace</code> 将此 frame 的 PC/IP 指令地址保存至 BufferedStackTrace 的成员变量 trace_buffer 中。</p><h2 id=stackdepot>StackDepot</h2><p>本节我们来看下 sanitizer runtime 是如何保存 stack trace 的。</p><p>我们在本文前面提到 intercetpr malloc 调用 <code>asan_malloc</code> 来进行内存分配，而 <code>asan_malloc</code> 就是对 <code>__asan::Allocator::Allocate</code> 函数的一层包装。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// compiler-rt/lib/asan/asan_allocator.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>asan_malloc</span>(uptr size, BufferedStackTrace <span style=color:#f92672>*</span>stack) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> SetErrnoOnNull(instance.Allocate(size, <span style=color:#ae81ff>8</span>, stack, FROM_MALLOC, true));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Allocate</span>(uptr size, uptr alignment, BufferedStackTrace <span style=color:#f92672>*</span>stack,
</span></span><span style=display:flex><span>                 AllocType alloc_type, <span style=color:#66d9ef>bool</span> can_fill) {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  m<span style=color:#f92672>-&gt;</span>alloc_context_id <span style=color:#f92672>=</span> StackDepotPut(<span style=color:#f92672>*</span>stack);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意到 <code>__asan::Allocator::Allocate</code> 函数是通过调用函数 <code>StackDepotPut</code> 将 stack unwinding 获取的 stack trace 保存起来。<code>StackDepotPut</code> 会返回一个 context_id，维护 context_id 与 stack trace 的映射关系，后续可以通过 context_id 找到对应的 stack trace。</p><p>存储 stack trace 的核心数据结构就是 StackDepot，代码位于：</p><ul><li><p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepotbase.h</p></li><li><p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.h</p></li><li><p>compiler-rt/lib/sanitizer_common/sanitizer_stackdepot.cpp</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// FIXME(dvyukov): this single reserved bit is used in TSan.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> StackDepotBase<span style=color:#f92672>&lt;</span>StackDepotNode, <span style=color:#ae81ff>1</span>, StackDepotNode<span style=color:#f92672>::</span>kTabSizeLog<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    StackDepot;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> StackDepot theDepot;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>u32 <span style=color:#a6e22e>StackDepotPut</span>(StackTrace stack) {
</span></span><span style=display:flex><span>  StackDepotHandle h <span style=color:#f92672>=</span> theDepot.Put(stack);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> h.valid() <span style=color:#f92672>?</span> h.id() <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>StackTrace <span style=color:#a6e22e>StackDepotGet</span>(u32 id) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> theDepot.Get(id);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p><code>StackDepotPut</code> 函数，参数类型是 StackTrace（BufferedStackTrace 是 StackTrace 的子类），返回值类型是 u32。存储 stack trace，返回一个 id，id 与 stack trace 是一一对应关系。</p></li><li><p><code>StackDepotGet</code> 函数，参数类型是 u32，返回值类型是 StackTrace。根据 id 返回对应的 stack trace。</p></li></ul><p>StackDepotNode 和 StackDepotBase/StackDepot 的成员变量如下所示。</p><ul><li><p>StackDepotNode。成员变量 StackDepotNode *link; 存储指向下一个 StackDepotNode 的指针，即多个 StackDepotNode 组成一个链表。成员变量 id 用于标识该 StackDepotNode/StackTrace。成员变量 tag 的可能取值是 TAG_UNKNOWN(0), TAG_ALLOC(1), TAG_DEALLOC(2), TAG_CUSTOM(100) 表示 stack trace 的来源。成员变量 size 就是用于表示 stack trace 的深度，成员变量 stack 是个数组，数组每个元素用于存储 stack trace 每一帧的 pc。</p></li><li><p>StackDepot/StackDepotBase。StackDepot 通过 hash table 来存储 StackDepotNode，hash table 维护了 1&#171;20 个 tab，每 1&#171;12 个 tab 又组成了一个 part。每个 tab 存储的是指向 StackDepotNode 链表第一个元素的指针。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StackDepotNode</span> {
</span></span><span style=display:flex><span>  StackDepotNode <span style=color:#f92672>*</span>link;
</span></span><span style=display:flex><span>  u32 id;
</span></span><span style=display:flex><span>  atomic_uint32_t hash_and_use_count; <span style=color:#75715e>// hash_bits : 12; use_count : 20;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  u32 size;
</span></span><span style=display:flex><span>  u32 tag;
</span></span><span style=display:flex><span>  uptr stack[<span style=color:#ae81ff>1</span>];  <span style=color:#75715e>// [size]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ...
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>, <span style=color:#66d9ef>int</span> kReservedBits, <span style=color:#66d9ef>int</span> kTabSizeLog<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StackDepotBase</span> {
</span></span><span style=display:flex><span>  atomic_uintptr_t tab[kTabSize];   <span style=color:#75715e>// Hash table of Node&#39;s.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  atomic_uint32_t seq[kPartCount];  <span style=color:#75715e>// Unique id generators.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>StackDepot hash table 示意图如下：</p><p><img src=/blog/sanitizer-stacktrace/2022-10-17-22-44-38-image.png alt></p><ul><li><p>对于一个给定的 stack trace，首先计算出该 stack trace 的 hash 值记作 h，然后计算 <code>h % kTabSize</code> 找到存储该 stack trace 的 tab。判断当前给定的 stack trace 是否已经在 <code>tab[h % kTabSize]</code> 对应的链表中。如果不在，就申请一块内存，在这块内存上根据给定的 stack trace 构造 StackDepotNode，然后将该 StackDepotNode 插入到 <code>tab[h % kTabSize]</code> 对应的链表开头。
那么 StackDepotNode 的 id 是怎么计算的呢？每 1&#171;12 个 tab 组成了一个 part，数组 <code>seq[kPartCount]</code> 存储的是每个 part 中当前已经存储了多少个 StackDepotNode。通过计算 <code>h % kTabSize / kPartSize</code> 找到存储该 stack trace 的 tab 所在的 part。对于一个新的 StackDepotNode 对应的 id 就是 <code>(seq[part] + 1) | (part &lt;&lt; kPartShift)</code>。</p></li><li><p>对于一个给定的 id，首先通过 <code>uptr part = id >> kPartShift;</code> 找到该 id 对应的 StackDepotNode 位于哪个 part。遍历该 part 中的 1 &#171;12 个 tab，在每个 tab 链表中寻找是否存在与给定 id 相等的 StackDepotNode。</p></li></ul><p>关于 sanitizer runtime 是如何保存 stack trace 的，可以仔细阅读下 StackDepot 的代码实现，这部分代码非常值得学习，这里就不一一贴代码了。</p><h2 id=references>References</h2><ol><li><p><a href=https://maskray.me/blog/2020-11-08-stack-unwinding>Stack unwinding | MaskRay</a></p></li><li><p><a href=https://developers.facebook.com/blog/post/2021/09/23/async-stack-traces-folly-synchronous-asynchronous-stack-traces/>https://developers.facebook.com/blog/post/2021/09/23/async-stack-traces-folly-synchronous-asynchronous-stack-traces/</a></p></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/llvm/ rel=tag>LLVM</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/hwasan-internals/>HWASAN Internals</a></li><li class=widget__item><a class=widget__link href=/post/inside-asan-allocator/>Inside AddressSanitizer Allocator</a></li><li class=widget__item><a class=widget__link href=/random/2022-12-31-summary/>2022 年度总结</a></li><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-runtime-init/>How Sanitizer Runtime Initialized</a></li><li class=widget__item><a class=widget__link href=/post/gwp-asan-internals/>GWP-ASan Internals</a></li><li class=widget__item><a class=widget__link href=/post/dumb-sanitizer-howto/>How To Write A Dumb Sanitizer</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li><li class=widget__item><a class=widget__link href=/categories/random/>Random</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>