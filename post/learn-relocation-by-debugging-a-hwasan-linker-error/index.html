<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Learn Relocation by Debugging a HWASAN Linker Error - Enna1's website</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Learn Relocation by Debugging a HWASAN Linker Error "><meta property="og:description" content="笔者在 Linux/AArch64 环境下使用 HWASAN 时，遇到一 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误，在分析解决该链接错误过程中对 linker relocation 以及 HWASAN 都有了更深的理解，因此将分析解决该链接错误的过程梳理总结形成此文。"><meta property="og:type" content="article"><meta property="og:url" content="https://enna1.github.io/post/learn-relocation-by-debugging-a-hwasan-linker-error/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-30T00:00:00+00:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Enna1's website" rel=home><div class="logo__item logo__text"><div class=logo__title>Enna1's website</div><div class=logo__tagline>Nobody dies a virgin, life fucks us all!</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>home</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>blog</span></a></li><li class=menu__item><a class=menu__link href=/random/><span class=menu__text>random</span></a></li><li class=menu__item><a class=menu__link href=/podcast/><span class=menu__text>podcast</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>archives</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>about</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Learn Relocation by Debugging a HWASAN Linker Error</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-05-30T00:00:00Z>May 30, 2023</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/programming/ rel=category>Programming</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#relocation>Relocation</a></li><li><a href=#hwasan-relocation-overflow>HWASAN relocation overflow</a></li><li><a href=#总结>总结</a></li><li><a href=#参考链接>参考链接</a></li><li><a href=#ps>P.S.</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>笔者在 Linux/AArch64 环境下使用 HWASAN 时，遇到一 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误，在分析解决该链接错误过程中对 linker relocation 以及 HWASAN 都有了更深的理解，因此将分析解决该链接错误的过程梳理总结形成此文。</p><h2 id=引言>引言</h2><p>考虑如下例子：</p><ul><li><p>main.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// cat main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> foo;
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>int</span> bar;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> foo <span style=color:#f92672>+</span> bar;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>global.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// cat global.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> foo;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> bar;
</span></span></code></pre></div></li><li><p>编译链接 & 链接报错</p><pre tabindex=0><code>$ clang -fno-PIC -fsanitize=hwaddress -c global.c -o global.o
$ clang -fno-PIC -c main.c -o main.o
$ clang -fuse-ld=lld -fsanitize=hwaddress main.o global.o -o a.out
ld.lld: error: main.o:(function main: .text+0x8): relocation R_AARCH64_ADR_PREL_PG_HI21 out of range: 3242591731706900480 is not in [-4294967296, 4294967295]; references &#39;foo&#39;
</code></pre></li></ul><p>注意：在编译 global.c 时添加了参数 <code>-fsanitize=hwaddress</code>，在编译 main.c 时没有添加参数 <code>-fsanitize=hwaddress</code>，在链接时两个编译单元生成可执行文件 a.out 时也添加了参数 <code>-fsanitize=hwaddress</code>。即目标文件 global.o 是被 HWASAN 插桩的，而目标文件 main.o 是没有被 HWASAN 插桩的，在链接 global.o 和 main.o 生成可执行文件 a.out 时，链接命令中的参数 <code>-fsanitize=hwaddress</code> 使得可执行文件 a.out 链接了 HWASAN runtime: libclang_rt.hwasan.a。</p><p>为什么编译 global.c 时添加参数 <code>-fsanitize=hwaddress</code>，而编译 main.c 时却没有添加参数 <code>-fsanitize=hwaddress</code>？</p><p>在实际开发中，一个项目通常有很多依赖库：有些依赖库是以源码形式依赖的，而有些依赖库则是以预编译好的 .a 或者 .so 的形式依赖的。所以这样的项目在使用 HWASAN 时，HWASAN 只能对那些从源码编译的部分进行插桩，对于预编译依赖库 HWASAN 则无法插桩。上述例子中在编译 main.c 时没有添加参数 <code>-fsanitize=hwaddress</code> 正是为了模拟预编译 .a 依赖库没有被 HWASAN 插桩这一情况。</p><p>实际上，上述例子正是为了分析实际项目中使用 HWASAN 时遇到的 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 这一链接错误而抽象出来的一个最小复现示例。</p><h2 id=relocation>Relocation</h2><p>在分析使用 HWASAN 时遇到的这个 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误之前，需要先了解重定位。</p><p>还是通过同一个例子来学习重定位，但暂时先抛开 HWASAN：</p><pre tabindex=0><code>$ clang -fno-PIC -c global.c -o global.o
$ clang -fno-PIC -c main.c -o main.o
$ clang -fuse-ld=lld main.o global.o -o a.out
</code></pre><p>首先通过 <code>objdump -d a.out | awk -v RS= '/^[[:xdigit:]]+ &lt;main>/'</code> 查看 a.out 中 main 函数的汇编代码：</p><pre tabindex=0><code class=language-Assembly data-lang=Assembly>00000000000107f4 &lt;main&gt;:
   107f4: d10043ff             sub        sp, sp, #0x10
   107f8: b9000fff             str        wzr, [sp, #0xc]
   107fc: 90000108             adrp        x8, 0x30000
   10800: b94b5508             ldr        w8, [x8, #0xb54]
   10804: 90000109             adrp        x9, 0x30000
   10808: b94b5929             ldr        w9, [x9, #0xb58]
   1080c: 0b090100             add        w0, w8, w9
   10810: 910043ff             add        sp, sp, #0x10
   10814: d65f03c0             ret
</code></pre><p><code>adrp x8, 0x30000</code> + <code>ldr w8, [x8, #0xb54]</code> 是从地址 0x30b54 读取 4 字节的内容保存在 x8 寄存器中，<code>adrp x9, 0x30000</code> + <code>ldr w9, [x9, #0xb58]</code> 是从地址 0x30b58 读取 4 字节的内容保存在 x9 寄存器中，<code>add w0, w8, w9</code> 是将保存在 x8 和 x9 寄存器的值相加将结果存储到 w0 寄存器中。这一系列指令对应的是源代码中的 <code>return foo + bar;</code> 这条语句，也就是说全局变量 foo 的地址是 0x30b54，全局变量 bar 的地址是 0x30b58。</p><p>如何验证：全局变量 foo 的地址是 0x30b54，全局变量 bar 的地址是 0x30b58？
通过 <code>nm</code> 命令（或 <code>readelf</code>）可以确认 a.out 中全局变量 foo 和 bar 的地址分别是 0x30b54 和 0x30b58：</p><pre tabindex=0><code>$ nm a.out | grep -E &#39;foo|bar&#39;
0000000000030b58 B bar
0000000000030b54 B foo
</code></pre><p>现在考虑这样一个问题：a.out 是 main.o 和 global.o 的链接产物，a.out 中全局变量 foo 和 bar 的地址是 0x30b54 和 0x30b58。编译单元 main.c 中引用了全局变量 foo 和 bar，而这两个全局变量是在编译单元 global.c 中定义的，编译 main.c 生成目标文件 main.o 时显然是不知道全局变量 foo 和 bar 的地址的，那么在最终链接产物 a.out 中是如何让 main 函数可以寻址到全局变量 foo 和 bar 的？</p><p>通过 <code>objdump -d main.o | awk -v RS= '/^[[:xdigit:]]+ &lt;main>/'</code> 查看 main.o 中 main 函数的汇编代码，可以看到 main.o 中获取全局变量 foo 的值的指令是 <code>adrp x8, 0</code> + <code>ldr w8, [x8]</code>。对比 a.out 中获取全局变量 foo 的值的指令是 <code>adrp x8, 0x30000</code> + <code>ldr w8, [x8, #0xb54]</code>，即 main.o 中 <code>adrp x8, 0</code> + <code>ldr w8, [x8]</code> 指令并没有填真正的全局变量 foo 的地址，而是用 0 作为占位符填到指令中。</p><pre tabindex=0><code class=language-Assembly data-lang=Assembly>0000000000000000 &lt;main&gt;:
   0:        d10043ff         sub        sp, sp, #0x10
   4:        b9000fff         str        wzr, [sp, #12]
   8:        90000008         adrp        x8, 0
   c:        b9400108         ldr        w8, [x8]
  10:        90000009         adrp        x9, 0
  14:        b9400129         ldr        w9, [x9]
  18:        0b090100         add        w0, w8, w9
  1c:        910043ff         add        sp, sp, #0x10
  20:        d65f03c0         ret
</code></pre><p>main.o 中是不知道全局变量 foo 和 bar 地址的，a.out 是知道全局变量 foo 和 bar 地址的，所以其实可以猜到是链接器在链接时将引用全局变量 foo 的指令 <code>adrp x8, 0</code> + <code>ldr w8, [x8]</code> 修改为 <code>adrp x8, 0x30000</code> + <code>ldr w8, [x8, #0xb54]</code>，填入了全局变量 foo 的地址。这其实就是重定位 (relocation)，重定位就是在链接器确定每个符号定义的地址后，修改所有对这些符号的引用，使之指向这些符号定义的地址。</p><p>那么链接器是怎么知道哪些位置需要重定位的？答案是依赖于保存在目标文件中的重定位信息。</p><p>可以通过 <code>readelf -rW</code> 查看重定位信息。</p><pre tabindex=0><code>$ readelf -rW main.o
Relocation section &#39;.rela.text&#39; at offset 0x1d8 contains 4 entries:
    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
0000000000000008  0000000700000113 R_AARCH64_ADR_PREL_PG_HI21 0000000000000000 foo + 0
000000000000000c  000000070000011d R_AARCH64_LDST32_ABS_LO12_NC 0000000000000000 foo + 0
0000000000000010  0000000800000113 R_AARCH64_ADR_PREL_PG_HI21 0000000000000000 bar + 0
0000000000000014  000000080000011d R_AARCH64_LDST32_ABS_LO12_NC 0000000000000000 bar + 0
</code></pre><p>根据上述重定位信息可知：</p><ol><li><p>在 main.o 的 text section 偏移为 0x8 处和 0xc 处引用了符号 foo，重定位类型分别为 R_AARCH64_ADR_PREL_PG_HI21 和 R_AARCH64_LDST32_ABS_LO12_NC</p></li><li><p>在 main.o 的 text section 偏移为 0x10 处和 0x14 处引用了符号 bar，重定位类型分别为 R_AARCH64_ADR_PREL_PG_HI21 和 R_AARCH64_LDST32_ABS_LO12_NC</p></li></ol><p>注：</p><ul><li><p><code>Offset</code>：需要修改的符号引用的位置。在本例中表示需要修改的符号引用的位置相对 text section 起始位置的偏移量（字节）。</p></li><li><p><code>Type</code>：重定位类型。用于指示链接器如何修改该符号引用的值。</p></li><li><p><code>Info</code>：低 4 字节表示重定位类型，高 4 字节表示表示符号表索引。符号表索引表示需要修改的符号引用在 <code>.symtab</code> section 中的索引。</p><p>重定位类型 R_AARCH64_ADR_PREL_PG_HI21 对应编号就是 0x113=275，重定位类型 R_AARCH64_LDST32_ABS_LO12_NC 对应编号就是 0x11d=285</p><p><code>Symbol's Value</code> 和 <code>Symbol's Name</code> 就是对应的 <code>.symtab</code> section 条目中 <code>Value</code> 和<code>Name</code> 的值。</p><pre tabindex=0><code>$ readelf -sW main.o
Symbol table &#39;.symtab&#39; contains 9 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     7: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND foo
     8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND bar
</code></pre></li><li><p><code>Addend</code>：有符号常数，一些重定位类型要使用它对被修改符号引用的值做偏移调整。</p></li></ul><hr><p>下面详解链接器将引用全局变量 foo 的指令 <code>adrp x8, 0</code> + <code>ldr w8, [x8]</code> 修改为 <code>adrp x8, 0x30000</code> + <code>ldr w8, [x8, #0xb54]</code> 的重定位过程：</p><p>根据 <a href=https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation>https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation</a> 可以找到重定位类型 R_AARCH64_ADR_PREL_PG_HI21 和 R_AARCH64_LDST32_ABS_LO12_NC 的重定位计算公式：</p><table><thead><tr><th>Code</th><th>Name</th><th>Operation</th><th>Comment</th></tr></thead><tbody><tr><td>275</td><td>R_AARCH64_ADR_PREL_PG_HI21</td><td>Page(S+A)-Page(P)</td><td>Set an ADRP immediate value to bits [32:12] of the X; check that -2^32 &lt;= X &lt; 2^32</td></tr><tr><td>285</td><td>R_AARCH64_LDST32_ABS_LO12_NC</td><td>S + A</td><td>Set the LD/ST immediate value to bits [11:2] of X. No overflow check</td></tr></tbody></table><p>注：</p><ul><li><p><code>S</code> (when used on its own) is the address of the symbol.</p></li><li><p><code>A</code> is the addend for the relocation</p></li><li><p><code>P</code> is the address of the place being relocated (derived from <code>r_offset</code>).</p></li><li><p><code>X</code> is the result of a relocation operation, before any masking or bit-selection operation is applied</p></li><li><p><code>Page(expr)</code> is the page address of the expression expr, defined as (expr & ~0xFFF). (This applies even if the machine page size supported by the platform has a different value.)</p></li></ul><hr><ol><li><p>将 <code>adrp x8, 0</code> 修改为 <code>adrp x8, 0x30000</code>的重定位过程</p><ul><li><p>重定位信息</p><pre tabindex=0><code>Relocation section &#39;.rela.text&#39; at offset 0x1d8 contains 4 entries:
    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
0000000000000008  0000000700000113 R_AARCH64_ADR_PREL_PG_HI21 0000000000000000 foo + 0
</code></pre></li><li><p><code>readelf -sW a.out</code> 找到符号 foo 最终所在的地址是 0x30b54，即 <code>S</code> = 0x30b54</p></li><li><p>根据重定位信息可知 addend 为 0 即 <code>A</code> = 0</p></li><li><p><code>objdump -d a.out</code> 找到 <code>adrp x8, 0</code> 指令最终在 a.out 中的地址为 0x107f4 + 0x8，即 <code>P</code> = 0x107fc</p></li><li><p><code>X</code> = Page(S+A)-Page(P) = Page(0x30b54 + 0) - Page(0x107fc) = (0x30b54 & ~0xFFF) - (0x107fc & ~0xFFF) = 0x20000</p></li><li><p>R_AARCH64_ADR_PREL_PG_HI21 类型的重定位操作是 &ldquo;Set an ADRP immediate value to bits [32:12] of the X; check that -2^32 &lt;= X &lt; 2^32&rdquo;</p><p>显然 -2^32 &lt;= 0x20000 &lt; 2^32，所以接下来就是将 <code>adrp x8, 0</code> 指令的 immediate value 设置为 0x20000 的 [32:12] bits。</p><p><code>ADRP</code> 指令编码如下，[30:29] bits 是 immediate value low bits, [23:5] for immediate value high bits。</p><p><img src=/blog/learn-relocation-by-debugging-a-hwasan-linker-error/adrp-inst-encoding.png alt></p><p>重定位之前 <code>adrp x8, 0</code> 指令的编码为 0x90000008 即 <code>1001 0000 0000 0000 0000 0000 0000 1000</code>，将 <code>adrp x8, 0</code> 指令的 immediate value 设置为 0x20000 的 [32:12] bits 即 0b100000，就是将 <code>adrp x8, 0</code> 指令的 immediate value low bits 设置为 0b00，将 <code>adrp x8, 0</code> 指令的 immediate value high bits 为 0b1000，所以重定位之后后指令编码变为 <code>1001 0000 0000 0000 0000 0001 0000 1000</code> 即 0x90000108。</p><p>对指令 0x90000108 进行解码：<code>107fc: 90000108 adrp x8, 0x30000</code>：当前 PC 值为 0x107fc，PC with its bottom 12 bits cleared 为 0x10000，immediate value 即 0b100000 左移 12 位为 0x20000，然后 0x10000 + 0x20000 = 0x30000，destination register 为 0b1000 即 x8 寄存器，所以该指令表示将 0x30000 保存在 x8 寄存器中。</p></li></ul></li><li><p>将 <code>ldr w8, [x8]</code> 修改为 <code>ldr w8, [x8, #0xb54]</code>的重定位过程</p><ul><li><p>重定位信息</p><pre tabindex=0><code>    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
000000000000000c  000000070000011d R_AARCH64_LDST32_ABS_LO12_NC 0000000000000000 foo + 0
</code></pre></li><li><p><code>readelf -sW a.out</code> 找到符号 foo 最终所在的地址是 0x30b54，即 <code>S</code> = 0x30b54</p></li><li><p>根据重定位信息可知 addend 为 0 即 <code>A</code> = 0</p></li><li><p><code>X</code> = S+A = 0x30b54 + 0 = 0x30b54</p><p>R_AARCH64_LDST32_ABS_LO12_NC 类型的重定位操作是 &ldquo;Set the LD/ST immediate value to bits [11:2] of X. No overflow check&rdquo;</p><p><code>X</code> = 0x30b54 的 [11:2] bits 为 0b1011010101。</p><p><code>ldr w9, [x8]</code> 指令的编码为 0xb9400108 即 <code>1011 1001 0100 0000 0000 0001 0000 1000</code>，[21:10] bits 为 immediate value。</p><p><img src=/blog/learn-relocation-by-debugging-a-hwasan-linker-error/ldr-inst-encoding.png alt></p><p>注：</p><ul><li><p><code>&lt;Wt></code>: Is the 32-bit name of the general-purpose register to be transferred, encoded in the &ldquo;Rt&rdquo; field.</p></li><li><p><code>&lt;Xt></code>: Is the 64-bit name of the general-purpose register to be transferred, encoded in the &ldquo;Rt&rdquo; field.</p></li><li><p><code>&lt;Xn|SP></code>: Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the &ldquo;Rn&rdquo; field.</p></li><li><p><code>&lt;pimm></code>: For the 32-bit variant: is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the &ldquo;imm12&rdquo; field as /4. For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the &ldquo;imm12&rdquo; field as /8</p></li></ul><p>重定位之前指令的编码为 0xb9400108 即 <code>1011 1001 0100 0000 0000 0001 0000 1000</code>，将指令的 immediate value 设置为 0b1011010101 得到重定位之后指令的编码为 <code>1011 1001 0100 1011 0101 0101 0000 1000</code> 即 0xb94b5508。</p><p>对指令 0xb94b5508 进行解码：<code>ldr w9, [x8, #0xb54]</code>：size = 0b10，Rt = 0b01000 = 8，Rn = 0b01000 = 8，imm12 = 0b1011010101，<code>&lt;Wt></code> = w8 寄存器，<code>&lt;Xn|SP></code> = x8 寄存器，<code>#&lt;pimm> = 0b1011010101 * 4 = 0xb54</code>，因此该指令表示从内存地址 x8 + 0xb54 处读取 4 字节内容保存在 w8 寄存器中。</p></li></ul></li></ol><h2 id=hwasan-relocation-overflow>HWASAN relocation overflow</h2><p>了解重定位后，就可以对本文最开始提到的 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误进行分析了：</p><pre tabindex=0><code>$ clang -fno-PIC -fsanitize=hwaddress -c global.c -o global.hwasan.o
$ clang -fno-PIC -c main.c -o main.o
$ clang -fuse-ld=lld -fsanitize=hwaddress main.o global.hwasan.o -o a.out
ld.lld: error: main.o:(function main: .text+0x8): relocation R_AARCH64_ADR_PREL_PG_HI21 out of range: 3242591731706900480 is not in [-4294967296, 4294967295]; references &#39;foo&#39;
</code></pre><p>为了方便分析，可以通过链接器提供的 <code>-noinhibit-exec</code> 选项，使得尽管出现 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误仍然能够生成链接产物 a.out。</p><pre tabindex=0><code>$ clang -Wl,-noinhibit-exec -fuse-ld=lld -fsanitize=hwaddress main.o global.hwasan.o -o a.out
$ readelf -sW a.out | grep -E &#34;foo|bar&#34;
  2442: 2d0000000009bae0     4 OBJECT  GLOBAL DEFAULT   26 foo
  2443: 2e0000000009baf0     4 OBJECT  GLOBAL DEFAULT   26 bar
</code></pre><p>通过 <code>readelf -rW</code> 查看重定位信息，由重定位信息可知：在 main.o 的 text section 偏移为 0x8 处引用了符号 foo，重定位类型分别为 R_AARCH64_ADR_PREL_PG_HI21。</p><pre tabindex=0><code>$ readelf -rW main.o
Relocation section &#39;.rela.text&#39; at offset 0x1d8 contains 4 entries:
    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
0000000000000008  0000000700000113 R_AARCH64_ADR_PREL_PG_HI21 0000000000000000 foo + 0
000000000000000c  000000070000011d R_AARCH64_LDST32_ABS_LO12_NC 0000000000000000 foo + 0
0000000000000010  0000000800000113 R_AARCH64_ADR_PREL_PG_HI21 0000000000000000 bar + 0
0000000000000014  000000080000011d R_AARCH64_LDST32_ABS_LO12_NC 0000000000000000 bar + 0
</code></pre><p>根据上一节 &ldquo;Relocation&rdquo; 的内容，R_AARCH64_ADR_PREL_PG_HI21 的重定位计算方式为 <code>Page(S+A)-Page(P)</code>。</p><ul><li><p><code>S</code> 即 符号 foo 的地址。通过 <code>readelf -sW a.out</code> 找到符号 foo 的地址是 0x2d0000000009bae0，即 <code>S</code> = 0x2d0000000009bae0</p></li><li><p><code>A</code> 即 addend。根据重定位信息可知 addend 为 0 即 <code>A</code> = 0</p></li><li><p><code>P</code> 即 需要进行重定位的位置。<code>objdump -d a.out</code> 找到 <code>adrp x8, 0</code> 指令最终在 a.out 中的地址为 0x780d8 + 0x8，即 <code>P</code> = 0x780e0</p></li><li><p>计算 <code>X</code> = Page(S+A)-Page(P) = Page(0x2d0000000009bae0 + 0) - Page(0x780e0) = (0x2d0000000009bae0 & ~0xFFF) - (0x780e0 & ~0xFFF) = 3242591731706900480</p></li><li><p>R_AARCH64_ADR_PREL_PG_HI21 类型的重定位操作是 &ldquo;Set an ADRP immediate value to bits [32:12] of the X; check that -2^32 &lt;= X &lt; 2^32&rdquo;，显然 3242591731706900480 不在 [-2^32, 2^32) 区间内，所以链接器报错 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo;</p></li></ul><hr><p>所以接下来问题就是为什么编译 global.c 时开启 HWASAN 后使得符号 foo 的地址变为了 3242591731706900480 这么大的值。</p><p>查看 global.hwasan.o 对应的汇编代码，可以看到 HWASAN 为 global.c 额外生成了 4 个 STT_OBJECT 符号 <code>.Lfoo.hwasan</code> 和 <code>.Lfoo.hwasan.descriptor</code>，<code>.Lbar.hwasan</code> 和 <code>.Lbar.hwasan.descriptor</code>：</p><pre tabindex=0><code class=language-Assembly data-lang=Assembly>$ clang -fno-PIC -fsanitize=hwaddress -S global.c -o -
        .type        .Lfoo.hwasan,@object            // @foo.hwasan
        .data
        .p2align        4, 0x0
.Lfoo.hwasan:
        .word        0                               // 0x0
        .ascii        &#34;\000\000\000\000\000\000\000\000\000\000\000-&#34;
        .size        .Lfoo.hwasan, 16

        .type        .Lfoo.hwasan.descriptor,@object // @foo.hwasan.descriptor
        .section        hwasan_globals,&#34;ao&#34;,@progbits,.Lfoo.hwasan,unique,2
        .p2align        3, 0x0
.Lfoo.hwasan.descriptor:
        .word        .Lfoo.hwasan-.Lfoo.hwasan.descriptor
        .word        754974724                       // 0x2d000004
        .size        .Lfoo.hwasan.descriptor, 8

        .type        .Lbar.hwasan,@object            // @bar.hwasan
        .data
        .p2align        4, 0x0
.Lbar.hwasan:
        .word        0                               // 0x0
        .ascii        &#34;\000\000\000\000\000\000\000\000\000\000\000.&#34;
        .size        .Lbar.hwasan, 16

        .type        .Lbar.hwasan.descriptor,@object // @bar.hwasan.descriptor
        .section        hwasan_globals,&#34;ao&#34;,@progbits,.Lbar.hwasan,unique,3
        .p2align        3, 0x0
.Lbar.hwasan.descriptor:
        .word        .Lbar.hwasan-.Lbar.hwasan.descriptor
        .word        771751940                       // 0x2e000004
        .size        .Lbar.hwasan.descriptor, 8

        .globl        foo
.set foo, .Lfoo.hwasan+3242591731706757120
        .size        foo, 4
        .globl        bar
.set bar, .Lbar.hwasan+3314649325744685056
        .size        bar, 4
</code></pre><ul><li><p><code>.Lfoo.hwasan</code> 的大小为 16-bytes，为 16-bytes 对齐，前 15-bytes 被初始化为 0x0，最后一个 byte 被初始化为 0x2d。<code>.Lfoo.hwasan.descriptor</code> 顾名思义就是用于描述 <code>.Lfoo.hwasan</code> 的，保存在最终链接二进制的 hwasan_globals section 中，<code>.Lfoo.hwasan.descriptor</code> 依次保存了以下内容：<code>.Lfoo.hwasan</code> 相对于自己的偏移（占 4-bytes）、<code>.Lfoo.hwasan</code> 对应的全局变量 foo 的 size and tag（共占 4-bytes，tag 保存在 top-byte，size 保存在低 3-bytes），全局变量 foo 的 size 为 4-bytes，tag 为 0x2d。</p></li><li><p><code>.Lbar.hwasan</code> 的大小为 16-bytes，为 16-bytes 对齐，前 15-bytes 被初始化为 0x0，最后一个 byte 被初始化为 0x2e。<code>.Lbar.hwasan.descriptor</code> 依次保存了以下内容：<code>.Lbar.hwasan</code> 相对于自己的偏移（占 4-bytes）、<code>.Lbar.hwasan</code> 对应的全局变量 bar 的 size and tag（共占 4-bytes，tag 保存在 top-byte，size 保存在低 3-bytes），全局变量 bar 的 size 为 4-bytes，tag 为 0x2e。</p></li><li><p>需要注意，开启 HWASAN 后定义全局变量 fo o 是通过 <a href=https://sourceware.org/binutils/docs/as/Set.html>.set assembler directive</a> 将全局变量 foo 的地址设置为 <code>.Lfoo.hwasan</code> 的地址 + 0x2d00000000000000，定义全局变量 bar 是通过 <a href=https://sourceware.org/binutils/docs/as/Set.html>.set assembler directive</a> 将全局变量 bar 的地址设置为 <code>.Lbar.hwasan</code> 的地址 + 0x2e00000000000000</p></li></ul><p>正是因为全局变量 foo 的地址被设置为 <code>.Lfoo.hwasan</code> 的地址 + 0x2d00000000000000，所以在最终的链接产物中符号 foo 的地址才变为了 3242591731706900480=0x2d00000000023000 这么大的值，导致出现 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 这一链接错误。</p><hr><p>那么为什么开启 HWASAN 后会创建 STT_OBJECT 符号 <code>.Lfoo.hwasan</code>，然后通过 <code>.set foo, .Lfoo.hwasan+3242591731706757120</code> 这种方式来设置全局变量 foo 的地址？</p><p>这涉及到 HWASAN 的原理，AArch64 的 TBI 特性使得软件可以在 64-bit 虚拟地址的最高字节中存储任意数据，HWASAN 正是基于 TBI 这一特性设计并实现的内存错误检测工具（关于 HWASAN 原理可以阅读我之前写过一篇文章 <a href=https://enna1.github.io/post/hwasan-internals/>HWASAN Internals - Enna1&rsquo;s website</a>）</p><ul><li><p>HWASAN 为了检测全局变量相关的内存错误，会为全局变量生成一个随机 tag 保存在全局变量地址的最高字节。全局变量的随机 tag 是基于其所在的编译单元文件路径计算得到的，在编译时插桩阶段，对于编译单元内的第一个全局变量，其 tag 是对当前编译单元文件路径计算 MD5 哈希值然后取第一个字节得到的，对于编译单元内的后续全局变量，其 tag 则是基于之前全局变量的 tag 递增得到的。</p><p>本例中，全局变量 foo 所在的编译单元就是 global.c，MD5 (&ldquo;global.c&rdquo;) = 2d5bdd4d2c44c739a456d749bb3e94a0，所以全局变量 foo 的 tag 就是 0x2d，<code>.set foo, .Lfoo.hwasan+3242591731706757120</code> 中的 3242591731706757120 就是由 <code>0x2d&lt;&lt;56</code> 计算而来，全局变量 bar 的 tag 就是 0x2d+1=0x2e，<code>.set foo, .Lfoo.hwasan+3314649325744685056</code> 中的 3314649325744685056 就是由 <code>0x2e&lt;&lt;56</code> 计算而来。</p><pre tabindex=0><code>$ echo -n global.c | md5sum
2d5bdd4d2c44c739a456d749bb3e94a0  -
$ echo $((0x2d&lt;&lt;56))
3242591731706757120
$ echo $((0x2e&lt;&lt;56))
3314649325744685056
</code></pre></li><li><p>HWASAN 除了将生成的随机 tag 保存在全局变量地址的最高字节，还会将随机 tag 保存在全局变量对应的 shadow memory 中。</p><p>HWASAN 会将每 16-bytes 的 application memory 对应 1-byte 的 shadow memory，所以如果全局变量的大小不是 16-bytes 对齐的，那么会为全局变量添加 padding 使其对齐到 16-bytes。这就是为什么全局变量 foo 的大小是 4-bytes 而 <code>.Lfoo.hwasan</code> 的大小则是 16-bytes 且对齐也是 16-bytes。</p><p>保存在 &ldquo;hwasan_globals&rdquo; section 中的 <code>.Lfoo.hwasan.descriptor</code> 就是用于设置全局变量 foo 对应的 shadow memory 的。在程序启动时 HWASAN runtime 会遍历 “hwasan_globals” section 中所有的 descriptor，根据 descriptor 中保存的全局变量的大小以及 tag 等信息来设置每个全局变量对应的 shadow memory tag。</p></li></ul><h2 id=总结>总结</h2><p>至此本文中引言中提到的 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 这一链接错误的根本原因就清晰了：因 main.c 在编译时是没有开启 HWASAN，而 global.c 在编译时是开启 HWASAN 的，所以定义在 global.c 中的全局变量/符号的地址的 top byte 是被 HWASAN 添加了 tag 的。在 main.c 编译生成的目标文件 main.o 中是通过指令组合 <code>adrp</code> + <code>ldr</code> 来访问全局变量的，且 <code>adrp</code> 处对应的 relocation type 为 R_AARCH64_ADR_PREL_PG_HI21。对 R_AARCH64_ADR_PREL_PG_HI21 该重定位类型链接器在重定位时会检查 <code>X = Page(S+A)-Page(P)</code> 的值是否在 [-2^32, 2^32) 区间内，由于全局变量/符号的地址的 top byte 被 HWASAN 添加了 tag，所以 <code>X = Page(S+A)-Page(P)</code> 一定溢出了 [-2^32, 2^32) 区间，所以链接器在重定位时出现了上述 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 的报错。</p><p>最后介绍下解决本文例子 &ldquo;relocation R_AARCH64_ADR_PREL_PG_HI21 out of range&rdquo; 链接错误的几种方案：</p><ol><li><p>编译 main.c 和 global.c 时都开启 HWASAN，最简单直接</p><pre tabindex=0><code>$ clang -fno-PIC -fsanitize=hwaddress -c global.c -o global.hwasan.o
$ clang -fno-PIC -fsanitize=hwaddress -c main.c -o main.hwasan.o
$ clang -fuse-ld=lld -fsanitize=hwaddress main.hwasan.o global.hwasan.o -o a.out
</code></pre><p>这是因为编译 main.c 开启 HWASAN 会生成特别的汇编指令，在 main 函数中会通过 <code>adrp</code> + <code>movk</code> + <code>add</code> 的指令组合来获取全局变量 foo 的地址，并且这三条指令对应的重定位类型分别为 R_AARCH64_ADR_PREL_PG_HI21_NC, R_AARCH64_MOVW_PREL_G3 和 R_AARCH64_ADD_ABS_LO12_NC</p><pre tabindex=0><code>$ objdump -d main.hwasan.o | awk -v RS= &#39;/^[[:xdigit:]]+ &lt;main&gt;/&#39;
  ...
  38:        90000000         adrp        x0, 0 &lt;foo&gt;
  3c:        f2e00000         movk        x0, #0x0, lsl #48
  40:        91000000         add        x0, x0, #0x0
  ...
$ readelf -rW main.hwasan.o
    Offset             Info             Type               Symbol&#39;s Value  Symbol&#39;s Name + Addend
0000000000000038  0000001200000114 R_AARCH64_ADR_PREL_PG_HI21_NC 0000000000000000 foo + 0
000000000000003c  0000001200000125 R_AARCH64_MOVW_PREL_G3 0000000000000000 foo + 100000000
0000000000000040  0000001200000115 R_AARCH64_ADD_ABS_LO12_NC 0000000000000000 foo + 0
</code></pre></li><li><p>编译 main.c 不开启 HWASAN，编译 global.c 时开启 HWASAN，但是编译 main.c 时开启 PIC</p><pre tabindex=0><code>$ clang -fno-PIC -fsanitize=hwaddress -c global.c -o global.hwasan.o
$ clang -fPIC -c main.c -o main.pic.o
$ clang -fuse-ld=lld -fsanitize=hwaddress main.pic.o global.hwasan.o -o a.out
</code></pre><p>这是因为编译 main.c 开启 PIC 后，main 函数访问全局变量 foo/bar 就是通过 GOT 来间接访问的，所以重定位类型会变为 R_AARCH64_ADR_GOT_PAGE 和 R_AARCH64_LD64_GOT_LO12_NC，也就不会出现 relocation overflow：</p><pre tabindex=0><code>0000000000000038  0000001200000137 R_AARCH64_ADR_GOT_PAGE 0000000000000000 foo + 0
000000000000003c  0000001200000138 R_AARCH64_LD64_GOT_LO12_NC 0000000000000000 foo + 0
000000000000004c  0000001400000137 R_AARCH64_ADR_GOT_PAGE 0000000000000000 bar + 0
0000000000000050  0000001400000138 R_AARCH64_LD64_GOT_LO12_NC 0000000000000000 bar + 0
</code></pre></li><li><p>编译 main.c 不开启 HWASAN，编译 global.c 时开启 HWASAN，但是关闭 HWASAN 对全局变量相关的内存错误的检测。</p><pre tabindex=0><code>$ clang -fno-PIC -fsanitize=hwaddress -mllvm -hwasan-globals=0 -c global.c -o global.hwasan.noglobals.o
$ clang -fno-PIC -c main.c -o main.o
$ clang -fuse-ld=lld -fsanitize=hwaddress main.pic.o global.hwasan.noglobals.o -o a.out
</code></pre></li></ol><h2 id=参考链接>参考链接</h2><ul><li><p><a href=https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation>https://github.com/ARM-software/abi-aa/blob/main/aaelf64/aaelf64.rst#relocation</a></p></li><li><p><a href=https://developer.arm.com/documentation/ddi0487/latest/>https://developer.arm.com/documentation/ddi0487/latest/</a></p></li></ul><h2 id=ps>P.S.</h2><p>我在调试 lld 学习重定位时，在 lld/ELF/Symbols.cpp 中看到如下代码注释，分享出来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>    <span style=color:#75715e>// In the typical case, this is actually very simple and boils
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// down to adding together 3 numbers:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 1. The address of the output section.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 2. The offset of the input section within the output section.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 3. The offset within the input section (this addition happens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    inside InputSection::getOffset).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If you understand the data structures involved with this next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// line (and how they get built), then you have a pretty good
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// understanding of the linker.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint64_t</span> va <span style=color:#f92672>=</span> isec<span style=color:#f92672>-&gt;</span>getVA(offset);
</span></span></code></pre></div></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/sanitizer/ rel=tag>Sanitizer</a></li><li class=tags__item><a class="tags__link btn" href=/tags/llvm/ rel=tag>LLVM</a></li></ul></div></footer></article></main><section class=comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//enna1-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://enna1.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/learn-relocation-by-debugging-a-hwasan-linker-error/>Learn Relocation by Debugging a HWASAN Linker Error</a></li><li class=widget__item><a class=widget__link href=/random/2023-5-15-a-whirlwind-tour-of-the-llvm-optimizer/>A whirlwind tour of the LLVM optimizer</a></li><li class=widget__item><a class=widget__link href=/post/hwasan-internals/>HWASAN Internals</a></li><li class=widget__item><a class=widget__link href=/post/inside-asan-allocator/>Inside AddressSanitizer Allocator</a></li><li class=widget__item><a class=widget__link href=/random/2022-12-31-summary/>2022 年度总结</a></li><li class=widget__item><a class=widget__link href=/post/strict_aliasing-tbaa-and-type_sanitizer/>Strict Aliasing, TBAA and TypeSanitizer</a></li><li class=widget__item><a class=widget__link href=/post/dissecting-thread-sanitizer/>Dissecting ThreadSanitizer Algorithm</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-get-stacktrace/>How Sanitizer Get Stack Trace</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-interceptor-works/>How Sanitizer Interceptor Works</a></li><li class=widget__item><a class=widget__link href=/post/how-sanitizer-runtime-init/>How Sanitizer Runtime Initialized</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/programming/>Programming</a></li><li class=widget__item><a class=widget__link href=/categories/random/>Random</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++</a>
<a class="widget-taglist__link widget__link btn" href=/tags/data-race/ title="Data Race">Data Race</a>
<a class="widget-taglist__link widget__link btn" href=/tags/llvm/ title=LLVM>LLVM</a>
<a class="widget-taglist__link widget__link btn" href=/tags/sanitizer/ title=Sanitizer>Sanitizer</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vectorizer/ title=Vectorizer>Vectorizer</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Enna1 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:xumingjie.enna1@bytedance.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>xumingjie.enna1@bytedance.com</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Blog RSS" rel="noopener noreferrer" href=/post/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Blog RSS</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title="Podcast RSS" rel="noopener noreferrer" href=/podcast/index.xml target=_blank><svg class="widget-social__link-icon icon icon-rss" width="24" height="24" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg><span>Podcast RSS</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Enna1.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>